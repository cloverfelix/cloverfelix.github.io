[{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了  结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new G","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["SQL常见问题"],"content":"SQL常见问题","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["SQL常见问题"],"content":"SQL常见问题 建立新连接时报错：can’t connect to mysql server on ‘localhost’ 原因：是因为本地服务器没开启 解决：用系统管理员打开命令行，输入net start mysql57启动服务器（这里如果是启动8.0服务器就是net start mysql80） 双数据库情况下，在普通命令行不输入密码直接进到mysql下服务器下 先进入mysql安装目录下的bin目录下 再输入mysql -uroot -P 3306 -p命令 直接回车，不需要输入密码 解决数据库建立新连接时报错access denied for user ‘root’@‘localhost’以及mysql命令行工具闪退问题 解决： 到安装的MySQL的目录下，找my.ini文件，在[mysqld]后添加skip-grant-tables，保存退出 在命令行中进入mysql安装目录下的bin目录 输入mysql -uroot -P 3306 -p命令（这里端口号要对应）（作用：使其登录时跳过权限检查） 直接回车，不用输入密码 输入ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 修改密码 报错： flush privileges; 刷新权限 再修改密码ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 成功 参考博客：https://blog.csdn.net/weixin_43589074/article/details/107728819 ","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["Spring"],"content":"Spring","date":"2021-06-26","objectID":"/spring/","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"111111111111111111111111111111111111111111 ","date":"2021-06-26","objectID":"/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring/"}]