[{"categories":["JavaWeb"],"content":"javaweb","date":"2021-07-04","objectID":"/javaweb/","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、基本概念 ","date":"2021-07-04","objectID":"/javaweb/:0:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.1、静态web 静态web存在的缺点 web页面无法更新 它无法和数据库交互（数据无法持久化，用户无法交互） ","date":"2021-07-04","objectID":"/javaweb/:1:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.2、动态web 页面会动态展示：“web的页面展示的效果因人而异” 动态web存在的缺点： 假如服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布； 动态web的优点： Web页面可以动态更新，所有用户看到的都不是同一个页面 它可以与数据库交互 2、web服务器 ","date":"2021-07-04","objectID":"/javaweb/:2:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.1、技术讲解 PHP： PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大量访问的情况 JSP/Servlet： B/S：浏览器和服务器 C/S：客户端和服务器 sun公司主推的B/S架构 基于Java语言（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响 高可用 高并发 高性能 语法像ASP ","date":"2021-07-04","objectID":"/javaweb/:3:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.2、web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息 IIS 微软的：ASP…….，Windows中自带的 Tomcat 下载tomcat： 解压 or 安装 了解配置文件以及目录结构 这个东西的作用 3、Tomcat ","date":"2021-07-04","objectID":"/javaweb/:4:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.1、安装Tomcat Tomcat官网 ","date":"2021-07-04","objectID":"/javaweb/:5:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.2、Tomcat启动和配置 文件夹的作用 访问测试：Tomcat测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 ","date":"2021-07-04","objectID":"/javaweb/:6:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.3、配置 可以配置启动的端口号 tomcat的默认端口是：8080 \u003cConnector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 可以配置主机的名称 默认主机名为：localhost—\u003e127.0.0.1 默认网站应用存放的位置：webapps \u003cHost name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"\u003e 高难度面试题： 请你谈谈网站是如何进行访问的！ 1. 输入一个域名；回车 2. 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 1. 有：直接返回对应的IP地址，这个地址中，有我们需要访问的web程序，可以直接访问 2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到 ","date":"2021-07-04","objectID":"/javaweb/:7:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.4、发布一个web网站 查看Tomcat自带的一些样例 将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 网站应有的结构 --webapps ：Tomcat服务器的web目录 --ROOT --clover ： 网站的目录名 - WEB-INF - classes ： Java程序 - lib ：web应用所有依赖的jar包 - web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img 4、Http ","date":"2021-07-04","objectID":"/javaweb/:8:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.1、什么是Http HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上 文本：html，字符串 超文本： 图片，音乐，视频，定位，地图。。。。。 默认端口：80 HTTPS：安全的 默认端口：443 ","date":"2021-07-04","objectID":"/javaweb/:9:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.2、两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，就断开连接。 http2.0 HTTP/2.0：客户端可以与web服务器连接后，可以获得多个web资源。 ","date":"2021-07-04","objectID":"/javaweb/:10:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.3、HTTP请求 客户端—发请求–服务器 1. Request URL: https://www.baidu.com/ 请求地址 2. Request Method: GET get方法/post方法 3. Status Code: 200 OK 状态码：200 4. Remote Address: 14.215.177.39:443 远程地址 ","date":"2021-07-04","objectID":"/javaweb/:11:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT get：一次请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效。 post：一次请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 ","date":"2021-07-04","objectID":"/javaweb/:11:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、消息头 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 ","date":"2021-07-04","objectID":"/javaweb/:11:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.4、HTTP响应 服务器—响应—客户端 百度： Cache-Control: private 缓存控制 Connection: keep-alive 连接 Content-Encoding: gzip 编码 Content-Type: ext/html 类型 ","date":"2021-07-04","objectID":"/javaweb/:12:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、响应体 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 Refrush：告诉客户端多久刷新一次 Location： 让网页重新定位 ","date":"2021-07-04","objectID":"/javaweb/:12:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、相应状态码 200：代表请求响应成功 3**：请求重定向 重定向：你重新到我给你的新位置去 4xx：找不到资源 资源不存在 5xx：服务器代码错误 502：网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么！ 5、Maven ","date":"2021-07-04","objectID":"/javaweb/:12:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.1、Maven项目架构管理工具 我们目前用来就是方便导入Jar包的！ Maven的核心思想：约定大于配置 有约束就不要去违反 Maven会规定好你该如何去编写我们的Java代码，必须按照这个规定来 ","date":"2021-07-04","objectID":"/javaweb/:13:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.2、配置环境变量 在系统环境变量中配置如下配置： M2_HOME maven 目录下的bin目录 MAVEN_HOME　maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 测试maven是否安装成功，必须配置完毕 ","date":"2021-07-04","objectID":"/javaweb/:14:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.3、阿里云镜像 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2021-07-04","objectID":"/javaweb/:15:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.4、本地仓库 有本地仓库，就有远程仓库！ 建立一个本地仓库：localRepository \u003clocalRepository\u003eE:\\maven repository\\.m2\\repository\u003c/localRepository\u003e ","date":"2021-07-04","objectID":"/javaweb/:16:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.5、IDEA使用Maven Maven官网：https://mvnrepository.com/ IDEAMaven自动配置问题 在IDEA中标记文件夹功能 ","date":"2021-07-04","objectID":"/javaweb/:17:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.6、配置Tomcat的问题 解决警告问题 必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹的名字 maven由于它的约定大于配置，我们之后可能遇到我们写的配置文件，无法被导出或者生效的问题。 解决方案： \u003c!--在build中配置resources，来防止我们资源导出失败的问题--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 6、Servlet ","date":"2021-07-04","objectID":"/javaweb/:18:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.1、HelloSevlet Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建议Moudel； 这个空的工程就是Maven主工程 关于Maven父子工程的理解： 父项目中会有 \u003cmodules\u003e \u003cmodule\u003eservlet-01\u003c/module\u003e \u003c/modules\u003e 子项目会有 \u003cparent\u003e \u003cartifactId\u003ejavaweb-03-servlet\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e 父项目中的Jar包子项目可以直接使用，而子项目中的jar包父项目不可以使用 Maven环境优化 修改web.xml为最新版本（可以去tomcat中的webapps里面找到） 将Maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.print(\"Hello,Servlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写Servlet映射 为什么需要映射：我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所 有我们需要在web服务器中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径； \u003c!--注册Servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!-- Servlet的请求路径--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 配置tomcat 注意：配置项目的发布路径就可以了 启动测试 ","date":"2021-07-04","objectID":"/javaweb/:19:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.2、Servlet原理 Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会有如下操作： ","date":"2021-07-04","objectID":"/javaweb/:20:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.3、Mapping 一个Servlet请求可以指定一个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定多个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello5\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定通用映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\\*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 默认请求路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 指定一些后缀或者前缀等等 \u003c!--可以自定义后缀实现请求映射 注意点：*前面不能加项目映射的路径 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e*.clover\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求了 \u003c!--404--\u003e \u003cservlet\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ErrorServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 注意：在使用IDEA创建多个webapps工程时，在第二个运行可能会出现404找不到资源问题 这里是因为新创建的webapps文件上没有带蓝色点点,需要自己手动去加上，然后运行才会成功。 如若创建新的工程的pom.xml中没有parent那一行，重新创建即可 另外在创建新文件时应当先创建java跟resources两个文件夹，并且要标记，否则无法创建package ","date":"2021-07-04","objectID":"/javaweb/:21:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.4、ServletContext web容器在启动的时候，它会为每个web应用程序都创建一个对应的ServletContext对象，它代 表了当前的web应用； ","date":"2021-07-04","objectID":"/javaweb/:22:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、共享数据 我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数 很少用 // this.getServletConfig() Servlet参数 很少用 // this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = \"韋\"; context.setAttribute(\"username\",username);//将一个数据保存在了ServletContext中，名字为：username，值为：username System.out.println(\"hello\"); } } public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(\"username\"); //设置显示页面不乱码问题 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(\"名字为：\"+username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.GetServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003curl-pattern\u003e/getc\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 测试结果： ","date":"2021-07-04","objectID":"/javaweb/:22:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、获取初始化参数 \u003ccontext-param\u003e \u003cparam-name\u003eurl\u003c/param-name\u003e \u003cparam-value\u003ejdbc:mysql//localhost:3306/mybatis\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo03\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e public class ServletDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //此处获取上下文对象，获取初始化参数对应web.xml中的context-param中的参数，当你访问这个路径的时候，页面进行跳转的时候，就会获取到该路径对应的值 String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2021-07-04","objectID":"/javaweb/:22:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、请求转发 public class ServletDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); System.out.println(\"进入demo4\"); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/sd3\");//转发的请求路径 // requestDispatcher.forward(req,resp);//调用forward实现转发请求 context.getRequestDispatcher(\"/sd3\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo04\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2021-07-04","objectID":"/javaweb/:22:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、读取资源文件 Properties 在Java目录下新建一个properties 在resources目录下新建一个properties 发现：都打包到了同一个路径下：classes；我们俗称这个路径为classpath 思路：需要一个文件流 username=root password=123456 public class ServletDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"username\"); String pwd = properties.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pwd); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 访问测试结果： ","date":"2021-07-04","objectID":"/javaweb/:22:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.5、HttpServletResponse web服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest对 象，代表一个响应的HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse ","date":"2021-07-04","objectID":"/javaweb/:23:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、简单分类 负责向浏览器发送数据的方法 ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentLengthLong(long var1); void setContentType(String var1); void addDateHeader(String var1, long var2); void setHeader(String var1, String var2); void addHeader(String var1, String var2); void setIntHeader(String var1, int var2); void addIntHeader(String var1, int var2); ","date":"2021-07-04","objectID":"/javaweb/:23:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、常见应用 向浏览器输出消息 下载文件 要获取下载文件的路径 下载的文件名时什么？ 想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1. 要获取下载文件的路径 String realPath = \"G:\\\\IDEADocument\\\\javaweb\\\\javaweb-03-servlet\\\\response\\\\target\\\\classes\\\\韋.png\"; System.out.println(\"下载文件的路径：\"+realPath); //2. 下载的文件名时什么？如果有/则需要进行转义 String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); //3. 想办法让浏览器能够支持下载我们需要的东西,下载我们需要的东西，中文文件名，则使用URLEncoder.encode编码，否则有可能乱码 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+ URLEncoder.encode(fileName,\"UTF-8\")); //4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(realPath); //5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; //6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); //7. 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ while((len = in.read(buffer))\u003e0){ out.write(buffer,0,len); } in.close(); out.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 注意：如果图片采用中文名字命名，则需要将其转化，使用URLEncoder.encoder编码，有可能会乱码 ","date":"2021-07-04","objectID":"/javaweb/:23:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、验证码功能 验证怎么来的？ 前端实现 后端实现，需要用到Java的图片类，生成一个图片 public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如何让一个浏览器3秒自动刷新一次 resp.setHeader(\"refresh\",\"3\"); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D) image.getGraphics();//笔 //设置图片的背景颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.red); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(\"image/jpeg\"); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(\"expires\",-1); resp.setHeader(\"Cache-Control\",\"no-cache\"); resp.setHeader(\"Pragma\",\"no-cache\"); //把图片写给浏览器 ImageIO.write(image,\"jpg\",resp.getOutputStream()); } //生成随机数 private String makeNum(){ Random random = new Random(); String num = random.nextInt(999999) + \"\"; StringBuffer sb = new StringBuffer(); //如果num产生的长度为4，这里就让其空下来的地方填充0，保证其数字长度为6 for (int i = 0; i \u003c6 - num.length() ; i++) { sb.append(\"0\"); } num = sb.toString() + num; return num; } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ImageServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003curl-pattern\u003e/img\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 关于expries一些简单的简介：https://www.jianshu.com/p/f331d5f0b979 ","date":"2021-07-04","objectID":"/javaweb/:23:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、实现重定向 B一个web资源收到客户端A请求后，B它会通知A客户端去访问另外一个web资源C，这个过程叫重定向 常见场景： 用户登录 void sendRedirect(String var1) throws IOException; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //重定向 /* resp.setHeader(\"Location\",\"/r/img\"); resp.setStatus(302); * */ resp.sendRedirect(\"/r/img\"); } \u003cbody\u003e \u003ch2\u003eHello World!\u003c/h2\u003e \u003c%--这里提交的路径，需要寻找到项目的路径--%\u003e \u003c%--${pageContext.request.contextPath()}代表当前项目的路径--%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"get\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 面试题：请你聊聊重定向和转发的区别？. 相同点 页面都会实现跳转 不同点 请求转发的时候，url不会产生变化 重定向的时候，url地址栏会发生变化 ","date":"2021-07-04","objectID":"/javaweb/:23:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.6、HttpServletRequest HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装 到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息 ","date":"2021-07-04","objectID":"/javaweb/:24:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、获取参数,请求转发 //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); 注意：如果这里使用`/`它会默认的找不到路径资源，因为这里的`/`就代表着当前的web应用 重定向的时候需要写全路径 而转发的时候时不需要写全路径的 \u003ch1\u003e登录\u003c/h1\u003e \u003cdiv\u003e \u003c%-- 这里表单表示的依视：以post方式提交表单，提交到我们的login请求--%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e 爱好： \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"女孩\"\u003e女孩 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"代码\"\u003e代码 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"唱歌\"\u003e唱歌 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"电影\"\u003e电影 \u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/div\u003e public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String[] hobbys = req.getParameterValues(\"hobbys\"); System.out.println(\"====================\"); //后台接受中文乱码问题 System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbys)); System.out.println(\"====================\"); System.out.println(req.getContextPath()); //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 7、Cookie、Session ","date":"2021-07-04","objectID":"/javaweb/:24:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.1、会话 会话：用户打开一个浏览器，点击了很多超链接，访问web资源，关闭浏览器，这个过程可以称之为会话 有状态会话： 一个同学来过教室，下次再来教室，我们会指定这个同学，曾经来过，称之为有状态会话 一个网站怎么证明你来过？ 客户端（自己） 服务端（网站） 服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookie 服务器登记你来过了，下次你来的时候我来匹配你；session ","date":"2021-07-04","objectID":"/javaweb/:25:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.2、保存会话的两种技术 cookie 客户端技术（响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据存放在session中！ 常见例子：网站登录之后，你下次就不用在登录了，可以直接进去 ","date":"2021-07-04","objectID":"/javaweb/:26:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.3、Cookie 注意：使用谷歌浏览器解决浏览器显示中文乱码，要多设置一个resp.setContentType(\"text/html;charset=utf-8\"); 从请求中拿到cookie信息 服务器响应给客户端cookie Cookie[] cookies = req.getCookies();//获得cookie cookie.getName();//获得cookie中的key cookie.getValue();//获得cookie中的value new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\");//新建一个cookie loginTime.setMaxAge(24*60*60);//设置cookie的有效期 resp.addCookie(loginTime);//响应给客户端一个cookie 数据之间的转化 //获取cookie中的值![[Pasted image 20210608115423.png]] cookie.getValue(); //将cookie中的值转化为Long型 long lastLoginTime = Long.parseLong(cookie.getValue()); //以时间格式显示 Date date = new Date(lastLoginTime); //以字符串的形式输出 out.write(date.toLocaleString()); cookie：一般会保存在本地的用户目录下的AppData 一个网站的cookie是否存在上限！ 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie cookie大小有限制4kb 300个cookie浏览器上限 删除Cookie 不设置有效期，关闭浏览器，自动失效 设置有效期为0 public class CookieDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //创建一个Cookie，名字必须要和删除的名字一致 Cookie cookie = new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\"); //设置Cookie的有效期为0，立马过期 cookie.setMaxAge(0); //给客户端响应一个cookie resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 传递中文数据的时候，可能会出现乱码 所以可以采用编码、解码 URLEncoder.encode(\"韋\",\"utf-8\") URLDecoder.decode(cookie.getValue(),\"utf-8\") ","date":"2021-07-04","objectID":"/javaweb/:27:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.4、Session（重点） 什么是Session： 服务器会给每一个用户（浏览器）创建一个Session对象； 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站它都可以访问！－－＞保存用户的信息；保存购物车的信息．．．．．． Session和Cookie的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存（保存重要的信息，减少服务器资源的浪费 Session对象由服务器创建 使用场景： 保存一个登录用户的信息 购物车信息 在整个网站中经常会使用的数据，我们将它保存在Session中 //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); resp.addCookie(cookie); Session是在网页一打开就会创建并且一直存在，就算你关闭了网页他也会存在，除非你手动删除 使用Session： package com.clover.servlet; import com.clover.pojo.Person; import javax.servlet.ServletException; import javax.servlet.http.*; import java.io.IOException; public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); //给Session中存放东西 session.setAttribute(\"name\",new Person(\"韋\",1)); //获取Session的ID String sessionId = session.getId(); //判断Session是不是新创建的 if(session.isNew()){ resp.getWriter().write(\"session创建成功，ID：\"+sessionId); }else { resp.getWriter().write(\"session已经在服务器中存在了，ID：\"+sessionId); } //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ // Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); // resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } --------------------------------------------------------- 获取对象中的值 public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); Person name = (Person) session.getAttribute(\"name\"); System.out.println(name); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ----------------------------------------------------------- 手动注销session public class SessionDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); //取消刚刚获取的name session.removeAttribute(\"name\"); //并且注销掉该session，注销后立马生成新的sessionId，手动注销Session session.invalidate(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 会话自动过期：web.xml中配置 \u003c!--设置session默认失效时间--\u003e \u003csession-config\u003e \u003c!--1分钟后session自动失效，以分钟为单位--\u003e \u003csession-timeout\u003e1\u003c/session-timeout\u003e \u003c/session-config\u003e 8、JSP ","date":"2021-07-04","objectID":"/javaweb/:28:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.1、什么是JSP Java Server Pages ：Java服务器端页面，也和Servlet一样，用于动态Web技术 最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据 ","date":"2021-07-04","objectID":"/javaweb/:29:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.2、JSP原理 思路：JSP到底是怎么执行的？ 代码层面没有任何问题 服务器内部工作 tomcat有一个work目录 IDEA中使用Tomcat会在IDEA的tomcat中产生一个work目录 我电脑的地址： C:\\Users\\REN\\.IntelliJIdea2019.3\\system\\tomcat\\Tomcat_9_0_411_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 发现页面转变成了Java程序！ 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet JSP最终也会被转换成为一个Java类！ JSP本质上就是一个Servlet //初始化 public void _jspInit() { } //销毁 public void _jspDestroy() { } //JSPServlet public void _jspService(HttpServletRequest request, HttpServletResponse response) 判断请求 内置一些对象 final javax.servlet.jsp.PageContext pageContext; //页面上下文 javax.servlet.http.HttpSession session = null; //session final javax.servlet.ServletContext application; //applicationContext final javax.servlet.ServletConfig config; //配置 javax.servlet.jsp.JspWriter out = null; //输出对象 final java.lang.Object page = this; //当前页 HttpServletRequest request //请求 HttpServletResponse response //响应 输出页面前增加的代码 response.setContentType(\"text/html\"); //设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; 以上的这些个对象，我们可以在JSP页面中直接使用 在JSP页面中；只要是JAVA代码就会原封不动的输出；如果是HTML代码就会被转化为： out.write(\"\u003chtml\u003e\\n\"); 这样的格式，输出到前端！ ","date":"2021-07-04","objectID":"/javaweb/:30:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.3、JSP基础语法 JSP表达式 \u003c%-- JSP表达式 作用：用来将程序的输出，输出到客户端 \u003c%= 变量或者表达式%\u003e --%\u003e \u003c%= new java.util.Date()%\u003e JSP脚本片段 \u003c%-- jsp脚本片段--%\u003e \u003c% int sum = 0; for (int i = 1; i \u003c= 100; i++) { sum+=i; } out.println(\"\u003ch1\u003eSum=\"+sum+\"\u003c/h1\u003e\"); %\u003e 脚本片段的再实现 \u003c% int x = 10; out.println(x); %\u003e \u003cp\u003e这是一个JSP文档\u003c/p\u003e \u003c% int y = 20; out.println(x); out.println(y); %\u003e \u003c%-- 在代码中嵌入HTML元素--%\u003e \u003c% for (int i = 0; i \u003c 5; i++) { %\u003e \u003ch1\u003ehello,world\u003c%= i%\u003e\u003c/h1\u003e \u003c% } %\u003e JSP声明 \u003c%! static { System.out.println(\"Loading servlet\"); } private int globalvar = 0; public void clover(){ System.out.println(\"进入了clover方法\"); } %\u003e 注意：这里使用的\u003c\u003e里面有一个感叹号存在 JSP声明：会被编译到JSP生成的Java类中！其他的，就会被生成到_jspService方法中！ JSP的注释，不会在客户端显示，HTML就会！ ","date":"2021-07-04","objectID":"/javaweb/:31:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.4、JSP指令 \u003c%@page args......%\u003e \u003c%@include file=\"\"%\u003e \u003c%--@include会将两个页面合二为一--%\u003e \u003c%@include file=\"common/header.jsp\"%\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003c%@include file=\"common/footer.jsp\"%\u003e \u003chr\u003e \u003c%--jsp标签 jsp:include：拼接页面，本质上还是三个 --%\u003e \u003cjsp:include page=\"/common/header.jsp\"/\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003cjsp:include page=\"/common/footer.jsp\"/\u003e 注意：使用 jsp:include，其中的page代表当web页面，所以需要在common前面加一个/ 而两者也是有区别，使用@include，如果同时定义一个名字相同的变量，则会报错 使用 jsp:include则不会报错 ","date":"2021-07-04","objectID":"/javaweb/:32:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.5、九大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【ServletContext】存东西 config 【ServletConfig】 out page exception 在pageContextDemo01中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--内置对象--%\u003e \u003c% pageContext.setAttribute(\"name1\",\"clover一号\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\",\"clover二号\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\",\"clover三号\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\",\"clover四号\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器 %\u003e \u003c%--脚本片段中的代码，会被原封不动生成到.JSP.java 要求：这里面的代码，必须保证Java语法的正确性 --%\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）:page--\u003erequest--\u003esession--\u003eapplication String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 2.在pageContextDemo02中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）: String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 这里由于时在另外一个页面访问，也没有请求转发，所以一号与二号就消亡了 测试结果： 3.在pageContextDemo03中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% pageContext.forward(\"/index.jsp\"); //就相当于执行了request.getRequestDispatcher(\"/index.jsp\").forward(request,response); %\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用了的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车 application：客户端向服务器发送请求，产生的数据，一个用户用完了，其它用户还可能使用，比如：聊天数据 ","date":"2021-07-04","objectID":"/javaweb/:33:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.6、JSP标签、JSTL标签，EL表达式 所需依赖 \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp.jstl\u003c/groupId\u003e \u003cartifactId\u003ejstl-api\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003etaglibs\u003c/groupId\u003e \u003cartifactId\u003estandard\u003c/artifactId\u003e \u003cversion\u003e1.1.2\u003c/version\u003e \u003c/dependency\u003e EL表达式：${} 获取数据 执行运算 获取web开发常用对象 JSP标签 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--jsp:include--%\u003e \u003c%-- http://localhost:8080/jsptag.jsp?name=clover$age=3 --%\u003e \u003cjsp:forward page=\"jsptag2.jsp\"\u003e \u003cjsp:param name=\"name\" value=\"clover\"/\u003e \u003cjsp:param name=\"age\" value=\"3\"/\u003e \u003c/jsp:forward\u003e \u003c/body\u003e \u003c/html\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--取出参数--%\u003e 名字：\u003c%=request.getParameter(\"name\")%\u003e 年龄：\u003c%=request.getParameter(\"age\")%\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： JSTL表达式 JSTL标签库的使用就是为了弥补HTML标签的不足，它自定义许多标签，可以供我们使用，标签的功能和Java代码一样 核心标签（掌握部分） JSTL标签使用步骤 引入对应的taglib 使用其中的方法 注意：在Tomcat也需要引入jstl的包，否则会报错，JSTL解析错误 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch4\u003eif测试\u003c/h4\u003e \u003chr\u003e \u003cform action=\"coreif.jsp\" method=\"get\"\u003e \u003c%-- EL表达式获取表单中的数据 ${param.参数名} --%\u003e \u003cinput type=\"text\" name=\"username\" value=\"${param.username}\"\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/form\u003e \u003c%--判断如果提交的用户名是管理员，则登录成功--%\u003e \u003cc:if test=\"${param.username=='admin'}\" var=\"isAdmin\"\u003e \u003cc:out value=\"管理员欢迎您！\"/\u003e \u003c/c:if\u003e \u003c%--自闭和标签--%\u003e \u003cc:out value=\"${isAdmin}\"/\u003e \u003c/body\u003e \u003c/html\u003e 登录账户不为admin时的结果： 登录账户为admin时的结果： corechoose 与 corewhen \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--定义一个变量score，值为85--%\u003e \u003cc:set var=\"score\" value=\"90\"/\u003e \u003cc:choose\u003e \u003cc:when test=\"${score\u003e=90}\"\u003e 你的成绩为优秀 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=80}\"\u003e 你的成绩为良好 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=70}\"\u003e 你的成绩为一般 \u003c/c:when\u003e \u003cc:when test=\"${score\u003c=60}\"\u003e 你的成绩为不及格 \u003c/c:when\u003e \u003c/c:choose\u003e \u003c/body\u003e \u003c/html\u003e 注意：如果有一个值满足多个条件，它会按照顺序去执行 coreforeach \u003c%@ page import=\"java.util.ArrayList\" %\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% ArrayList\u003cString\u003e people = new ArrayList\u003c\u003e(); people.add(0,\"张三\"); people.add(1,\"李四\"); people.add(2,\"王五\"); people.add(3,\"张六\"); people.add(4,\"田七\"); request.setAttribute(\"list\",people); %\u003e \u003c%-- var,每一次遍历出来的变量 item，要遍历的对象 begin，从哪开始 end，到哪结束 step，每一次执行的步长 --%\u003e \u003cc:forEach var=\"people\" items=\"${list}\"\u003e \u003cc:out value=\"${people}\"/\u003e\u003cbr\u003e \u003c/c:forEach\u003e \u003cbr\u003e \u003cc:forEach var=\"people\" items=\"${list}\" begin=\"1\" end=\"3\" step=\"2\"\u003e \u003cc:out value=\"${people}\" /\u003e \u003c/c:forEach\u003e \u003c/body\u003e \u003c/html\u003e 使用了begin end 变量后的情况 9、JavaBean JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法 一般用来和数据库的字段做映射 ORM：对象关系映射 10、MVC三层架构 ","date":"2021-07-04","objectID":"/javaweb/:34:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.1、原来的操作模式 用户直接访问控制层，控制层就可以直接操作数据库 servlet---CRUD---数据库 弊端：程序十分臃肿，不利于维护（在servlet中加入了处理jdbc的代码） Servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 架构思想：没有什么是加一层解决不了的！ ","date":"2021-07-04","objectID":"/javaweb/:35:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.2、MVC三层架构 Model 业务处理：业务逻辑（Service） 数据持久层：CRUD（Dao） View 展示数据 提供连接发起Servlet请求 Controller 接受用户的请求：（req：请求参数、session信息） 交给业务层处理对应的代码 控制视图的跳转 登录---\u003e接受用户的登录请求---\u003e处理用户的请求（获取用户登录的参数，username，password）---\u003e交给业务层处理登录业务（判断用户名密码是否正确：事务）---\u003eDao层查询用户名和密码是否正确---\u003e数据库 11、Filter（重点） Filter：过滤器，用来过滤网站的数据 处理中文乱码 登录验证 Filter开发步骤： 导包 编写过滤器 导包不能导入错误 编写过滤器，实现Filter接口，重写对应的方法 package com.clover.filter; import javax.servlet.*; import java.io.IOException; public class CharacterEncodingFilter implements Filter { //初始化：web服务器启动，就已经初始化了，随时等待过滤对象出现！ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"CharacterEncodingFilter初始化\"); } //Chain：链 /* * 1.过滤器中的所有代码，再过滤特定请求的时候都会执行 * 2.必须要让过滤器继续执行（因为可能存在多个过滤器，所以要继续执行下去） * */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(\"UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"CharacterEncodingFilter执行前.........\"); chain.doFilter(request,response);//让我们的请求继续走，如果不屑，程序执行到这里就会被拦截停止！ System.out.println(\"CharacterEncodingFilter执行后.........\"); } //销毁 @Override public void destroy() { System.out.println(\"CharacterEncodingFilter销毁\"); } } 3.编写web.xml配置Filter \u003cfilter\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.clover.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003c!-- 只要是 /servlet下的任何请求，都会经过这个过滤器--\u003e \u003curl-pattern\u003e/servlet/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 12、监听器 编写一个监听器 实现一个监听器的接口 package com.clover.listener; import javax.servlet.ServletContext; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class OnlineCountListener implements HttpSessionListener { //创建session监听：查看你的一举一动 //一旦创建Session就会出发一次这个事件！ @Override public void sessionCreated(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count+1); } context.setAttribute(\"OnlineCount\",onlineCount); } //销毁Session监听 //一旦销毁Session就会出发一次这个事件！ @Override public void sessionDestroyed(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count-1); } context.setAttribute(\"OnlineCount\",onlineCount); } /* * 销毁session有两种方法 *1.自动销毁 getSession().invalidate(); *2.手动销毁 在web.xml中设置session存活时间 */ } 在web.xml中注册监听器 \u003c!--注册监听器--\u003e \u003clistener\u003e \u003clistener-class\u003ecom.clover.listener.OnlineCountListener\u003c/listener-class\u003e \u003c/listener\u003e 13、过滤器、监听器常见应用 ","date":"2021-07-04","objectID":"/javaweb/:36:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["Thread"],"content":"Thread","date":"2021-07-04","objectID":"/thread/","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程简介 ","date":"2021-07-04","objectID":"/thread/:1:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Process：进程 程序是指令和数据的有效集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。一个进程中可以包含若干个线程，当然一个进程中最少包含一个线程。线程是CPU调度和执行的单位。 ","date":"2021-07-04","objectID":"/thread/:1:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Thread：线程 ","date":"2021-07-04","objectID":"/thread/:1:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"两条线程是同时、交替执行的 注意，线程开启不一定立即执行，由CPU调度执行 ","date":"2021-07-04","objectID":"/thread/:1:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"方法一：继承Thread类，重写run()方法，调用start开启线程 package com.ren.lesson01; //创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由CPU调度执行 public class TestThread01 extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 TestThread01 testThread01 = new TestThread01(); //调用start()方法开启线程 testThread01.start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： 从网络上下载图片，通过一个下载器方法实现 package com.ren.lesson01; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestThread02(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public void run() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestThread02 t2 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestThread02 t3 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //这三个不是按照顺序来执行的，是同时进行，小的先完成 t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } 小结：","date":"2021-07-04","objectID":"/thread/:1:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 package com.ren.lesson01; //创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 public class TestThread03 implements Runnable{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //创建runnable接口的实现类对象 TestThread03 testThread03 = new TestThread03(); //创建线程对象，通过线程对象来开启我们的线程，代理 // Thread thread = new Thread(testThread03); // // thread.start(); new Thread(testThread03).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： package com.ren.lesson01; //多个线程同时操作同一个对象 //买火车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread04 implements Runnable{ //票数 private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums\u003c=0){ break; } //模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //Thread.currentThread().getName()获取当前线程的名称 System.out.println(Thread.currentThread().getName()+\"--\u003e拿到了第\"+ticketNums--+\"票\"); } } public static void main(String[] args) { TestThread04 ticket = new TestThread04(); new Thread(ticket,\"你\").start(); new Thread(ticket,\"我\").start(); new Thread(ticket,\"他\").start(); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程创建方式三：实现Callable接口 package com.ren.lesson02; import com.ren.lesson01.TestThread02; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; //线程创建方式三：实现Callable接口 /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ public class TestCallable implements Callable\u003cBoolean\u003e { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public Boolean call() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行(通过服务来提交我们的线程) Future\u003cBoolean\u003e r1 = ser.submit(t1); Future\u003cBoolean\u003e r2 = ser.submit(t2); Future\u003cBoolean\u003e r3 = ser.submit(t3); //获取结果（获取的结果就是线程调用了call函数所返回的结果） Boolean rs1 = r1.get(); Boolean rs2 = r1.get(); Boolean rs3 = r1.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ 结果图： ","date":"2021-07-04","objectID":"/thread/:1:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"静态代理 使用结婚这个例子来阐述，可以将其与线程进行比较 package com.ren.lesson02; /** * 静态代理模式总结： * 真实对象（目标对象）和代理对象都要实现同一个接口 * 代理对象要代理真实角色 * 好处：代理对象可以做很多真实对象做不了的事情 * 真实对象专注做自己的事情 */ public class StaticProxy { public static void main(String[] args) { You you = new You(); //将其与多线程对比 /** * Thread就相当于WeddingCompany * Thread是一个代理，它代理的是他括号里面的真实对象（Runnable接口） * HappyMarry是来自于它的接口中的（代理对象中的），start是Thread里面去弄的，它们都有一个共同的方法，run方法 */ new Thread(()-\u003e System.out.println(\"我爱你\")).start(); new WeddingCompany(you).HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry() { System.out.println(\"我要结婚了！\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁--\u003e真实目标角色 private Marry target; public WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry();//这就是真实对象 after(); } private void after() { System.out.println(\"结婚之后，收尾款\"); } private void before() { System.out.println(\"结婚之前，布置现场\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lamda表达式 ","date":"2021-07-04","objectID":"/thread/:2:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"函数式接口的定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lamda表达式来创建该接口的对象 一步步的简化过程 package com.ren.lesson02; /** * 推导lamda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda2\"); } } public static void main(String[] args) { ILike like = new Like(); like.lamda(); like = new Like2(); like.lamda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda3\"); } } like = new Like3(); like.lamda(); //5.匿名内部类,没有类的名称，必须借助接口或者父类 like = new ILike() { @Override public void lamda() { System.out.println(\"i like lamda4\"); } }; like.lamda(); //3.用lamda简化 like = ()-\u003e{ System.out.println(\"i like lamda5\"); }; like.lamda(); } } //1.定义一个函数式接口 interface ILike{ void lamda(); } //2.实现类 class Like implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda\"); } } 实例过程 package com.ren.lesson02; public class TestLamda2 { public static void main(String[] args) { //lamda表达式简化 ILove love = (int a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化1.去掉参数类型 love = (a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化2.去掉括号 love = a-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化3.去掉花括号 love = a-\u003e System.out.println(\"i love you--\u003e\"+a); /** * 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 */ love.love(8); } } interface ILove{ void love(int a); } 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 ","date":"2021-07-04","objectID":"/thread/:2:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程五大状态 ","date":"2021-07-04","objectID":"/thread/:3:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程方法 ","date":"2021-07-04","objectID":"/thread/:3:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不涉及到多个线程操作一个对象可以直接继承Thread，涉及道路就采用继承Runnable接口 ","date":"2021-07-04","objectID":"/thread/:4:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程停止 package com.ren.lesson03; /** * 测试stop(停止线程) * 1.建议使用线程正常停止---\u003e利用次数，不建议死循环 * 2.建议使用标志位---\u003e设置一个标志位 * 3.不要使用stop或者destory等过时或者JDK不建议使用的方法 */ public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while(flag){ System.out.println(\"run......Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\"+i); if(i==900){ //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"该线程停止了\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程休眠 package com.ren.lesson03; import java.text.SimpleDateFormat; import java.util.Date; //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取系统当前时间 while(true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if(num\u003c=0){ break; } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程礼让 package com.ren.lesson03; /** * 测试礼让线程 * 礼让不一定成功，看CPU心情 */ public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行！\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行！\"); } } 结果图： 注意：礼让有可能是成功的，也有可能礼让失败！！！ ","date":"2021-07-04","objectID":"/thread/:4:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程强制执行_Join Join合并线程，待此线程执行完成后，再执行其它线程，其它线程阻塞。可以想象成插队。 package com.ren.lesson03; //测试join方法，想象成插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"线程VIP来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); //主线程 for (int i = 0; i \u003c 500; i++) { if(i==200){ thread.start(); thread.join();//插队 } System.out.println(\"main\"+i); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程状态观测 package com.ren.lesson03; //观察测试线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"//////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//New //观察启动后 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//Run //只要线程不终止，就一直输出状态 while(state != Thread.State.TERMINATED){ Thread.sleep(100);//1秒运行十次 state = thread.getState();//线程状态的更新 System.out.println(state); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程优先级 线程优先级越高，所获取的资源越多 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度 package com.ren.lesson03; //测试线程的优先级 public class Testpriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，在启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(5); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); // t5.setPriority(11); // t5.start(); // // t6.setPriority(-1); // t6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"守护线程 package com.ren.lesson03; //测试守护线程 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(); thread.setDaemon(true);//默认是false表示的用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程启动 new Thread(you).start();// 你 用户线程启动 } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\"1111111111111111111111111\"); } } } class You implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 36500; i++) { System.out.println(\"你一生都开心的活着！\"); } System.out.println(\"============goodbye world==============\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程同步机制 ","date":"2021-07-04","objectID":"/thread/:4:8","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"三大不安全案例 ","date":"2021-07-04","objectID":"/thread/:5:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"买票 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //模拟延时 放大问题的发生性 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"取钱 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不安全的集合 package com.ren.lesson04; import java.util.ArrayList; import java.util.List; //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步方法 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); //模拟延时 放大问题的发生性 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } //synchronized 同步方法，锁的是this private synchronized void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } ","date":"2021-07-04","objectID":"/thread/:6:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步块 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(1000,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 //synchronized 默认锁的是this @Override public void run() { //锁的对象就是变化的量，需要增、删、改的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } } ","date":"2021-07-04","objectID":"/thread/:6:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"CopyOnWriteArrayList package com.ren.lesson04; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //打印是在主线程，操作list是在子线程，sleep是保证子线程执行完在执行主线程的打印 System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:7:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁 ","date":"2021-07-04","objectID":"/thread/:8:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁避免方法 package com.ren.lesson05; //死锁：多个线程互相抱着对方需要的资源，形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑凉\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); //选择 int choice; //使用化妆品的人 String girlName; public Makeup(int choice,String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException { if(choice == 0){ /** * 这个地方解决的方法就是不让其一个人抱着两个人的资源，将其写到外面来 */ synchronized (lipstick){//获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } synchronized (mirror){//一秒钟后想获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){//获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } synchronized (lipstick){//两秒钟后想获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:8:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lock ","date":"2021-07-04","objectID":"/thread/:9:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"synchronized与Lock的对比 package com.ren.lesson05; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try{ //加锁 lock.lock(); if(ticketNums\u003e0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { //解锁 lock.unlock(); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:9:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"生产者消费者问题 ","date":"2021-07-04","objectID":"/thread/:10:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"管程法 package com.ren.lesson05; //测试：生产者消费者模型--\u003e利用缓冲区解决：管程法 //生产者， 消费者 ， 产品， 缓冲区 public class TestPC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); } } //生产者 class Productor extends Thread{ SynContainer container; public Productor(SynContainer container){ this.container = container; } //生产 @Override public void run() { for (int i = 0; i \u003c 100; i++) { container.push(new Chicken(i)); System.out.println(\"生产了第\"+i+\"只鸡\"); } } } //消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } //消费 @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(\"消费了第--\u003e\"+container.pop().id+\"只鸡\"); } } } //产品 class Chicken{ //产品编号 int id; public Chicken(int id) { this.id = id; } } //缓冲区 class SynContainer{ //需要一个容器大小 Chicken[] chickens = new Chicken[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Chicken chicken){ //如果容器满了，就需要等待消费者消费产品 if(count==chickens.length){ //通知消费者生产，生产者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果没有满，我们就需要丢入产品 chickens[count] = chicken; count++; //可以通知消费者消费了 this.notifyAll(); } //消费者消费产品 public synchronized Chicken pop(){ //判断能否消费 if(count == 0){ //等待生产者生产，消费者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果可以消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"信号灯法 package com.ren.lesson05; //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--\u003e演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if(i%2==0){ tv.play(\"快乐大本营播放中！\"); }else{ tv.play(\"抖音记录美好生活\"); } } } } //消费者--\u003e观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { tv.watch(); } } } //产品--\u003e节目 class TV{ //演员表演，观众等待 T //观众观看，演员等待 F //表演的节目 String voice; //标志位 boolean flag = true; //演员表演 public synchronized void play(String voice){ if(!flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice = voice; this.flag = !flag; } //观众观看 public synchronized void watch(){ if(flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"观众观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !flag; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"使用线程池 package com.ren.lesson05; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable的实现类 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:11:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了  结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new G","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["Docker"],"content":"docker","date":"2021-07-04","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-07-04","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-07-04","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-07-04","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 ","date":"2021-07-04","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 ","date":"2021-07-04","objectID":"/docker/:3:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 ","date":"2021-07-04","objectID":"/docker/:3:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-07-04","objectID":"/docker/:3:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 ","date":"2021-07-04","objectID":"/docker/:4:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 ","date":"2021-07-04","objectID":"/docker/:4:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 ","date":"2021-07-04","objectID":"/docker/:4:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 ","date":"2021-07-04","objectID":"/docker/:4:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Centos安装 https://docs.docker.com/engine/install/centos/ ","date":"2021-07-04","objectID":"/docker/:4:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ","date":"2021-07-04","objectID":"/docker/:4:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils ","date":"2021-07-04","objectID":"/docker/:4:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 ","date":"2021-07-04","objectID":"/docker/:4:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ ","date":"2021-07-04","objectID":"/docker/:4:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images ","date":"2021-07-04","objectID":"/docker/:4:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 ","date":"2021-07-04","objectID":"/docker/:4:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-07-04","objectID":"/docker/:4:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是真么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-07-04","objectID":"/docker/:5:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 ","date":"2021-07-04","objectID":"/docker/:6:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 ","date":"2021-07-04","objectID":"/docker/:6:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 ","date":"2021-07-04","objectID":"/docker/:6:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，编程了centos的id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minutes stoic_wilson edbd9366d959 centos \"/bin/bash\" 35 minutes ago Up 35 minutes affectionate_bartik 9939864fa2e6 centos \"bin/bash\" 48 minutes ago Exited (0) 48 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 52 minutes ago Exited (0) 49 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 20 hours ago Exited (0) 20 hours ago gracious_bhabha [root@192 ~]# docker rm 5f42e9930435 5f42e9930435 [root@192 ~]# docker rm edbd9366d959 # 注意正在运行的容器不能删除 Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove [root@192 ~]# docker ps -aq # 所有容器id bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d [root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除 bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d 启动和停止容器的操作 docker start docker restart docker stop docker kill [root@192 ~]# docker run -it centos /bin/bash [root@7b1a7dd10ea4 /]# exit exit [root@192 ~]# docker ps #查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a # 查看历史运行过的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 54 seconds ago Exited (0) 42 seconds ago fervent_mirzakhani [root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来 7b1a7dd10ea4 [root@192 ~]# docker ps # 查看当前运行容器 发现启动成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 2 minutes ago Up 28 seconds fervent_mirzakhani [root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行 7b1a7dd10ea4 [root@192 ~]# docker ps # 再次查看 没有这个容器了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","date":"2021-07-04","objectID":"/docker/:6:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"常用其他命令 后台启动docker docker run -d 镜像名 # 用docker ps 查看的时候 发现停止了 # 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止 Last login: Wed Jun 17 19:47:35 2020 [root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker [root@192 ~]# docker run -d centos # 运行 8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded [root@192 ~]# docker ps -a # 查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ce188e5fee3 centos \"/bin/bash\" 19 seconds ago Exited (0) 18 seconds ago tender_dirac 7b1a7dd10ea4 centos \"/bin/bash\" 8 hours ago Exited (0) 8 hours ago fervent_mirzakhani 查看日志 docker logs # -tf #显示日志 #--tail number # 要显示日志条数 docker logs -f -t --tail n 【id】 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps # 时间戳 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) # 自己编写的一个脚本 whiel true;do echo shenzai;sleep # 运行一个 [root@192 ~]# docker run -it centos /bin/bash [root@c2887d35c71d /]# [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c2887d35c71d centos \"/bin/bash\" 57 seconds ago Up 56 seconds vigorous_kare # 查看日志，由于没有运行脚本，所以啥也没显示 [root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d ^C # ctrl+c退出 # 运行centos里面加个脚本 [root@192 ~]# docker run -d centos /bin/sh -c \"while true;do echo shenzai;sleep 1;done\" cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb6d7fbc3f27 centos \"/bin/sh -c 'while t…\" 7 seconds ago Up 6 seconds dreamy_almeida c2887d35c71d centos \"/bin/bash\" 3 minutes ago Up 3 minutes vigorous_kare # 查看日志 发现隔一秒打印一条 [root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27 2020-06-17T12:02:11.293765084Z shenzai 2020-06-17T12:02:12.297675608Z shenzai 2020-06-17T12:02:13.301845582Z shenzai 2020-06-17T12:02:14.304800996Z shenzai 2020-06-17T12:02:15.307130238Z shenzai 2020-06-17T12:02:16.310574235Z shenzai 2020-06-17T12:02:17.312946923Z shenzai 2020-06-17T12:02:18.314841295Z shenzai 2020-06-17T12:02:19.317021705Z shenzai 2020-06-17T12:02:20.319670013Z shenzai 2020-06-17T12:02:21.322651649Z shenzai 2020-06-17T12:02:22.325466918Z shenzai 2020-06-17T12:02:23.327984704Z shenzai 2020-06-17T12:02:24.329656919Z shenzai 查看容器中进程信息 # 命令 docker top 容器id # UID：当前用户id PID：父id PPID：进程ID UID PID PPID C STIME root 1424 31183 0 15:13 root 31183 31163 0 14:50 查看正在镜像的元数据 # 命令 docker inspect 容器id [root@192 ~]# docker inspect cb6d7fbc3f27 [ { # 容器的完整id \"Id\": \"cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\", # 创建时间 \"Created\": \"2020-06-17T12:00:50.706906186Z\", # 脚本位置 \"Path\": \"/bin/sh\", # 运行的脚本 \"Args\": [ \"-c\", \"while true;do echo shenzai;sleep 1;done\" ], \"State\": { \"Status\": \"running\", # 状态，正在运行 \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1909, # 父进程id \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-06-17T12:00:51.093617477Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, # 镜像来源 \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname\", \"HostsPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts\", \"LogPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log\", \"Name\": \"/dreamy_almeida\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"Mou","date":"2021-07-04","objectID":"/docker/:6:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"可视化 portainer(先用这个) Rancher(CI/CD时用) portainer Docker图像化界面管理工具，提供一个后台面板供我们操作！ docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer 访问外网8088 用户名 密码 【中午吃饭重连了一下，失败，不知道发生了啥】 【平时不会用这个，好吧，先往下】 ","date":"2021-07-04","objectID":"/docker/:6:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 ","date":"2021-07-04","objectID":"/docker/:7:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 ","date":"2021-07-04","objectID":"/docker/:7:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-07-04","objectID":"/docker/:7:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 ","date":"2021-07-04","objectID":"/docker/:8:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 ","date":"2021-07-04","objectID":"/docker/:8:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 ","date":"2021-07-04","objectID":"/docker/:8:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 ","date":"2021-07-04","objectID":"/docker/:8:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"具名和匿名挂载 ","date":"2021-07-04","objectID":"/docker/:8:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 ","date":"2021-07-04","objectID":"/docker/:8:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-07-04","objectID":"/docker/:8:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 ","date":"2021-07-04","objectID":"/docker/:9:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 ","date":"2021-07-04","objectID":"/docker/:9:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 *#*表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ ","date":"2021-07-04","objectID":"/docker/:9:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile命令 ","date":"2021-07-04","objectID":"/docker/:9:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":" FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 ","date":"2021-07-04","objectID":"/docker/:9:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 ","date":"2021-07-04","objectID":"/docker/:9:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 ","date":"2021-07-04","objectID":"/docker/:9:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包：https://blog.csdn.net/doupeihua/article/details/51831947 tomcat压缩包：https://tomcat.apache.org/download-90.cgi 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html ","date":"2021-07-04","objectID":"/docker/:9:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login -u cloverfelix Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [root@iZ2zejeormv0s24sdvazvxZ ~]# 4、登录完毕后就可以提交镜像了，就是一步 docker push # push到自己的镜像到服务器上 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker push divtomcat Using default tag: latest The push refers to repository [docker.io/library/divtomcat] b23ff398b23f: Preparing e0403d0b82a9: Preparing d252d00ff518: Preparing 537a66dda3f7: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied # push请求被拒绝了 [root@iZ2zejeormv0s24sdvazvxZ ~]# push上去的时候一定记得带上版本号 ","date":"2021-07-04","objectID":"/docker/:9:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"小结： ","date":"2021-07-04","objectID":"/docker/:9:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 ","date":"2021-07-04","objectID":"/docker/:10:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们没每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是**–link**技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：–link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用-link了！ 使用的都是自定义网络！不适用docker0！ docker0问题：它不支持容器名连接访问！ ","date":"2021-07-04","objectID":"/docker/:10:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE e3ed9ad5b74b bridge bridge local 51f1bd18d34e host host local f833096b830f mynet bridge local bb8aa0300ba6 none null local 我们自己的网络就创建好了 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-01 tomcat 7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-02 tomcat 11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111\", \"Created\": \"2021-02-03T00:17:44.277900481+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"1b542176401a508f905acbb09ab2d07c45c3280e6f60e66428a565766470b46e\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"872b36e9c2a5d9f59a2931e1edad34c3eded6d693c3fef830e29bcdae511b4d9\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] # 再次测试ping连接 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.121 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.096 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.100 ms --- 192.168.0.3 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.096/0.105/0.121/0.016 ms #现在不使用--link也可以ping名字了！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.099 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.103 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.093 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.100 ms --- tomcat-net-02 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.069/0.092/0.103/0.017 ms 结论：我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络 好处： redis - 不同的集群使用不同的网络，保证集群是安全和健康的 mysql - 不同的集群使用不同的网络，保证集群是安全和健康的 ","date":"2021-07-04","objectID":"/docker/:10:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"网络连通 # 测试打通 tomcat01 到 mynet # 连通之后就是将我们的 tomcat01 加到 mynet网络下 # 一个容器两个ip地址 #阿里云服务器： 一个公网 一个私网地址 # tomcat01 可以与 tomcat-net-01 连通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.4 PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data. 64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.134 ms 64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.095 ms 64 bytes from 192.168.0.4: icmp_seq=3 ttl=64 time=0.097 ms 64 bytes from 192.168.0.4: icmp_seq=4 ttl=64 time=0.096 ms ^C --- 192.168.0.4 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.095/0.105/0.134/0.019 ms # tomcat02 与 tomcat-net-01依旧打不通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat-net-01 ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ ","date":"2021-07-04","objectID":"/docker/:10:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战：部署Redis集群 ","date":"2021-07-04","objectID":"/docker/:10:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-07-04","objectID":"/docker/:11:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-07-04","objectID":"/docker/:12:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-07-04","objectID":"/docker/:13:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-07-04","objectID":"/docker/:14:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug ","date":"2021-07-04","objectID":"/docker/:15:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-07-04","objectID":"/docker/:15:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"}]