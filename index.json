[{"categories":["Docker"],"content":"DockerDeploy","date":"2021-08-18","objectID":"/dockerdeploy/","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"使用Dockers部署若依项目 ","date":"2021-08-18","objectID":"/dockerdeploy/:0:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"1、先进行docker安装 ","date":"2021-08-18","objectID":"/dockerdeploy/:1:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"2、安装mysql docker run -p 3307:3306 --name mysql01 -v /home/westbrook/mysql/log:/var/log/mysql \\ -v /home/westbrook/mysql/conf/my.cnf:/etc/mysql/my.cnf \\ -v /home/westbrook/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 -d mysql:5.7.33 执行成功后 注意：如果第一次直接执行该命令，它会自动的把`mysql/conf`下的my.cnf配置文件创建成为一个目录，会产生报错，需要你手动删除该目录后重建一个配置文件 开启远程连接时需要进行以下操作： 1、先查看用户信息 select host,user,plugin,authentication_string from mysql.user; 备注：host为 % 表示不限制ip ，localhost表示本机使用 plugin非mysql_native_password 则需要修改密码 2、如果是8.0版本以上还需要修改加密规则，而我采用的是5.7，所以不需要修改，直接执行以下命令即可 flush privileges; ","date":"2021-08-18","objectID":"/dockerdeploy/:2:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"3、安装Toomcat docker run --name tomcat01 -p 8081:8080 -d tomcat 执行命令成功以后，去本机访问时，发现资源未找到，这就是我们常说的一个问题，可以进容器查看 进入容器可以看到有一个webapps.dist文件夹，我们tomcat所需要的文件全部存放在其中，而不是存放在webapps目录下面 先将两个文件server.xml和tomcat-users.xml复制过去为后面做映射做准备 docker cp bb50d6e13752:/usr/local/tomcat/conf/server.xml /home/westbrook/tomcat/conf docker cp bb50d6e13752:/usr/local/tomcat/conf/tomcat-users.xml /home/westbrook/tomcat/conf 然后清除之前运行起来的tomcat01 # 先停止运行 docker stop tomcat01 # 再移除tomcat01 docker rm tomcat01 拉取tomcat镜像并运行 docker run --name tomcat01 -p 8081:8080 -v /home/westbrook/tomcat/webapps:/usr/local/tomcat/webapps \\ -v /home/westbrook/tomcat/conf/server.xml:/usr/local/tomcat/conf/server.xml \\ -v /home/westbrook/tomcat/conf/tomcat-users.xml:/usr/local/tomcat/conf/tomcat-users.xml \\ -v /home/westbrook/tomcat/logs:/usr/local/tomcat/logs -d tomcat 现在再次访问还是访问不到 我们进入容器中，将webapps.dist文件中的资源拷贝到webapps中去 # 进入容器 docker exec -it tomcat01 /bin/bash # 进入webapps.dist目录中，将文件中的内容复制到webapps目录下 cp -r * ../webapps 因为这里进行了数据卷的挂载，实现了容器内与宿主机的数据绑定，所以再容器中将文件复制到了webapps中后，宿主机中的webapps文件也自动同步对应容器文件中的数据，所以可以访问成功！ ","date":"2021-08-18","objectID":"/dockerdeploy/:3:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"4、安装redis docker run -p 6380:6379 --name redis01 \\ -v /home/westbrook/redis/data:/data \\ -v /home/westbrook/redis/conf/redis.conf:/etc/redis/redis.conf \\ -d redis redis-server /etc/redis/redis.conf # -d以后台的方式启动；redis是要运行什么镜像；redis-server以后面这个配置文件路径的方式启动 ","date":"2021-08-18","objectID":"/dockerdeploy/:4:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"5、安装nginx docker run --name nginx01 -p 81:80 \\ -v /home/westbrook/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v /home/westbrook/nginx/html:/usr/share/nginx/html \\ -v /home/westbrook/nginx/logs:/var/log/nginx \\ -d nginx 注意：如果再拉取镜像并运行的时候进行数据卷的挂载，虽然会成功，但是nginx会直接挂掉；原因是因为你在宿主机建立一个空的配置文件来进行映射是行不同的； 解决方法：先运行一个nginx镜像不进行数据卷的挂载，获取到它的配置文件后再次进行数据卷挂载 ","date":"2021-08-18","objectID":"/dockerdeploy/:5:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"6、前端部署 先进入若依前端目录，进入目录后再文件夹目录地方输入cmd 然后输入cnpm install安装依赖 在输入npm build:prod对项目进行打包，如果再命令行出现这种报错 那就去vs code中的package.json文件中找到build:prod命令，鼠标放在上面出现运行脚本后点击运行，让其开始打包 打包完成后生成了一个dist文件夹，将其拷贝到服务器上/home/westbrook/nginx/html目录下 同时进入服务器该/home/westbrook/nginx/conf目录下，编辑nginx配置文件 server { listen 80; server_name 192.168.167.48; #charset koi8-r; #access_log logs/host.access.log main; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } } 最后重启nginx容器即可！docker restart nginx01 ","date":"2021-08-18","objectID":"/dockerdeploy/:6:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"7、部署后端 打开若依项目，先修改resources目录下的logback.xml文件 然后再修改application-druid.yml文件中数据库配置 再修改application.yml文件中关于redis配置以及路径配置 如果想要打jar包，克隆下来后直接运行就可以了 如果想打war包就得进行一些修改 首先修改pom.xml文件，引入tomcat依赖将tomcat内置的依赖去掉，因为springboot自动集成了tomcat，打war包就得去掉。 然后继续修改pom.xml文件，将packaging修改成你所要打包对应的类型 后端还未部署起来，还在继续测试！！！ 后端打jar包时运行一直报数据库错误 ","date":"2021-08-18","objectID":"/dockerdeploy/:7:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Vuex"],"content":"Vuex","date":"2021-07-28","objectID":"/vue/","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"开始、简介 每一个Vuex应用的核心就是store（仓库）。”store“基本上就是一个容器，它包含着你的应用中绝大部分的状态。Vuex和单纯的全局对象有以下两点不同。 1、Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效的更新。 2、你不能直接改变store中的状态。改变store中的状态唯一的途径就是显示的提交（commit）mutation。这样是得我们可以方便的跟踪每一个状态的变化。 安装完Vuex之后，我们来创建一个store import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 现在，我们可以通过store.state来获取状态对象，以及通过store.commit方法触发状态变更： store.commit('increment') console.log(store.state.count) // -\u003e 1 为了在Vue组件中访问this.$store property，你需要为Vue实例提供创建好的store。Vuex提供了一个从根组件向所有子组件，以store选项的方式注入该store的机制： new Vue({ el: '#app', store: store, }) 为子组件或vue实例提供一个创建好的store。 现在我们可以去子组件中调用一个方法实现状态的变更： methods: { increment() { this.$store.commit('increment') console.log(this.$store.state.count) } } 注意：我们通过提交mutation的方式，而非直接改变store.state.count，是因为我们星耀更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样在阅读代码的时候能更容易地理解应用内部的状态改变。 核心概念 ","date":"2021-07-28","objectID":"/vue/:0:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"State Vuex使用单一状态树，一个对象就包含了全部的应用层级状态。至此它便作为一个”唯一数据源“而存在。这样意味着，每一个应用将仅仅包含一个store实例 存储在Vuex中的数据和Vue实例中的data遵循相同的规则。例如状态对象必须是纯粹 (plain) 的。 ","date":"2021-07-28","objectID":"/vue/:1:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"在Vue组件中获得Vuex状态 由于Vuex的状态存储时响应式的，从store实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return store.state.count } } } 每当 store.state.count 变化的时候，都会重新请求计算属性，并且触发更新相关联的DOM 缺点：这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用state的组件中需要频繁地导入。 Vuex通过store选项，提供了一种机制将状态从根组件”注入“到每一个子组件中（需要调用Vue.use(Vuex)） const app = new Vue({ el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` \u003cdiv class=\"app\"\u003e \u003ccounter\u003e\u003c/counter\u003e \u003c/div\u003e ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return this.$store.state.count } } } ","date":"2021-07-28","objectID":"/vue/:2:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"ref ","date":"2021-07-28","objectID":"/vue/:3:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Network"],"content":"Network","date":"2021-07-07","objectID":"/network/","tags":["Network"],"title":"Network","uri":"/network/"},{"categories":["Network"],"content":"计算机网络的概念 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善 的软件实现资源共享和信息传递的系统 计算机网络是互联的、自治的计算机集合 互联-互联互通 使用的就是通信链路 自治-无主从关系 计算机系统之间是相互独立的 ","date":"2021-07-07","objectID":"/network/:0:0","tags":["Network"],"title":"Network","uri":"/network/"},{"categories":["Linux"],"content":"Frp","date":"2021-07-06","objectID":"/frp/","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"配置FRP实现内网穿透 ","date":"2021-07-06","objectID":"/frp/:0:0","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"1、安装frp frp的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务（ps：例如在家里通过 ssh 访问处于公司内网环境内的主机） 说明 实现功能 ① 外网通过ssh访问内网机器（ps：主要验证实现此功能） ② 自定义绑定域名访问内网web服务 配置准备 ① 公网服务器1台（演示用机为CentOS系统） ② 内网服务器1台（演示用机为CentOS系统） ③ 公网服务器绑定域名1个（实现1-①功能不需要公网服务器绑定域名，1-②功能必须需要公网服务器绑定域名） ④ 内网服务器部署一个web服务，可以用tomcat模拟，没有测试。 先去官网下载frp：https://github.com/fatedier/frp/releases 下载完传到Linux服务器上，并且在/etc/local目录下创建frp文件夹，并且将frp解压至该文件下 mkdir /usr/local/frp cd frp tar -zxvf /root/frp_0.37.0_linux_amd64.tar.gz -C ./ 进入解压目录cd frp_0.13.0_linux_amd64，这里主要关注4个文件，分别是frpc、frpc.ini和frps、 frps.ini，**前者两个文件是客户端**所关注文件，**后者两个文件是服务端**所关注两个文件。 配置服务端（公网服务器），首先删掉frpc、frpc.ini两个文件，然后再进行配置，vi ./frps.ini [common] bind_port = 7000 #与客户端绑定的进行通信的端口 vhost_http_port = 7081 #访问客户端web服务自定义的端口号 保存然后启动服务，这是前台启动， ./frps -c ./frps.ini 后台启动命令为 nohup ./frps -c ./frps.ini \u0026 启动成功后的样子： 配置客户端（内网服务器），首先删掉frps、frps.ini两个文件,然后再进行配置，vi ./frpc.ini [common] server_addr = 192.168.167.227 # 公网服务器IP server_port = 7000 # 与服务端bind_port一致 # 公网通过ssh访问内部服务器 [ssh] type = tcp # 连接协议 local_ip = 192.168.167.117 # 内网服务器ip local_port = 22 # ssh默认端口号 remote_port = 7088 # 自定义的访问内部ssh端口号 # 公网访问内部web服务器以http方式 [web] type = http # 访问协议 local_prot = 8081 # 内部web服务的端口号 custom_domains = repo.clover.com # 所绑定的公网服务器域名，一级、二级域名都可以 保存然后执行启动，这是前台启动， ./frpc -c ./frpc.ini 后台启动命令为 nohup ./frpc -c ./frpc.ini \u0026 这种方法，我没有做成功，我换到使用隧道代理的方法上去了，以后有了计网的基础后，再来实践 这是隧道代理的信息 ","date":"2021-07-06","objectID":"/frp/:1:0","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"Environment","date":"2021-07-05","objectID":"/environment/","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"Linux编程环境和软件安装 ","date":"2021-07-05","objectID":"/environment/:0:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"1、安装JDK 去官网地址下载JDK：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 第一步，先卸载掉服务器自带的openJDK，通过命令查看已安装的openJDK rpm -qa | grep java 然后将java开头的删除完毕即可 yum -y remove java-1.7.0-openjdk-1.7.0.141-2.6.10.5.el7.x86_64 ...... 也可以执行，一次删除，删完后可以再次查看一次 yum -y remove javapackages-tools.noarch 然后将/root目录下的jdk解压到/usr/local/java路径下，java文件夹是你自己创建的 cd /usr/local mkdir java tar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./ 再去/etc/profile文件中配置环境变量 JAVA_HOME=/usr/local/java/jdk1.8.0_291 CLASSPATH=$JAVA_HOME/lib PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH 然后执行命令使配置文件生效 source /etc/profile 输入下面命令检查结果 java -version javac ","date":"2021-07-05","objectID":"/environment/:1:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"2、安装Node 先去官网下载node：https://nodejs.org/en/ 历史版本链接：https://nodejs.org/dist/ 先在/usr/local下创建一个node文件，然后将root目录下的node解压到当前node目录下 cd /usr/local/ mkdir node cd node tar -zxvf /root/node-v12.16.0-linux-x64.tar.gz -C ./ 解压完成后，去/etc/profile文件中配置环境变量 export PATH=/usr/local/node/node-v12.16.0-linux-x64/bin:$PATH 然后刷新文件 source /etc/profile 使用下面命令检查安装结果 node -v npm -v npx -v ","date":"2021-07-05","objectID":"/environment/:2:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"3、安装Maven 去官网下载Maven：http://maven.apache.org/ maven 下载地址：http://maven.apache.org/download.cgi maven 历史版本：https://archive.apache.org/dist/maven/maven-3/ 先去/opt目录下创建一个maven文件，然后将roo目录下的maven其解压到该文件中 cd /opt mkdir maven tar -zxvf /root/apache-maven-3.6.3-bin.tar.gz -C ./ 然后配置阿里的镜像 编辑修改 /opt/maven/apache-maven-3.6.3/conf/settings.xml文件 在\u003cmirrors\u003e\u003c/mirrors\u003e标签对⾥添加如下内容即可 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e 镜像配置完成后，去/etc/profile文件中配置环境变量 export MAVEN_HOME=/opt/maven/apache-maven-3.6.3 export PATH=$MAVEN_HOME/bin:$PATH 配置完环境变量，执行命令使配置文件生效 source /etc/profile 使用下面命令检查结果 mvn -v ","date":"2021-07-05","objectID":"/environment/:3:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"4、安装Redis 去官网下载Redis：https://redis.io/download 历史版本：http://download.redis.io/releases/ 先去/usr/local下创建一个redis文件，然后将root目录下的redis解压到该文件中 cd /usr/local/ mkdir redis cd redis tar -zxvf /root/redis-6.2.4.tar.gz -C ./ 解压完毕后，进入redis-6.2.4文件中执行下面命令 注意：如果你所装虚拟机为最小化介质安装，则需要先安装gcc，执行yum -install gcc后，才能执行下面命令，否则会报错 make \u0026\u0026 make install 将 REDIS 安装为系统服务并后台启动，进⼊ utils ⽬录，并执⾏如下脚本即可 cd utils/ ./install_server.sh 使用高版本的Redis的时候执行./install_server.sh，会报错 解决方法： 进入./install_server.sh文件中，对其编辑，将其中一段代码注释即可 再次执行./install_server.sh，即可成功，此处所有配置使用默认的 查看REDIS服务启动情况 systemctl status redis_6379.service 然后启动客户端进行测试 但是此时只能在本地访问，⽆法远程连接，因此还需要做部分设 设置允许远程连接 编辑redis配置文件 vim /etc/redis/6379.conf 将 bind 127.0.0.1 修改为 0.0.0.0 然后重启 Redis 服务即可： systemctl restart redis_6379.service 设置密码 编辑redis配置文件,并且找到如下内容，去掉注释，将foobared修改为⾃⼰想要的密码，保存即可，最后重启redis vim /etc/redis/6379.conf #requirepass foobared systemctl restart redis_6379.service 这样后续的访问需要先输⼊密码认证通过⽅可： ","date":"2021-07-05","objectID":"/environment/:4:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"5、安装Nginx 先去官网下载Nginx：http://nginx.org/en/download.html 先去/usr/local下创建一个nginx文件，然后将root目录下的nginx解压到该文件中 cd /usr/local/ mkdir nginx cd nginx tar -zxvf /root/nginx-1.18.0.tar.gz -C ./ 预先安装额外的依赖 yum -y install pcre-devel yum -y install openssl openssl-devel 编译安装Nginx cd nginx-1.17.10 ./configure make \u0026\u0026 make install 安装完成后，Nginx的可执⾏⽂件位置位于 /usr/local/nginx/sbin/nginx 启动Nginx 直接执行如下命令就可以了 /usr/local/nginx/sbin/nginx 如果想停⽌Nginx服务，可执⾏： /usr/local/nginx/sbin/nginx -s stop 如果修改了配置⽂件后想重新加载Nginx，可执⾏： /usr/local/nginx/sbin/nginx -s reload 注意其配置⽂件位于： /usr/local/nginx/conf/nginx.conf 浏览器验证启动情况 出现访问不了的问题有两个原因 是自己搭配的服务器，那就是看防火墙开了80端口没有 2.如果使用的是阿里或者腾讯云的要去网络安全组把80端口打开 执行下面命令打开防火墙的80端口 # 查看防火墙规则 firewall-cmd --list-all # 查询端口是否开放 firewall-cmd --query-port=8080/tcp # 开放80端口 firewall-cmd --permanent --add-port=80/tcp # 移除端口 firewall-cmd --permanent --remove-port=8080/tcp # 重启防火墙（修改配置后要重启防火墙） firewall-cmd --reload # 参数解释： firewall-cmd：是Linux提供的操作firewall的一个工具 --permanent：表示设置为持久 --add-port：标识添加的端口 开放端口号访问的结果： ","date":"2021-07-05","objectID":"/environment/:5:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"6、安装Mysql 先去官网下载Mysql：https://dev.mysql.com/downloads/mysql/ 如果系统之前⾃带 Mariadb ，可以先卸载之。 ⾸先查询已安装的 Mariadb 安装包: rpm -qa|grep mariadb 将其均卸载之 # 使用该四条命令可删除全部 yum -y remove mariadb-server-5.5.56-2.el7.x86_64 yum -y remove mariadb-5.5.56-2.el7.x86_64 yum -y remove mariadb-devel-5.5.56-2.el7.x86_64 yum -y remove mariadb-libs-5.5.56-2.el7.x86_64 # 但是用该条命令可以直接删除完毕 yum -y remove mariadb-libs.x86_64 先去/usr/local下创建一个mysql文件，然后将root目录下的mysql解压到该文件中 cd /usr/local mkdir mysql cd mysql tar -zxvf /root/mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz -C ./ 创建MYSQL⽤户和⽤户组 groupadd mysql useradd -g mysql mysql 同时新建/usr/local/mysql/data⽬录，后续备⽤ 修改MYSQL⽬录的归属⽤户 chown -R mysql:mysql ./ 准备MYSQL的配置⽂件 在/etc⽬录下新建my.cnf⽂件 写入如下简化配置 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 socket=/var/lib/mysql/mysql.sock [mysqld] skip-name-resolve #设置3306端⼝ port = 3306 socket=/var/lib/mysql/mysql.sock # 设置mysql的安装⽬录 basedir=/usr/local/mysql # 设置mysql数据库的数据的存放⽬录 datadir=/usr/local/mysql/data # 允许最⼤连接数 max_connections=200 # 服务端使⽤的字符集默认为8⽐特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使⽤的默认存储引擎 default-storage-engine=INNODB lower_case_table_names=1 max_allowed_packet=16M 同时使⽤如下命令创建/var/lib/mysql⽬录，并修改权限： mkdir /var/lib/mysql chmod 777 /var/lib/mysql 正式开始安装MYSQL cd /usr/local/mysql ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql -- datadir=/usr/local/mysql/data 注意：记住上⾯打印出来的root的密码，后⾯⾸次登陆需要使用 复制启动脚本到资源⽬录 cp ./support-files/mysql.server /etc/init.d/mysqld 并修改/etc/init.d/mysqld ，修改其 basedir 和 datadir 为实际对应⽬录： basedir=/usr/local/mysql datadir=/usr/local/mysql/data 设置MYSQL系统服务并开启⾃启 首先增加mysqld服务控制脚本执⾏权限： chmod +x /etc/init.d/mysqld 同时将mysqld服务加⼊到系统服务： chkconfig --add mysqld 最后检查mysqld服务是否已经⽣效即可： chkconfig --list mysqld 这样就表明mysqld服务已经⽣效了，在2、3、4、5运⾏级别随系统启动⽽⾃动启动，以后可以直接使 ⽤service命令控制mysql的启停. 直接执行 service mysqld start 将Mysql的BIN目录加入到PATH环境变量 这样方便以后任意目录上都可以使用mysql提供的命令 编辑/etc/profile文件，在文件末尾处追加如下信息 export PATH=$PATH:/usr/local/mysql/bin 最后执行如下命令使环境变量生效 source /etc/profile 首次登录Mysql 以root账户登录Mysql，使用上文安装完成提示的密码进行登入 mysql -u root -p 接下来修改ROOT账户密码 在mysql的命令执行如下命令即可，密码可以换成你想设置的密码即可 alter user user() identified by \"xn123456\"; flush privileges; 设置远程主机登录 use mysql; update user set user.Host='%' where user.User='root'; flush privileges; ","date":"2021-07-05","objectID":"/environment/:6:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"6、安装Tomcat ","date":"2021-07-05","objectID":"/environment/:7:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Netty"],"content":"Netty","date":"2021-07-04","objectID":"/netty/","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"study ","date":"2021-07-04","objectID":"/netty/:0:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Spring"],"content":"spring","date":"2021-07-04","objectID":"/spring/","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.Spring ","date":"2021-07-04","objectID":"/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.1 简介 下载spring所有版本信息的地址入口：https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/spring-framework-reference/ 下载spring所有版本信息的地址：http://repo.spring.io/release/org/springframework/spring github：https://github.com/spring-projects/spring-framework 导入spring-webmvc，可以快速一次性导入所有java包） \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.0.RELEASE\u003c/version\u003e \u003c/dependency\u003e 导入spring web jdbc \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-07-04","objectID":"/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.2 优点 开源的免费容器 轻量级，非入侵式的框架（引入不会对原来的代码产生任何影响） 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持 spring就是一个轻量级的控制反转和面向切面编程的框架 ","date":"2021-07-04","objectID":"/spring/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.3 组成 ","date":"2021-07-04","objectID":"/spring/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.4 学习路线 SpringBoot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 要先学Spring和SpringMVC SpringCloud 基于SpringBoot实现的 2.坑 多态父类实现子类独有的方法需要向下强转 public static void main(String[] args){} 可以由快捷键psvm加回车打出来 无参构造函数，只要一new就会执行 只要有new一定要写在main方法里 3.IOC DI ","date":"2021-07-04","objectID":"/spring/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.1 理论推导（依赖注入：set注入） //利用set进行动态实现值的注入 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } 之前程序是主动创建对象！控制权在程序员手上 使用set注入后，程序不再具有主动性，而是变成了被动的接受对象 这种思想从本质上解决了问题，我们程序员不用再去管理对象的创建了 ","date":"2021-07-04","objectID":"/spring/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.2 IOC本质 是一种通过描述（XML或注解）并通过第三方生产或获取特定对象的方式，在spring中实现控制反转的是Ioc容器，其实现方法是依赖注入（DI） ","date":"2021-07-04","objectID":"/spring/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.3 IOC容器(控制反转) 配置文件 xml中的bean标签就是一个对象，把类用bean标签添加在配置文件中，就相当于：类名 变量名=new 类名()，而标签中的id就是变量名，class就等于new的对象。所以myHello就是一个Hello类对象。这里的对象是由spring创建的，而不是java new出来的。 property相当于给对象中的基本数据类型的属性设置一个值（注意！！！，类中一定要有：set属性名(参数类型 参数值){this.属性名=参数值} 这个方法 \u003cbean id=\"myHello\" class=\"com.kua.pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"spring\"/\u003e \u003c/bean\u003e property如果要给对象中的对象数据设置值，那就是\u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e其中name表示对象属性名，表示引用spring中创建好的对象 \u003cbean id=\"myServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e \u003c/bean\u003e 初始化时，先读取配置文件，获得spring的上下文对象（固定语句不可变） ApplicationContext context=new ClassPathXmlApplicationContext(\"bean.xml\");//这里的bean.xml是配置文件名 通过上下文对象context的getBean方法从Ioc容器中直接取出对象 Hello myHello=(Hello)context.getBean(\"hello\"); ","date":"2021-07-04","objectID":"/spring/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.4 IOC综合 控制：谁来控制对象的创建，传统的应用程序是由程序本身来控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：利用set方法进行注入 IOC编程思想：由主动编程，变成被动接收，对象由Spring来创建，管理，装配 ","date":"2021-07-04","objectID":"/spring/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.5 IOC创建对象的方式（依赖注入：构造器注入） 使用构造器方式注入可以不写set 使用无参构造创建对象（默认的） 如果要用有参构造函数创建对象 方式一：下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e index表示参数的下标，value表示给参数赋值 方式二：匹配参数类型（不建议使用） \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e 注意：基本类型可以直接写，但是引用类型如：String得写全名 方式三：直接通过参数名 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e ","date":"2021-07-04","objectID":"/spring/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.6 IOC初始化对象的时间 在new ClassPathXmlApplicationContext，即加载完配置文件后就已经初始化好了所有bean对象，然后你需要getBean谁就取谁 4.Spring配置 ","date":"2021-07-04","objectID":"/spring/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"4.1 Spring配置 alias，给bean对象取别名（一对一） 给容器中的东西取别名 \u003calias name=\"user\" alias=\"user2\"/\u003e bean配置 id：bean的唯一标识符 class：bean对象所对应的全限定名（包+类） name：给bean对象取别名，可以同时取多个别名，中间可以用逗号、空格、分号隔开 import：一般用于团队开发使用，他可以将多个文件导入合并为一个 用import可以导入这个模块的其他bean文件，合并为一个总的，然后通过总的xml文件可以取到所有导入的bean里面的东西，如果不同bean中有相同的配置，但是配置的值不同，则下面的xml文件会覆盖上面的 5.DI依赖注入之set注入 ","date":"2021-07-04","objectID":"/spring/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"5.1、依赖注入之set注入 依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性值由容器注入 复杂类型： public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 真实测试对象： public class Student { private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003e card; private Set\u003cString\u003e games; private String wife; private Properties info; } bean4.xml \u003cbean id=\"adress\" class=\"com.kuang.pojo.Address\"/\u003e \u003cbean id=\"student\" class=\"com.kuang.pojo.Student\"\u003e \u003c!-- 普通值注入,value--\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c!-- bean注入，ref--\u003e \u003cproperty name=\"address\" ref=\"adress\"/\u003e \u003c!-- 数组注入--\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!-- List注入--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e打篮球\u003c/value\u003e \u003cvalue\u003e看剧\u003c/value\u003e \u003cvalue\u003e敲代码\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- Map注入--\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"学号\" value=\"2918378\"/\u003e \u003centry key=\"身份证\" value=\"2917321\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- Set注入--\u003e \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003e找你妹\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- null--\u003e \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c!-- Properties配置类型--\u003e \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"学号\"\u003e21342\u003c/prop\u003e \u003cprop key=\"性别\"\u003e女\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e 测试类： ApplicationContext context=new ClassPathXmlApplicationContext(\"bean4.xml\"); Student student=(Student) context.getBean(\"student\"); System.out.println(student.toString()); 6.导入test测试包（junit） ","date":"2021-07-04","objectID":"/spring/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"6.1、导入test测试包 \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.7.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 然后在测试类中@Test，这样在测试类中写出的方法，会自动被执行 7.c命名和p命名空间注入 ","date":"2021-07-04","objectID":"/spring/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"7.1、命名空间 p命名空间的注入，可以直接注入属性的值：property（本质还是set注入） 前提： 导入约束xmlns:p=“http://www.springframework.org/schema/p\" 要有set方法 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" p:age=\"18\" p:name=\"yzq\"/\u003e 可以直接在bean标签内注入属性的值 如果是注入对象则： 导入junit，并在测试文件中@Test（插曲） c命名空间（本质是构造器注入） 前提： 导入约束 xmlns:c=\"http://www.springframework.org/schema/c\" 要有set方法 必须要有无参构造函数和有参构造函数两种 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\"/\u003e 测试： @Test public void test2(){ ApplicationContext context=new ClassPathXmlApplicationContext(\"beans4.xml\"); User user=context.getBean(\"user\",User.class); System.out.println(user); }; 8.Bean Scopes（bean作用域） ","date":"2021-07-04","objectID":"/spring/:14:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"8.1、bean作用域 单例模式singleton（Spring默认机制） 对象只有一个，不管从相同的bean对象中getBean多少个对象，都是表示同一个对象，如下：输出true 用法：在bean的后面加上scope=“singleton”，也可以不加，因为这种作用域是spring默认的 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\" scope=\"singleton\"/\u003e User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 原型模式prototype 用法：scope=“prototype” 每次从容器中get时都会产生新对象，每个对象都不一样 User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 输入false 其他四个只能在web开发中使用 9.bean的自动装配（Autowired） ","date":"2021-07-04","objectID":"/spring/:15:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"9.1、bean自动装配 Spring会在上下文中自动寻找，并自动给bean装配属性，只针对bean对象 在Spring中有三种装配方式： 在xml中显示的配置 在java中显示的配置 隐式的自动装配bean（重要） 自动装配就是：可以不用在bean中自己手动装备bean对象的对象属性，也就是不用property来为对象中的对象引用赋值，但是只针对对象属性 用法：用autowired=““实现 People.java public void setName() { this.name = name; } public void setCat(Cat cat) { this.cat = cat; } public void setDog(Dog dog) { this.dog = dog; } bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c/bean\u003e byName表示在容器上下文中查找和自己set方法后面的值对应的beanid，弊端：名字必须相同 byType表示在容器上下文中查找和自己set方法中对象类型相同的对应的beanid，都可以省略id。弊 端：容器中所有bean的class唯一，即只有一个对象，如下就会报错 \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byType\"\u003e 10.使用注解实现自动装配 ","date":"2021-07-04","objectID":"/spring/:16:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.1 @Autowired 可以删掉set方法，但是需要get方法！！！ 前提：只针对bean对象，通过byType方式实现，如果有多个对象，就通过byName方式实现 导入约束 xmlns:context=\"http://www.springframework.org/schema/context\" 配置注解的支持 \u003c!--所有注解驱动--\u003e \u003ccontext:annotation-config/\u003e 容器中和.java中的名字要相同 使用： 在配置文件中注入所有你要自动装配的对象，然后直接在属性上面或者set方法上面使用@Autowired bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\"/\u003e People.java @Autowired private Cat cat; @Autowired private Dog dog; 也可以放在set方法上面 ","date":"2021-07-04","objectID":"/spring/:17:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.2 @Nullable(拓展) 如果显示定义@Autowired的require属性为false，那么那个对象的属性值为null也不会报错（但是完全没有定义，只有声明，就会报错） 与这有相同效果的是@Nullable，用法：在构造函数的形参前面 public People(@Nullable String name) { this.name = name; } ","date":"2021-07-04","objectID":"/spring/:18:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.3 @Qualifier 当容器中和.java中的对象名字和类型都不匹配时，这时@Autowired就没办法用，但如果又想要自动匹配，就可以使用@Qualifier(value=\"\")实现名字匹配 \u003cbean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e @Autowired @Qualifier(value=\"dog1\") private Dog dog; 但是可能在运行前要去maven里clean一下，再运行 ","date":"2021-07-04","objectID":"/spring/:19:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.4 @Resource 以上三种都是Spring注解，这一个是java注解 @Resource与@Autowired用法一样，但是@Resource先通过byName，再通过byType 当名字和类型都不匹配时：加一个name属性可以指定名字匹配 @Resource(name=\"\") ","date":"2021-07-04","objectID":"/spring/:20:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.5 @Component 见11的第2条的方法二 ","date":"2021-07-04","objectID":"/spring/:21:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.6 @Scope 见11的第5条 11.使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入，所以出错时检查这个包有没有问题 导入约束 增加支持 bean 属性如何注入（开启注解的支持） 方法一： 注解驱动 \u003ccontext:annotation-config/\u003e 方法二： 指定包中的全部注解都生效 \u003ccontext:component-scan base-package=\"com.kuang.pojo\"/\u003e 用@Component注解： 放在类上面，表示 这个类被Spring管理了，就是一个bean，而@Value就相当于bean中的property，给属性（这里的属性，不只是对象，还包含基本数据类型的属性）注入值，@Value也可以放在set方法上面 //相当于在配置文件中 //\u003cbean id=\"user\" class=\"com.kuang.pojo.User\" /\u003e @Component public class User { @Value(\"yzq\") private String name; } 衍生的注解 @Component有几个衍生注解，在web开发中，会按照mvc三层架构分层 poji层：@Component dao层：@Repository service层：@Service controller层：@Controller 这四个注解功能一样，都是讲某个类注入到容器中 自动装配置 以上所有注解 作用域 也可以使用注解：@Scope(“作用域类型”)，也是放在类上面的 @Component @Scope(\"prototype\") public class User{ } 小结 xml和注解： xml更加万能，适用于任何场所|维护简单方便 注解：不是自己的类使用不了，维护复杂，因为每个不同的类的注解是独立的 xml与注解最佳实践 xml用来管理bean 注解只负责完成属性的注入 注意：一定要开启注解的支持 12.使用java方式配置Spring ","date":"2021-07-04","objectID":"/spring/:22:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.1 用@Configuration配置过程 写一个类作为配置类，将@Configuration放在类上面，@Bean放在一个返回类的方法里面 @Configuration代表最这是一个配置类，和之前的bean.xml是一样的，本身也会被spring容器托管，注册到容器中，因为他本来就是一个@Component @Bean代表bean，哪个类的bean就写一个返回类的方法，然后bean的id就是方法的方法名 配置类： @Configuration public class myConfig { @Bean public User getUser(){ //返回要注入到bean中的对象 return new User(); } } 给bean中的属性注入值 @Value(\"yzq\") private String name; public String getName() { return name; } 测试类：注意是用的AnnotationConfigApplicationContext实现类，因为没有配置文件xml了，完全是用java+注解配置的，实参是写的配置类，bean的id名是配置类中的方法名 ApplicationContext context = new AnnotationConfigApplicationContext(myConfig.class); User getUser=(User) context.getBean(\"getUser\"); System.out.println(getUser.getName()); ","date":"2021-07-04","objectID":"/spring/:23:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.2 @Configuration扫描 也可以显示的扫描包 @Configuration //包中所有注解都生效 @ComponentScan(\"com.kuang.pojo\") public class myConfig { @Bean public User getUser(){ return new User(); } } 因为肯定有多个bean，所以就根据几个bean创建几个java配置类，然后每个类上面都加上@Configuration，代表这是一个配置类但是要把这么多bean整合到一起，就要使用@Import(其他配置类名.class) 13.代理模式 ","date":"2021-07-04","objectID":"/spring/:24:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.1 代理模式 ​ 为什么学习代理模式？ ​ 因为这是SpringAOP的底层 ","date":"2021-07-04","objectID":"/spring/:25:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.2 静态代理 角色分析： 抽象角色（租房）：一般会使用接口或者抽象类来解决 public interface rent { public void rent(); } 真实角色（房东）：被代理的角色 public void rent(){ System.out.println(\"房东要出租房子\"); }; 代理角色（中介）：代理真实角色，代理真实角色后，一般会做一些附属操作（代理角色自己的方法） public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent(){ host.rent(); hetong(); see(); fee(); } public void hetong(){ System.out.println(\"中介带你签合同\"); } public void see(){ System.out.println(\"中介带你看房\"); } public void fee(){ System.out.println(\"中介带你付费\"); } } 客户（我）：访问代理对象的人 public class Client { public static void main(String[] args) { //房东只租房子 Host host =new Host(); //代理出来租房子还有一些附属操作 Proxy proxy=new Proxy(host); //不用面对房东，直接找中介即可 proxy.rent(); } } 好处： 可以使真实角色操作更纯粹，不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工 公共业务发生拓展时，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率低 ","date":"2021-07-04","objectID":"/spring/:26:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.3 静态代理再理解 抽象角色 public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色，实现增删改查四个方法 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 代理角色：现有客户需要在每次实现什么方法的时候，能够输出实现了什么方法，称为日志功能，这个时候如果去在真实角色的代码里面添加，就违反了”改动原有代码，在公司中是大忌“，所以这时候就需要代理去实现 public class UserServiceProxy { private UserServiceImpl userServiceImpl; public void setUserServiceImpl(UserServiceImpl userServiceImpl) { this.userServiceImpl = userServiceImpl; } public void add(){ log(\"add\"); userServiceImpl.add(); } public void delete(){ log(\"delete\"); userServiceImpl.delete(); } public void update(){ log(\"update\"); userServiceImpl.update(); } public void query(){ log(\"query\"); userServiceImpl.query(); } public void log(String a){ System.out.println(\"实现了\"+a+\"方法\"); } } 客户：只需要跟代理角色接触，让代理角色去调用真实角色的各种方法 public class Client { public static void main(String[] args) { UserServiceImpl userServiceImpl=new UserServiceImpl(); UserServiceProxy userServiceProxy=new UserServiceProxy(); userServiceProxy.setUserServiceImpl(userServiceImpl); userServiceProxy.add(); } } ","date":"2021-07-04","objectID":"/spring/:27:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.4 聊聊AOP AOP实现机制，就是不改变原有代码，增加代理角色，面向切面编程 ","date":"2021-07-04","objectID":"/spring/:28:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.5 动态代理详解 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口：JDK的动态代理 基于类：cglib java字节码实现（现在用的多的）：javassist，javassist是一个开源的分析、编辑和创建java字节码的类库 前提：了解两个类 Proxy类：生成动态代理实例的，提供动态代理类和实例的静态方法 InvocationHandle：调用处理程序并返回一个结果的（调用处理程序实现的接口） 接口： public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色： public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 创建代理对象的类，ProxyInvocationHandle.java： //使用这个类动态生成代理类，这个类本身不是代理类，只是处理代理过程的一个类 public class ProxyInvocationHandle implements InvocationHandler { //设置被代理的接口 //实际上就是设置实现接口的真实角色对象 public Object target; public void setTarget(Object target) { this.target = target; } //生成得到代理类 public Object getProxy(){ //参数1：实现接口的真实类的位置 //参数2：真实类 //参数3：通过什么调用的 return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果，这个invoke方法是通过反射自动调用的，在getProxy时传了一个this，里面调用了invoke。每次当代理对象调用方法时都会经过这个方法，这个方法包含了所有代理对象需要处理的业务 //参数1：动态生成的代理对象的实例 //参数2：接口的方法，和真实角色接口方法一致 //代表调用接口方法对应的Object参数数组 public Object invoke(Object o, Method method, Object[] objects) throws Throwable { //因为method是接口的方法，所以getName就可以得到方法名 log(method.getName()); Object result=method.invoke(target,objects); return result; } //如果想要增加代理类自己的方法，就直接在下面写，下面是一个实现日志功能的方法 public void log(String msg){ System.out.println(\"实现了\"+msg+\"方法\"); } } 客户： public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService=new UserServiceImpl(); //处理和生成代理角色的类 ProxyInvocationHandle pih=new ProxyInvocationHandle(); //设置要代理的对象，实际上就是真实角色对象 pih.setTarget(userService); //生成代理类,要强转成接口类型，因为动态代理的是接口 UserService proxy=(UserService) pih.getProxy(); //现在就可以让代理类处理业务了 proxy.add(); } } 输出： 好处： 静态代理的优点全有 一个动态代理类代理的是一个接口，一般就是对应的一些业务 一个动态代理类可以代理多个类，只要实现了同一个接口就可以 14.AOP ","date":"2021-07-04","objectID":"/spring/:29:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.1 了解 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的技术，在不改变原来代码的基础上实现动态的增强 ","date":"2021-07-04","objectID":"/spring/:30:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2 使用Spring实现Aop 前提：使用AOP织入，需要导入一个依赖包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-07-04","objectID":"/spring/:31:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.1 方法一：使用原生Spring API接口（JDK）默认 此方法特点是，切入一个方法就要对应一个类 UserService接口 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } UserServiceImpl实现类 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); } public void delete(){ System.out.println(\"删\"); } public void update(){ System.out.println(\"改\"); } public void search(){ System.out.println(\"查\"); } } Log类：实现日志功能 public class Log implements MethodBeforeAdvice { @Override //参数method：要执行的目标对象的方法 //参数args：参数 //参数target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"类,实现了\"+method.getName()+\"方法\"); } } AfterLog类：实现方法执行后，得知返回值功能 public class AfterLog implements AfterReturningAdvice { @Override //参数returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); } } bean9.xml配置类 切入点表示要切入到哪里去，即实现接口的类中的方法要在哪里执行 执行环绕：表示把自定义类与切入点连接起来，对应起来，表示自定义类中的方法在对应的切入点处执行 \u003c!-- 注册bean--\u003e \u003cbean id=\"log\" class=\"com.kuang.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/\u003e \u003cbean id=\"userServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"/\u003e \u003c!-- 方法一:使用原生Spring API接口--\u003e \u003c!-- 配置aop：要在上面导入aop约束--\u003e \u003caop:config\u003e \u003c!-- 切入点:expression=\"execution(修饰符，返回值，类名，方法名，参数)\"--\u003e \u003c!-- * 代表任意修饰符返回值--\u003e \u003c!-- com.kuang.service.UserServiceImpl.* 表示这个类下的所有方法--\u003e \u003c!-- com.kuang.service.UserServiceImpl.*(..) 表示所有方法，(..)代表方法的任意参数--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 执行环绕增加:表示把log,afterLog类切入到上面切入点的所有方法中--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:config\u003e 测试类Test9.java public class Test9 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\"bean9.xml\"); // 因为动态代理代理的是接口 UserService userService=(UserService) context.getBean(\"userServiceImpl\"); userService.add(); } } ","date":"2021-07-04","objectID":"/spring/:31:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.2 方法二：使用自定义类（CGLIB） 此方法的特点是：切入的所有方法都存在于一个类中，切入 多少个方法就对应多少个函数 切面表示引用哪个类，即哪个类里面有自定义的特定功能的方法，它就是一个类。切面中还要还要定义切入点（切面要引用到哪里去）和通知（是要切入切面类中的哪个方法，且切入到哪里去） 自定义切面类 public class DivPointCut { public void before(){ System.out.println(\"函数执行之前\"); } public void after(){ System.out.println(\"函数执行之后\"); } } bean9.xml \u003c!-- 方法二:使用自定义类--\u003e \u003c!-- 注入自定义切面类--\u003e \u003cbean id=\"divPointCut\" class=\"com.kuang.divPointCut.DivPointCut\"/\u003e \u003caop:config\u003e \u003c!-- 自定义切面,ref要引用的类--\u003e \u003caop:aspect ref=\"divPointCut\"\u003e \u003c!-- 切入点--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 通知:即自定义切面中的方法,且要指定在哪里调用--\u003e \u003caop:before method=\"before\" pointcut-ref=\"pointcut\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e ","date":"2021-07-04","objectID":"/spring/:31:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.3 方法三：注解实现 与方法二原理一模一样，只是将xml换成注解 AnnotationPointCut自定义切面类： 注意选的是上面那个Before注解 //此注解表示这个类是一个切面 @Aspect public class AnnotationPointCut { //此注解表示这个方法是一个通知,切入点就写在@Before内 @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"函数执行前\"); } @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"函数执行后\"); } @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") //这里的joinPoint是指连接点,和切入点类似,但是它可以从切入地方拿东西，是必要的参数 //记得一定要抛出异常 public void around(ProceedingJoinPoint jp) throws Throwable{ System.out.println(\"环绕前\"); //代表执行方法 Object proceed=jp.proceed(); System.out.println(\"环绕后\"); //连接点还可以获得签名(实际上就是执行了哪个方法)等信息 Signature signature=jp.getSignature(); System.out.println(\"签名:\"+signature); } } 配置文件 \u003c!-- 方法三:使用注解--\u003e \u003c!-- 注入自定义切面--\u003e \u003cbean id=\"annotationPointCut\" class=\"com.kuang.divPointCut.AnnotationPointCut\"/\u003e \u003c!-- 注解支持--\u003e \u003caop:aspectj-autoproxy/\u003e 运行： ","date":"2021-07-04","objectID":"/spring/:31:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.4 小结 后面设置为false，使用JDK支持，这也是默认的 设置为true，使用cglib支持 \u003c!-- 注解支持--\u003e \u003capo:aspectj-autoproxy proxy-target-class=\"false\"/\u003e 15.整合mybatis ","date":"2021-07-04","objectID":"/spring/:31:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"15.1 回顾Mybatis Mybatis过程： 导入相关jar包 junit \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e mysql \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e mybatis \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e spring-webmvc \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e spring-jdbc \u003c!-- spring操作数据库的话,需要一个spring-jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e aspectjweaver：aop必导的包 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e mybatis-spring \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.2\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/nfmall?useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"uchr@123\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 测试 看到视频23的15:00 16.声明式事务 ","date":"2021-07-04","objectID":"/spring/:32:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"16.1 回顾事务 把一组业务当成一个业务来做，要么都成功要么都失败 涉及到数据的一致性问题 确保完整性和一致性 事务ACID原则 原子性：确保事务要么都成功要么都失败 一致性：事务完成后，要么都提交，要么就都不行，资源状态都要保持一致性 隔离性：多个业务操作同一个资源，防止数据损坏 持久性：事务一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化的写到存储器中 ","date":"2021-07-04","objectID":"/spring/:33:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["SpringBoot"],"content":"springboot","date":"2021-07-04","objectID":"/springboot/","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"SpringBoot原理探讨 创建一个Controller时，让其返回一个字符串，有两种方式 1、使用@RestController注解 2、使用RequestMapping+ResponseBody注解 **pom.xml ** spring-boot-dependencies：核心依赖在父工程中 我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库 启动器 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e 启动器：说白了就是SpringBoot的启动场景 比如说spring-boot-starte-web，他就会帮我们自动导入web环境所有的依赖！ springboot会将所有的功能场景，都变成一个个的启动器 我们要使用什么功能，就只需要找到对应的启动器就可以了start 主程序 // @SpringBootApplication ：标注这这个类是一个SpringBoot的应用 启动类下的所有资源被导入 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { // 将Springboot启动 SpringApplication.run(DemoApplication.class, args); } } 注解 @SpringBootConfiguration ： springboot的配置 @Configuration ：spring的配置类 @Component ：说明这也是一个spring的组件 @EnableAutoConfiguration ：自动配置 @AutoConfigurationPackage ：自动配置包 @Import(AutoConfigurationPackages.Registrar.class) ：自动配置包注册 @Import(AutoConfigurationImportSelector.class) ：自动配置导入选择 @SpringBootApplication 集成了所有注解，当它启动的时候，它所集成的资源都会被导入 META-INF/spring.factories：自动配置的核心文件 Properties properties = PropertiesLoaderUtils.loadProperties(resource) //所有资源加载到配置类中！ 所以，自动配置真正实现是从classpath中搜寻所有的/META-INF/spring.factories配置文件，并将其中对应的org.springframework.boot.autoconfigure.包下的配置项，通过反射实例化为对应标注了@Configuration的JavaConfig形式的IOC容器配置类，然后将这些都汇总成为一个实例并加载到IOC容器中 结论：springboot所有的自动配置都是在启动的时候扫描并加载：`spring.factories`所有的的自动配置类都在这里，但是不一定生效，要判断条件是否成立，只要导入了对应的start就有对应的启动器了，有了启动器，我们自动装配就会生效，然后就配置成功！ 1、springboot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值 2、将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置 3、以前我们需要自动配置的东西，现在springboot帮我们做了 4、整个JavaEE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中 5、它将所有的需要导入的组件一圈类名的方式返回，这些组件就会被添加到容器中 6、它会给容器中导入非常多的自动配置类(xxxAutoConfiguration)，就是给容器中导入这个场景需要的所有组件，并配置好这些组件，即自动装配(Configuration); 7、有了自动配置类，免去了我们手动编写配置注入功能组件等工作； springApplication.run方法分析 分析该方法主要分为两部分，一部分是SpringApplication的实例化，二是run方法的执行 SpringApplication 这个类主要做了一下四件事情 1、推断应用的类型是普通的项目还是web项目 2、查找并加载所有可用初始化器，设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 ","date":"2021-07-04","objectID":"/springboot/:1:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"配置文件 Springboot使用一个全局的配置文件，配置文件名称是固定的 application.properties 语法结构： key=value application.yml 语法结构：key: 空格 value 注意：这里的空格是不能少的，少了即失效 yml基础语法 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的 3、属性和值的大小写都是十分敏感的 字面量： 普通的值 [ 数字，布尔值，字符串] 字面量直接卸载后面就可以，字符串默认不用加上双引号或者单引号 k: v 注意： ““双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表达的意思； 比如：name: “clover \\n felix” 输出： clover 换行 felix ‘‘单引号，会转义特殊字符，特殊字符最终会变成和普通字符一样输出 比如：name:‘clover \\n felix’ 输出：clover \\n felix ","date":"2021-07-04","objectID":"/springboot/:2:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"注入配置文件 yaml注入配置文件 1、在springboot项目中的resource目录下新建一个文件application.yml 2、编写一个实体类Dog； @Component //注册bean到容器中 public class Dog { @Value(\"wangcai\") private String name; @Value(\"3\") private int age; // 有参无参构造、get、set方法、toString()方法 } 3、思考我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下 @Component //注册bean public class Dog { @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; } 4、在springboot的测试类下注入狗狗类并输出一下 @SpringBootTest class DemoApplicationTests { @Autowired //将狗狗自动注入进来 private Dog dog; @Test public void contextLoads() { System.out.println(dog); //打印看下狗狗对象 } } 结果成功输出，@Value注入成功，这是我们原来的方法 5、在编写一个复杂一点的实体类：Person类 Component //注册bean到容器中 public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map\u003cString,Object\u003e maps; private List\u003cObject\u003e lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 } 6、我们来使用yaml配置的方法进行注入，写的时候要注意区别和优势，编写一个yaml配置 person:name:cloverage:3happy:falsebirth:1996/08/24maps:{k1: v1,k2:v2}lists:- code- musicdog:name:wangcaiage:3 7、把刚刚写好的Person对象所有的值，注入到我们的类中 @Component /* @ConfigurationProperties作用： 将配置文件中配置的每一个属性的值，映射到这个组件中； 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 参数 prefix = \"person\" ：将配置文件中的person下面的所有属性一一对应 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 */ @ConfigurationProperties(prefix = \"person\") public class Person { private String name; private int age; private boolean happy; private Date birth; private Map\u003cString,Object\u003e maps; private List\u003cObject\u003e lists; private Dog dog; } 8、IDEA提示，SpringBoot配置注解处理器没有找到，让我们查看文档，我们查看文档，可以找到一个依赖 \u003c!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-configuration-processor\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e 9、确认以上配置都OK之后，去测试类中测试一下 @SpringBootTest class Springboot02ConfigApplicationTests { @Autowired private Person person; //将person自动注入进来 @Test void contextLoads() { System.out.println(dog); } } 结果：所有值全部注入成功 加载指定的配置文件 @PropertySource：加载指定的配置文件 @configurationProperties：默认从全局配置文件中获取值 注意：properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings--\u003eFileEncodings 中配置； 对比小结 @Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；看个功能对比图 1、@ConfigurationProperties只需要写一次即可，@Value则需要每个字段都添加 2、松散绑定：这个什么意思呢？比如我写的yml中写的lastname，这个和lastName是一样的，- 后面跟着的字母默认是大写的。这就是松散绑定。可以进行一下测试。 3、JSR303数据校验，这个就是我们可以在字段时增加一层锅炉其验证，可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象，使用value就不支持 结论： 配置yml和配置properties都可以获取到值，推荐使用yml 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下@Value 如果说我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接使用configurationProperties。 ","date":"2021-07-04","objectID":"/springboot/:3:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"自动配置原理 分析自动配置原理 在配置文件中能配置的东西，都存在一个固有的规律 比如：xxxxAutoConfiguration：都有一个默认值 xxxProperties 和 配置文件进行绑定，我们就可以使用自定义的配置了 xxxProperties中存在一些默认值，也就是xxxxAutoConfiguration的默认值，如果我们想要修改值，就必须让xxxProperties与配置文件绑定，然后就可以通过其中的属性修改默认值 以HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理； //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件； @Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中 @EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnClass({CharacterEncodingFilter.class}) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； @ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframe work.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } //。。。。。。。 } 一句话总结：根据当前不同的条件判断，决定这个配置类是否生效！ 一旦这个配置类生效：这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的; 所有在配置文件中能配置的属性都是在xxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 //从配置文件中获取指定的值和bean的属性进行绑定 @ConfigurationProperties(prefix = \"spring.http\") public class HttpProperties { // ..... } ","date":"2021-07-04","objectID":"/springboot/:4:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"自动配置原理再理解 SpringBoot类启动的时候有一个@SpringBootApplication注解 该注解里面又包含了三个非常重要的注解 @SpringBootConfiguration:点进去以后可以看到里面的底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置(使用Configuration配置类等同于XML文件) @EnableAutoConfiguration:开启自动配置功能 @ComponentScan:这个注解，默认是扫描当前类下的package。将@Controller/@Service/@Component/@Repository等注解加载到IOC容器中 ","date":"2021-07-04","objectID":"/springboot/:5:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"重点EnableAutoConfiguration 我们知道SpringBoot可以帮我们减少很多的配置，也肯定听过“约定大于配置”这么一句话，那SpringBoot是怎么做的呢？其实靠的就是@EnableAutoConfiguration注解。 简单来说，这个注解可以帮助我们自动载入应用程序所需要的所有默认配置。 点进去查看发现有两个比较主要的注解 @AutoConfigurationPackage：自动配置包 @Import：给IOC容器导入组件 ","date":"2021-07-04","objectID":"/springboot/:5:1","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"AutoConfigurationPackage 这个注解称之为自动配置包，点进去查看后发现依赖的还是Import注解 在点进去看，就发现重要的代码 在默认的情况下就是将：主配置类(@SpringBootApplication)所在包及其子包里边的组件扫描到Spring容器中。 看完这句话，会不会觉得，这不就是ComponentScan的功能吗？这俩不就重复了吗？ 我开始也有这个疑问，直到我看到文档的这句话： it will be used when scanning for code @Entity classes. It is generally recommended that you place EnableAutoConfiguration (if you’re not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched. 比如说，你用了Spring Data JPA，可能会在实体类上写@Entity注解。这个@Entity注解由@AutoConfigurationPackage扫描并加载，而我们平时开发用的@Controller/@Service/@Component/@Repository这些注解是由ComponentScan来扫描并加载的。 ","date":"2021-07-04","objectID":"/springboot/:5:2","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"回到Import 回到@Import(AutoConfigurationImportSelector.class)这句代码上，再点进去AutoConfigurationImportSelector.class看看具体的实现是什么： 我们再进去看一下这些配置信息是从哪里来的(进去getCandidateConfigurations方法)： 这里包装了一层，我们看到的只是通过SpringFactoriesLoader来加载，还没看到关键信息，继续进去： 梳理思路： FACTORIES_RESOURCE_LOCATION的值是META-INF/spring.factories Spring启动的时候会扫描所有jar路径下的META-INF/spring.factories，将其文件包装成Properties对象 从Properties对象获取到key值为EnableAutoConfiguration的数据，然后添加到容器中去 ","date":"2021-07-04","objectID":"/springboot/:5:3","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"总结 @SpringBootApplication等同于下面三个注解： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！ 通过获取到的key值为EnableAutoConfiguration的数据，就会自动去加载META-INF/spring.factories文件的信息，然后通过xxxxAutoConfiguration中的条件来判断当前这个配置类是否生效，如果生效就会往容器中添加组件 这些组件中属性的值是从对应的Properties类中所获取的，这些属性又是和配置文件进行绑定的 所以我们需要配置什么就可以参照properties来配置，你也可以去手动的修改其默认值 ","date":"2021-07-04","objectID":"/springboot/:5:4","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"静态资源映射规则 SpringBoot中，SpringMVC的web配置都在WebMvcAutoconfiguration这个配置类里面 WebMvcAutoconfiguration中有很多配置的方法 有一个方法addResourceHandlers添加资源处理 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { // 已禁用默认资源处理 logger.debug(\"Default resource handling disabled\"); return; } // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } 读源码： 比如/webjars/** ，都需要去classpath:/META-INF/resources/webjars/找对应的资源； 那什么是webjars呢？ Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可 使用SpringBoot需要使用Webjars，我们可以去搜索一下： 网站：https://www.webjars.org 【网站带看，并引入jQuery测试】 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ \u003cdependency\u003e \u003cgroupId\u003eorg.webjars\u003c/groupId\u003e \u003cartifactId\u003ejquery\u003c/artifactId\u003e \u003cversion\u003e3.4.1\u003c/version\u003e \u003c/dependency\u003e 查看webjars目录结构，并访问jQuery.js文件 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源 第二种静态资源映射规则 那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 我们去找staticPathPattern发现第二种映射规则 ： /** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：. // 进入方法 public String[] getStaticLocations() { return this.staticLocations; } // 找到对应的值 private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // 找到路径 private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即 上面数组的内容。 所以有四个目录存放的静态资源可以被我们识别 \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" 总结： 1、在SpringBoot，可以使用一下方式处理静态资源 webjars localhost:8080/webjars/ public，static，resources localhost:8080/ 2、优先级：resources\u003estatic(默认)\u003epublic 3、只要自定义了目录，默认路径就会失效，再次访问原来默认对应的路径就会报错 /* 与 /** 的区别： /* ：会匹配所有的url(只匹配当前文件夹下文件，不匹配子文件夹下文件)，包括*.jsp页面 /** ：会匹配所有的url(匹配当前文件夹下文件和子文件夹下文件)；路径型的和后缀型的url(包括/login，*.jsp，*.js，*.html等) ","date":"2021-07-04","objectID":"/springboot/:6:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"模板引擎 思想： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些 值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引 擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们 想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只 不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介 绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他 的这个语法更简单。而且呢，功能更强大。 引入Thymeleaf Thymeleaf 官网： Thymeleaf 在Github 的主页： Spring官方文档： 找到我们对应的版本 找到对应的pom依赖： \u003c!--thymeleaf--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e Maven会自动下载jar包，我们可以去看看下载的东西 Thymeleaf分析 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规 则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafProperties @ConfigurationProperties( prefix = \"spring.thymeleaf\" ) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; } 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ ","date":"2021-07-04","objectID":"/springboot/:7:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"MVC自动配置原理 官网阅读 官方文档 Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring's defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把\"1\"字符串自动转换为 int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 图标定制 Custom Favicon support (covered later in this document). // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能）， 则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或 ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own@Configuration class of type WebMvcConfigurer but without @EnableWebMvc.If you wish to provide custom instances of RequestMappingHandlerMapping,RequestMappingHandlerAdapter, orExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. ContentNegotiatingViewResolver 内容协商视图解析器 自动配置了ViewResolver，就是我们之前学习SpringMVC的视图解析器； 即根据方法的返回值取得视图对象(View)，然后由视图对象决定如何渲染(转发，重定向) 先查看一下源码：找到WebMvcAutoConfiguration，然后搜索ContentNegotiatingViewResolver。找到如下方法！ @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = \"viewResolver\", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; } 可以点击这个类(ContentNegotiatingViewResolver)看看，找到对应的解析视图的代码 @Nullable // 注解说明：@Nullable 即参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No currentServletRequestAttributes\"); List\u003cMediaType\u003e requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List\u003cView\u003e candidateViews = this.getCandidateViews(viewName, locale,requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } // ..... } 继续点击查看，是如何获取视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection\u003cViewResolver\u003e matchingBeans = BeanFactoryUtils.bea","date":"2021-07-04","objectID":"/springboot/:8:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"test ","date":"2021-07-04","objectID":"/springboot/:9:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["Redis"],"content":"Redis","date":"2021-07-04","objectID":"/redis/","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"NoSQL概述 1、单机Mysql的年代 90年代，一个基本的网站访问量不会太大，单个数据库完全足够 那个时候，更多的去使用静态网页HTML~ 服务器根本就没有太大的压力！ 思考，这种情况下：整个网站的瓶颈是什么？ 1、数据量如果太大了，一个机器放不下了！ 2、数据的索引，一个机器内存也存放不下 3、访问量（读写混合），一个服务器承受不了 只要开始出现以上的三种情况之一，那么你就必须要晋级！ Memcached（缓存） + MySQL + 垂直拆分（读写分离） 网站80%的情况下都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力 我们可以使用缓存来保证效率。 发展过程：优化数据结构和索引—\u003e文件缓存（IO）—\u003eMemcached（当时最热门的技术！） 3、分库分表 + 水平拆分 + MySQL集群 技术和业务在发展的同时，对人的要求也越来越高 本质：数据库（读、写） 早些年MyISAM：表锁（有100万条数据，查询张三就会将整个表锁起来，等查询完后才能进行下一条查 询，十分影响效率！高并发下就会出现严重的锁问题。 转战Innodb：行锁 慢慢的就开始使用分库分表来解决写的压力！MySQL在那个年代推出了表分区！这个并没有多少公司使用 MySQL的集群，很好满足那个年代的所有需求 4、如今最近的年代 MySQL等关系型数据库就不够用了！数据量很多，变化很快！ MySQL有的时候它用来存放一些比较大的文件，博客，图片！数据库表很大，效率就低了！如果有一种数 据库来专门处理这种数据，MySQL压力就变得十分小（研究如何处理这些问题！）大数据的IO压力下，表 几乎没法更改 目前一个基本的互联网项目 为什么要用NoSQL！ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库，NoSQL可以很好的处理以上的情况！ ","date":"2021-07-04","objectID":"/redis/:0:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"什么是NoSQL NoSQL NoSQL = Not Only SQL （不仅仅是SQL） 关系型数据库：表格，行，列 泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是 超大规模的高并发社区！暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速， Redis是发展的最快的，而且是我们当下必须要掌握的一个技术！ 很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！不 需要多余的操作就可以横向扩展！ Map\u003cString，Object\u003e使用键值对来控制 NoSQL特点 解耦！ 1、方便扩展（数据之间没有关系，很好扩展！） 2、大数据量高性能（Redis一秒写8万次，读取11万，NoSQL的缓存是记录级是一种细粒度的缓存，性能 会比较高） 3、数据类型是多样型的！（不需要事先设计数据库！随取随用！如果数据量十分大的表，很多人无法设计了） 4、传统的 RDBMS（关系型数据库） 和 NoSQL 传统的RDBMS - 结构化组织 - SQL - 数据和关系都存在单独的表中 - 数据操作，数据定义语言 - 严格的一致性 - 基础的事务 NoSQL - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储（HBase），文档存储（MongoDb），图形数据库（社交关系） - 最终一致性 - CAP定理和BASE　（异地存活！整个服务器宕机了，但是不影响其它的地方正常运行） - 高新能，高可用，高可扩 了解3V+3高 大数据时代的3V：主要是描述问题的 1、海量Volume 2、多样Variety 3、实时Velocity 大数据时代的3高：主要是对程序的要求 1、高并发 2、高可扩 3、高新能 真正在公司中的实践：NoSQL + RDBMS一起使用才是最强的 ","date":"2021-07-04","objectID":"/redis/:1:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"NoSQL的四大分类 KV键值对： 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memcache 文档型数据库（bson格式 和 json一样） MongoDB（一般必须掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！ MongoDB是一个介于关系型数据库和非关系型数据库的中间产品！MongoDB是NoSQL中功能最丰富，最像关系型数据库的！ ConchDB（不做了解、国外的） 列存储数据库 HBase 分布式文件系统 图关系数据库 它不是存图形的，放的是关系，比如：朋友圈社交网络，广告推荐！ Neo4j，InfoGrid； Redis入门 ","date":"2021-07-04","objectID":"/redis/:2:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server），即远程字典服务 是一个开源的使用ANSIC语言编写，支持网络、可基于内存亦可持久化的日志型、Key-Value数据库， 并提供多种语言的API redis会周期型的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且再次基础上实现了 master-slave（主从）同步。 Redis能干什么？ 1、 内存存储、持久化，内存中是断电即失，所以说持久化很重要。（RDB，AOF） 2、效率高，可以用于高速缓存 3、发布订阅系统 4、地图信息分析 5、计时器、计数器（浏览量！） ","date":"2021-07-04","objectID":"/redis/:3:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Windows安装 1、下载安装包 2、下载完毕得到压缩包 3、解压到自己环境目录下！Redis十分的小 4、开启Redis，双击运行即可！ 5、使用redis客户端来连接redis 记住一句话，Windows下使用确实简单，但是Redis推荐我们使用Linux去使用 ","date":"2021-07-04","objectID":"/redis/:4:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Linux安装包 1、下载安装包 2、解压Redis安装包！程序一般放在/opt下 3、进入解压后的文件，可以看到redis的配置文件 4、基本的环境安装 yum install gcc-c++ make make install 5、Redis的默认安装路径usr/local/bin 6、将redis配置文件。复制到我们当前的目录下 7、redis默认不是后台启动的，修改配置文件 8、启动redis服务 9、使用redis-cli进行连接测试 10、查看redis的进程是否开启 11、如何关闭redis服务shutdown 12、再次查看进程是否存在 ","date":"2021-07-04","objectID":"/redis/:5:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"测试性能 redis-benchmark是一个压力测试工具！ 官方自带的性能测试工具！ redis-benchmark +命令参数！ 可选参数如下： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 如何查看这些分析呢？ ","date":"2021-07-04","objectID":"/redis/:6:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"基础的知识 redis默认有16个数据库 默认使用的是第0个 可以使用select进行切换数据库！从0-15 清除当前数据库flushdb 清除全部数据库的内容flushall 127.0.0.1:6379[3]\u003e keys * # 查看数据库所有的key 1) \"name\" 127.0.0.1:6379[3]\u003e flushdb # 清除当前数据库 OK 127.0.0.1:6379[3]\u003e keys * (empty array) Redis是单线程的！ 明白Redis是很快的，官方表示，Redis是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是根据 机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所以就使用单线程了！ Redis是C语言写的，官方提供的数据为 100000+QPS，完全不必同样是使用key-value的Memecache差！ Redis为什么是单线程还这么快？查文献巩固一下 1、误区1：高性能的服务器一定是多线程的？ 2、误区2：多线程（CPU上下文会切换）一定比单线程效率高！ 核心：redis是将所有的数据据全部放在内存中的，所以说使用单线程去操作效率就是最高的,多线程（CPU 上下文会切换：这是一个耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高 的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！！ 五大数据类型 127.0.0.1:6379\u003e keys * # 查看所有的key 1) \"name\" 127.0.0.1:6379\u003e set age 1 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e exists name # 判断当前key是否存在 (integer) 1 127.0.0.1:6379\u003e exists name1 (integer) 0 127.0.0.1:6379\u003e move name 1 # 移出当前key (integer) 1 127.0.0.1:6379\u003e keys * 1) \"age\" 127.0.0.1:6379\u003e set name felix OK 127.0.0.1:6379\u003e KEYS * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e get name \"felix\" 127.0.0.1:6379\u003e move name 10 (integer) 1 127.0.0.1:6379\u003e keys * 1) \"age\" 127.0.0.1:6379\u003e set name felix OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e expire name 10 # 设置key的过期时间，单位是秒 (integer) 1 127.0.0.1:6379\u003e ttl name # 查看当前key 的剩余时间 (integer) 6 127.0.0.1:6379\u003e ttl name (integer) 4 127.0.0.1:6379\u003e ttl name (integer) 4 127.0.0.1:6379\u003e ttl name (integer) 3 127.0.0.1:6379\u003e ttl name (integer) 2 127.0.0.1:6379\u003e ttl name (integer) 1 127.0.0.1:6379\u003e ttl name (integer) -2 127.0.0.1:6379\u003e get name (nil) 127.0.0.1:6379\u003e type name # 查看当前key的一个类型 string 127.0.0.1:6379\u003e type age string ","date":"2021-07-04","objectID":"/redis/:7:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"String（字符串） 127.0.0.1:6379\u003e set key1 clover # 设置值 OK 127.0.0.1:6379\u003e get key1 # 获得值 \"clover\" 127.0.0.1:6379\u003e keys * # 获得所有的key 1) \"key1\" 127.0.0.1:6379\u003e EXISTS key1 # 判断某一个key是否存在 (integer) 1 127.0.0.1:6379\u003e APPEND key1 \"felix\" # 追加字符串，如果当前key不存在，就相当于setkey (integer) 11 127.0.0.1:6379\u003e get key1 \"cloverfelix\" 127.0.0.1:6379\u003e STRLEN key1 # 获取字符串的长度！ (integer) 11 127.0.0.1:6379\u003e APPEND key1 \",wei\" (integer) 15 127.0.0.1:6379\u003e get key1 \"cloverfelix,wei\" 127.0.0.1:6379\u003e STRLEN key1 (integer) 15 127.0.0.1:6379\u003e set views 0 # 初始浏览量为0 OK 127.0.0.1:6379\u003e get views \"0\" 127.0.0.1:6379\u003e incr views # 自增1 浏览量变为1 (integer) 1 127.0.0.1:6379\u003e incr views (integer) 2 127.0.0.1:6379\u003e get views \"2\" 127.0.0.1:6379\u003e decr views # 自减1 浏览量减一 (integer) 1 127.0.0.1:6379\u003e decr views (integer) 0 127.0.0.1:6379\u003e decr views (integer) -1 127.0.0.1:6379\u003e get views \"-1\" 127.0.0.1:6379\u003e INCRBY views 10 # 可以设置步长，指定增量 (integer) 9 127.0.0.1:6379\u003e DECRBY views 10 (integer) -1 127.0.0.1:6379\u003e get views \"-1\" 127.0.0.1:6379\u003e # 字符串范围 range 127.0.0.1:6379\u003e set key1 \"hello,clover\" # 设置key1的值 OK 127.0.0.1:6379\u003e get key1 \"hello,clover\" 127.0.0.1:6379\u003e GETRANGE key1 0 4 # 截取字符串[0，4] \"hello\" 127.0.0.1:6379\u003e GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的 \"hello,clover\" # 替换！ 127.0.0.1:6379\u003e set key2 abcdefg OK 127.0.0.1:6379\u003e get key (nil) 127.0.0.1:6379\u003e get key2 \"abcdefg\" 127.0.0.1:6379\u003e SETRANGE key2 1 xxx # 替换指定位置开始的字符串 (integer) 7 127.0.0.1:6379\u003e get key2 \"axxxefg\" # setex （set with expire） # 设置过期时间 # setnx （set if not exist） # 不存在再设置（在分布式锁中会常常使用！） 127.0.0.1:6379\u003e setex key3 30 cloverfelix # 设置key3的值为 cloverfelix，30秒后过期 OK 127.0.0.1:6379\u003e ttl key3 (integer) 21 127.0.0.1:6379\u003e setnx mykey \"redis\" # 如果mykey 不存在，创建mykey (integer) 1 127.0.0.1:6379\u003e keys * 1) \"key3\" 2) \"key2\" 3) \"mykey\" 4) \"key1\" 127.0.0.1:6379\u003e ttl key3 (integer) -2 127.0.0.1:6379\u003e setnx mykey \"mongoDB\" 如果mykey 存在，创建失败！ (integer) 0 127.0.0.1:6379\u003e get mykey \"redis\" # mset # mget 127.0.0.1:6379\u003e mset k1 v1 k2 v2 k3 v3 # 同时设置多个值 OK 127.0.0.1:6379\u003e keys * 1) \"k1\" 2) \"k3\" 3) \"k2\" 127.0.0.1:6379\u003e mget k1 k2 k3 # 同时获取 1) \"v1\" 2) \"v2\" 3) \"v3\" 127.0.0.1:6379\u003e msetnx k1 v2 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！ (integer) 0 127.0.0.1:6379\u003e get k4 (nil) 127.0.0.1:6379\u003e # 对象 set user:1 {name:zhangsan,age:3} # 这里的key是一个巧妙的设计：user:{id}:{filed属性}， 如此设计在Redis中完全是OK的 # 那么在设置文章的浏览量的时候就可以指定多篇文章的浏览量 127.0.0.1:6379\u003e mset user:1:name zhangsan user:1:age 3 OK 127.0.0.1:6379\u003e mget user:1:name user:1:age 1) \"zhangsan\" 2) \"3\" getset # 先get然后在set 127.0.0.1:6379\u003e getset db redis # 如果不存在值，则返回为null (nil) 127.0.0.1:6379\u003e get db \"redis\" 127.0.0.1:6379\u003e getset db mongodb # 如果存在值，获取原来的值，并设置新的值 \"redis\" 127.0.0.1:6379\u003e get db \"mongodb\" String类似的使用场景：value除了是我们的字符串还可以是我们的数字！ ","date":"2021-07-04","objectID":"/redis/:8:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"List 在redis乱码，我们可以把list玩成栈、队列、阻塞队列！ 所有的list命令都是用l开头的 127.0.0.1:6379\u003e LPUSH list one # 将一个或多个值插入列表的头部（从左边插入进去） (integer) 1 127.0.0.1:6379\u003e LPUSH list two (integer) 2 127.0.0.1:6379\u003e LPUSH list three (integer) 3 127.0.0.1:6379\u003e keys * 1) \"list\" 127.0.0.1:6379\u003e LRANGE list 0 -1 # 获取值是从前往后的，即先插入进来的值放在最后，最后插入的值放在最前面，下标为0 1) \"three\" 2) \"two\" 3) \"one\" 127.0.0.1:6379\u003e LRANGE list 0 1 # 通过区间获取具体的值 1) \"three\" 2) \"two\" 127.0.0.1:6379\u003e RPUSH list right # 将一个或多个值插入列表的头部（从右边插入进去） (integer) 4 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"two\" 3) \"one\" 4) \"right\" # LPOP # RPOP 127.0.0.1:6379\u003e lpop list # 移出list的第一个元素 \"three\" 127.0.0.1:6379\u003e rpop list # 移出list的最后一个元素 \"right\" 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" # index 127.0.0.1:6379\u003e lindex list 0 # 通过下标获得list中的某一个值！ \"two\" 127.0.0.1:6379\u003e lindex list 1 \"one\" # llen 127.0.0.1:6379\u003e lpush list one (integer) 1 127.0.0.1:6379\u003e lpush list two (integer) 2 127.0.0.1:6379\u003e lpush list three (integer) 3 127.0.0.1:6379\u003e llen list # 返回列表的长度 (integer) 3 # 移除指定的值！ 127.0.0.1:6379\u003e lrem list 1 three # 移出list集合中指定个数的value，精确匹配 (integer) 1 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" 127.0.0.1:6379\u003e lpush list three (integer) 3 127.0.0.1:6379\u003e lpush list three (integer) 4 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"three\" 3) \"two\" 4) \"one\" 127.0.0.1:6379\u003e lrem list 2 three (integer) 2 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" # list截断 127.0.0.1:6379\u003e rpush mylist \"hello\" (integer) 1 127.0.0.1:6379\u003e rpush mylist \"hello1\" (integer) 2 127.0.0.1:6379\u003e rpush mylist \"hello2\" (integer) 3 127.0.0.1:6379\u003e rpush mylist \"hello3\" (integer) 4 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello\" 2) \"hello1\" 3) \"hello2\" 4) \"hello3\" 127.0.0.1:6379\u003e ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello1\" 2) \"hello2\" 127.0.0.1:6379\u003e # rpoplpush 移出列表的最后一个元素，将它移动到新的列表中！ 127.0.0.1:6379\u003e rpush mylist \"hello\" (integer) 1 127.0.0.1:6379\u003e rpush mylist \"hello1\" (integer) 2 127.0.0.1:6379\u003e rpush mylist \"hello2\" (integer) 3 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"hello1\" 3) \"hello2\" 127.0.0.1:6379\u003e rpoplpush mylist myotherlist # 移出右边的最后一个元素，加入到新的list集合中去 \"hello2\" 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"hello1\" 127.0.0.1:6379\u003e lrange myotherlist 0 -1 1) \"hello2\" 127.0.0.1:6379\u003e # lset 将列表中指定下标的值替换为另外一个值，相当于更新操作 127.0.0.1:6379\u003e exists list # 判断这个表是否存在 (integer) 0 127.0.0.1:6379\u003e lset list 0 item # 如果不存在列表我们去更新就会报错 (error) ERR no such key 127.0.0.1:6379\u003e lpush list value1 (integer) 1 127.0.0.1:6379\u003e lrange list 0 0 1) \"value1\" 127.0.0.1:6379\u003e lset list 0 item # 如果存在，更新当前下标的值 OK 127.0.0.1:6379\u003e lrange list 0 0 1) \"item\" 127.0.0.1:6379\u003e lset list 1 test # 如果不存在，则会报错！ (error) ERR index out of range # linsert 将某个具体的value插入到列表中的某个元素的前面或者后面！ 127.0.0.1:6379\u003e rpush mylist hello (integer) 1 127.0.0.1:6379\u003e rpush mylist world (integer) 2 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"world\" 127.0.0.1:6379\u003e linsert mylist before world other (integer) 3 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"other\" 3) \"world\" 127.0.0.1:6379\u003e linsert mylist after world new (integer) 4 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"other\" 3) \"world\" 4) \"new\" 小结 它实际上是一个链表，可以在节点前后插入，left，right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移出了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点！ 可以当作消息队列（Lpush，Rpop），也可以作为栈（Lpush，Lpop） ","date":"2021-07-04","objectID":"/redis/:9:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Set（集合） set中的值是不能重复的！且插入值是随机分布的，并不是有序集合 127.0.0.1:6379\u003e sadd myset \"hello\" # sadd =\u003e set add set集合中添加元素 (integer) 1 127.0.0.1:6379\u003e sadd myset \"clover\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"cloverfelix\" (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset # smembers =\u003e set members 查看指定set的所有值 1) \"hello\" 2) \"clover\" 3) \"cloverfelix\" 127.0.0.1:6379\u003e sismember myset \"felix\" # sismember =\u003e set exist member 判断某一个值是不是在set集合中 (integer) 0 127.0.0.1:6379\u003e sismember myset \"clover\" # 存在集合中就返回0，不存在就返回值为1 (integer) 1 ###################################### 127.0.0.1:6379\u003e scard myset # 获取set集合中元素的个数 (integer) 3 ##################################### srem 127.0.0.1:6379\u003e srem myset \"hello\" # 移除set集合中的指定的元素 (integer) 1 127.0.0.1:6379\u003e scard myset (integer) 2 127.0.0.1:6379\u003e SMEMBERS myset 1) \"clover\" 2) \"cloverfelix\" ##################################### set 是无序不重复集合。抽随机！ 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机抽选出一个元素 \"felix\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"clover\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"clover\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"felix\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 # 随机抽取指定个数的元素 1) \"felix\" 2) \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 1) \"cloverfelix\" 2) \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 1) \"felix\" 2) \"test\" ##################################### 删除指定的key，随机删除key 127.0.0.1:6379\u003e SMEMBERS myset 1) \"clover\" 2) \"test\" 3) \"felix\" 4) \"cloverfelix\" 127.0.0.1:6379\u003e spop myset # 随机删除一些set集合中的元素 \"test\" 127.0.0.1:6379\u003e spop myset \"clover\" 127.0.0.1:6379\u003e spop myset \"cloverfelix\" 127.0.0.1:6379\u003e SMEMBERS myset 1) \"felix\" ##################################### 将一个指定的值，移动到另外一个set集合中！ 127.0.0.1:6379\u003e sadd myset \"hello\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"world\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"clover\" (integer) 1 127.0.0.1:6379\u003e sadd myset2 \"felix\" (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"hello\" 2) \"clover\" 3) \"world\" 127.0.0.1:6379\u003e SMOVE myset myset2 \"clover\" # 将一个指定的值，移动到另外一个set集合中！，第一个参数是源地址，第二个参数是目的地址 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"hello\" 2) \"world\" 127.0.0.1:6379\u003e SMEMBERS myset2 1) \"clover\" 2) \"felix\" 127.0.0.1:6379\u003e ##################################### 微博，B站，公共关注（并集） 数字集合类： - 差集 - 交集 - 并集 127.0.0.1:6379\u003e sadd key1 a (integer) 1 127.0.0.1:6379\u003e sadd key1 b (integer) 1 127.0.0.1:6379\u003e sadd key1 c (integer) 1 127.0.0.1:6379\u003e sadd key2 c (integer) 1 127.0.0.1:6379\u003e sadd key2 d (integer) 1 127.0.0.1:6379\u003e sadd key2 e (integer) 1 127.0.0.1:6379\u003e SDIFF key1 key2 # 差集 1) \"a\" 2) \"b\" 127.0.0.1:6379\u003e SINTER key1 key2 # 交集 1) \"c\" 127.0.0.1:6379\u003e SUNION key1 key2 # 并集 1) \"c\" 2) \"b\" 3) \"a\" 4) \"d\" 5) \"e\" 127.0.0.1:6379\u003e ","date":"2021-07-04","objectID":"/redis/:10:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Hash（哈希） Hash插入值是顺序插入，并且是可重复的！ 可以将其想象成一个Map集合！之前我们用的都是Key-Value，而我们这里是将Value换成Map，也就是 key-map的形式，Map中存放的又是一个key-value，所以这个时候这个值是一个Map集合 Hash本质和String类型没有太大区别，还是一个简单的key-value 127.0.0.1:6379\u003e hset myhash test1 felix # set一个具体的key-value OK 127.0.0.1:6379\u003e hset myhash test2 ryan OK 127.0.0.1:6379\u003e hget myhash test1 # 获取一个字段值 \"felix\" 127.0.0.1:6379\u003e hget myhash test2 \"ryan\" 127.0.0.1:6379\u003e hmset myhash test1 clover test2 cosy # set多个具体的key-value OK 127.0.0.1:6379\u003e hmget myhash test1 test2 # 获取多个字段值 1) \"clover\" 2) \"cosy\" 127.0.0.1:6379\u003e hgetall myhash # 获取全部数据，展示是key-value形式 1) \"test1\" 2) \"clover\" 3) \"test2\" 4) \"cosy\" 127.0.0.1:6379\u003e hdel myhash test2 # 删除指定key字段！对应的value值也就消失了！ (integer) 1 127.0.0.1:6379\u003e hgetall myhash 1) \"test1\" 2) \"clover\" 127.0.0.1:6379\u003e ######################################## hlen 获取hash的长度 127.0.0.1:6379\u003e hmset myhash test2 felix OK 127.0.0.1:6379\u003e HGETALL myhash 1) \"test1\" 2) \"clover\" 3) \"test2\" 4) \"felix\" 127.0.0.1:6379\u003e HLEN myhash # 获取hash表的字段数量 (integer) 2 127.0.0.1:6379\u003e ######################################## 127.0.0.1:6379\u003e HEXISTS myhash test0 # 判断hash中指定字段是否存在！ (integer) 1 127.0.0.1:6379\u003e HEXISTS myhash test4 (integer) 0 127.0.0.1:6379\u003e ######################################## # 只获得所有filed # 只获得所有value 127.0.0.1:6379\u003e hkeys myhash 1) \"test1\" 2) \"test2\" 3) \"test3\" 4) \"test0\" 127.0.0.1:6379\u003e hvals myhash # 这个地方使用的是简写 1) \"clover\" 2) \"felix\" 3) \"clover\" 4) \"clover\" 127.0.0.1:6379\u003e ######################################## incr 自增 decr 自减 127.0.0.1:6379\u003e hset myhash test4 5 (integer) 1 127.0.0.1:6379\u003e HINCRBY myhash test4 1 # 自增加1 (integer) 6 127.0.0.1:6379\u003e HINCRBY myhash test4 -1 # 这就相当于执行自减了 (integer) 5 127.0.0.1:6379\u003e hsetnx myhash test5 clover # 判断某一个值是否存在，不存在就创建一个，存在就返回0且不能设置 (integer) 1 127.0.0.1:6379\u003e hsetnx myhash test5 felix (integer) 0 127.0.0.1:6379\u003e hash用来保存变更的数据，尤其是用户信息之类的，经常变更的信息！hash更适合于对象的存储，String 更加适合字符串存储！ ","date":"2021-07-04","objectID":"/redis/:11:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Zset（有序集合） 在set基础上，增加了一个值 127.0.0.1:6379\u003e zadd myset 1 one # 添加一个值 (integer) 1 127.0.0.1:6379\u003e zadd myset 2 two 3 three # 添加多个值 (integer) 2 127.0.0.1:6379\u003e ZRANGE myset 0 -1 1) \"one\" 2) \"two\" 3) \"three\" 127.0.0.1:6379\u003e ########################################## 排序是如何实现的呢 127.0.0.1:6379\u003e zadd salary 2500 xiaohong # 添加三个用户 (integer) 1 127.0.0.1:6379\u003e zadd salary 5000 zhangsan (integer) 1 127.0.0.1:6379\u003e zadd salary 500 clover (integer) 1 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf # 显示全部的用户！ 从小到大排序 1) \"clover\" 2) \"xiaohong\" 3) \"zhangsan\" 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf withscores # 显示全部用户并且附带成绩 1) \"clover\" 2) \"500\" 3) \"xiaohong\" 4) \"2500\" 5) \"zhangsan\" 6) \"5000\" 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升序排序 1) \"clover\" 2) \"500\" 3) \"xiaohong\" 4) \"2500\" # 此处 狂神将得由问题：RANGE命令是指从小到大，不能用于去执行从大到小，要执行从大到小，得使用ZREVRANGE 127.0.0.1:6379\u003e ZREVRANGE salary 0 -1 1) \"zhangsan\" 2) \"xiaohong\" 3) \"clover\" 127.0.0.1:6379\u003e ######################################## # 移除指定的元素rem 127.0.0.1:6379\u003e zrange salary 0 -1 1) \"clover\" 2) \"xiaohong\" 3) \"zhangsan\" 127.0.0.1:6379\u003e zrem salary xiaohong # 移除有序集合中指定的元素 (integer) 1 127.0.0.1:6379\u003e zrange salary 0 -1 1) \"clover\" 2) \"zhangsan\" 127.0.0.1:6379\u003e zcard salary # 获取有序集合中的个数 (integer) 2 ####################################### 127.0.0.1:6379\u003e zadd myset 1 one 2 two 3 three (integer) 3 127.0.0.1:6379\u003e ZCOUNT myset 1 3 # 获取指定区间的成员数量 (integer) 3 127.0.0.1:6379\u003e ZCOUNT myset 1 2 (integer) 2 127.0.0.1:6379\u003e 三种特殊数据类型 ","date":"2021-07-04","objectID":"/redis/:12:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"geospatial地理位置 Redis的Geo在Redis3.2版本就推出了！这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！ 只有六个命令 getadd # getadd 添加地理位置 # 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！ # 有效的经度从-180度到180度。 # 有效的纬度从-85.05112878度到85.05112878度。 # 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 # 127.0.0.1:6379\u003e geoadd china:city 39.90 116.40 beijin (error) ERR invalid longitude,latitude pair 39.900000,116.400000 # 参数 key 值（） 127.0.0.1:6379\u003e geoadd china:city 116.40 39.90 beijing (integer) 1 127.0.0.1:6379\u003e geoadd china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379\u003e geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen (integer) 2 127.0.0.1:6379\u003e geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian (integer) 2 getpos 获得当前定位：一定是一个坐标值！ 127.0.0.1:6379\u003e GEOPOS china:city beijing # 获取指定的城市的经度和纬度！ 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" 127.0.0.1:6379\u003e GEOPOS china:city beijing chongqi 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" 2) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" GEODIST 两人之间的距离！ 单位： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 127.0.0.1:6379\u003e GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离 \"1067.3788\" 127.0.0.1:6379\u003e GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离 \"1464.0708\" georadius以给定的经纬度为中心， 找出某一半径内的元素 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人，200 所有数据应该都录入：china:city ，才会让结果更加清晰！ 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻 找方圆1000km内的城市 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km 1) \"chongqi\" 2) \"xian\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置 1) 1) \"chongqi\" 2) \"341.9374\" 2) 1) \"xian\" 2) \"483.8340\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息 1) 1) \"chongqi\" 2) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 2) 1) \"xian\" 2) 1) \"108.96000176668167114\" 2) \"34.25999964418929977\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist withcoord count 1 # 筛选出指定的结果！ 1) 1) \"chongqi\" 2) \"341.9374\" 3) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist withcoord count 2 1) 1) \"chongqi\" 2) \"341.9374\" 3) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 2) 1) \"xian\" 2) \"483.8340\" 3) 1) \"108.96000176668167114\" 2) \"34.25999964418929977\" GEORADIUSBYMEMBER # 找出位于指定元素周围的其他元素！ 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city beijing 1000 km 1) \"beijing\" 2) \"xian\" 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city shanghai 400 km 1) \"hangzhou\" 2) \"shanghai\" GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示 该命令将返回11个字符的Geohash字符串! # 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！ 127.0.0.1:6379\u003e geohash china:city beijing chongqi 1) \"wx4fbxxfke0\" 2) \"wm5xzrybty0\" GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！ 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 # 查看地图中全部的元素 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 5) \"shanghai\" 6) \"beijing\" 127.0.0.1:6379\u003e zrem china:city beijing # 移除指定元素！ (integer) 1 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 5) \"shanghai\" ","date":"2021-07-04","objectID":"/redis/:13:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Hyperloglog 什么是基数？ A {1,3,5,7,8,7} B{1,3,5,7,8} 基数（是指一个集合中不重复的元素）= 5 可以接受误差！ 简介 Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！ 优点：占用的内存是固定，2^64 不同的元素的基数，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！ 网页的 UV （一个人访问一个网站多次，但是还是算作一个人！） 传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； 0.81% 错误率！ 统计UV任务，可以忽略不计的！ 测试使用 127.0.0.1:6379\u003e PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey (integer) 1 127.0.0.1:6379\u003e PFCOUNT mykey # 统计 mykey 元素的基数数量 (integer) 10 127.0.0.1:6379\u003e PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2 (integer) 1 127.0.0.1:6379\u003e PFCOUNT mykey2 (integer) 9 127.0.0.1:6379\u003e PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =\u003e mykey3 并集 OK 127.0.0.1:6379\u003e PFCOUNT mykey3 # 看并集的数量！ (integer) 15 如果允许容错，那么一定可以使用 Hyperloglog ！ 如果不允许容错，就使用 set 或者自己的数据类型即可！ ","date":"2021-07-04","objectID":"/redis/:14:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Bitmap 为什么其他教程都不喜欢讲这些？这些在生活中或者开发中，都有十分多的应用场景，学习了，就是就是 多一个思路！ 技多不压身！ 位存储 统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用 Bitmap！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！ 测试 一个方框代表一天，来统计一个星期的打卡情况 使用bitmap 来记录 周一到周日的打卡！ 查看某一天是否打卡 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 6 (integer) 0 统计操作，统计 打卡的天数！ 127.0.0.1:6379\u003e bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！ (integer) 3 事务 要么同时成功，要么同时失败，原子性！ Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序 执行！ 一次性（队列中的命令一次执行完）、顺序性、排他性（不允许别人干扰）！执行一系列命令！ ----------------- 队列 set（命令）set（命令） set（命令）执行---------------------- 命令执行的过程中是不允许被打断的，出现了错误会去执行处理错误的机制 Redis事务没有隔离级别的概念 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec（执行命令） Redis单条命令是保存原子性的，但是redis事务不保证原子性！ redis的事务： 开启事务（multi） 命令入队（） 执行命令（exec） 正常执行事务！ 127.0.0.1:6379\u003e multi # 开启事务 OK # 命令入队 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e exec # 执行事务 1) OK 2) OK 3) \"v2\" 4) OK 127.0.0.1:6379\u003e multi # 开启事务 OK # 命令入队 127.0.0.1:6379\u003e set k1 v1 放弃事务！ 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e DISCARD # 取消事务 OK 127.0.0.1:6379\u003e get k4 # 事务队列中命令都不会被执行！ (nil) 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！ 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e getset k3 # 错误的命令 (error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e set k5 v5 QUEUED 127.0.0.1:6379\u003e exec # 执行事务报错！ (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379\u003e get k5 # 所有的命令都不会被执行！ (nil) 运行时异常（1/0）， 如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！ 127.0.0.1:6379\u003e set k1 \"v1\" OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e incr k1 # 会执行的时候失败！ QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e get k3 QUEUED 127.0.0.1:6379\u003e exec 1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！ 2) OK 3) OK 4) \"v3\" 127.0.0.1:6379\u003e get k2 \"v2\" 127.0.0.1:6379\u003e get k3 \"v3\" 监控！ Watch （面试常问！） 悲观锁： 很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁： 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据， 获取version 更新的时候比较 version Redis测监视测试 正常执行成功！ 127.0.0.1:6379\u003e set money 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e watch money # 监视 money 对象 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY out 20 QUEUED 127.0.0.1:6379\u003e exec # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！ 1) (integer) 80 2) (integer) 20 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ Watch的生命周期，只是和事务关联的，一个事务执行完毕（执行了exec命令），相应的Watch的生命周期即将结束 127.0.0.1:6379\u003e watch money # 监视 money OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 10 QUEUED 127.0.0.1:6379\u003e INCRBY out 10 QUEUED 127.0.0.1:6379\u003e exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！ (nil) ################################ 这是第二条线程，在还没执行exec时，第二条线程插队修改了值 127.0.0.1:6379\u003e get money \"80\" 127.0.0.1:6379\u003e set money 1000 OK 如果修改失败，获取最新的值就好 Jedis 我们要使用 Java 来操作 Redis 什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用 java操作redis，那么一定要对Jedis 十分的熟悉！ 测试 1、导入对应的依赖 \u003c!--导入jedis包--\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003c!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.75\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 2、编码测试： -连接数据库 操作命令 断开连接！ package com.clover; import redis.clients.jedis.Jedis; public class TestPing { public static void main(String[] args) { //1、new Jedis()对象即可 Jedis jedis = new Jedis(\"127.0.0.1\",6379); //jedis所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要 System.out.println(jedis.ping()); } } ","date":"2021-07-04","objectID":"/redis/:15:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"常用的API String List Set Hash Zset 事务 package com.clover; import com.alibaba.fastjson.JSONObject; import redis.clients.jedis.Jedis; import redis.clients.jedis.Transaction; public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.4\", 6379); //每次执行前清空数据库 jedis.flushDB(); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\",\"world\"); jsonObject.put(\"name\",\"clover\"); //开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); try { multi.set(\"user1\",result); multi.set(\"user2\",result); //int i = 1/0;//代码抛出异常，执行失败 multi.exec();//执行事务 } catch (Exception e) { multi.discard();//放弃事务 e.printStackTrace(); } finally { System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close();//关闭连接 } } } SpringBoot整合 SpringBoot操作数据：都是集中在spring-data中操作 SpringData和SpringBoot齐名的项目！ 说明：在SpringBoot2.x之后，原来使用的Jedis被替换成了lettuce jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！更像 BIO模式 lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数量，更像 NIO模式 源码分析 @Bean @ConditionalOnMissingBean(name = \"redisTemplate\") // 我们可以自己定义一个redis Template来替换这个默认的！ public RedisTemplate\u003cObject, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 默认的 Redis Template 没有过多的设置，redis 对象都是需要序列化！ // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 \u003cString, Object\u003e RedisTemplate\u003cObject, Object\u003e template = new RedisTemplate\u003c\u003e(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！ public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } 整合测试 1、导入redis依赖 \u003c!--操作redis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写配置文件 # SpringBoot 所有的配置类，都会由一个自动配置类 # 自动配置类都会绑定一个 properties 配置文件 # 配置redis spring.redis.host=127.0.0.1 spring.redis.port=6379 # 我们以后使用集群部署时尽量使用最新的lettuce，因为Jedis中有一部分配置类不存在，所以不生效 # 而lettuce中所有的类默认都是生效的 我们以后使用集群部署时尽量使用最新的lettuce，因为Jedis中有一部分配置类不存在，所以不生效 而lettuce中所有的类默认都是生效的 3、测试！ package com.clover.redis02springboot; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForSet // opsForHash // opsForZSet // opsForGeo // opsForHyperLogLog // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD // 获取redis的连接对象 // RedisConnection connection =redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"clover\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 关于对象的保存时出现的问题 1、使用了序列化时的结果 @Test public void test() throws JsonProcessingException { // 真实的开发中，我们一般使用json来传递对象 User user = new User(\"clover\", 3); // 这个是我们创建SpringBoot项目中所存在的，也就是jackson对象 // 序列化该对象 String obj = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\",obj); System.out.println(redisTemplate.opsForValue().get(\"user\")); } 2、未使用序列化时的结果 @Test public void test() throws JsonProcessingException { // 真实的开发中，我们一般使用json来传递对象 User user = new User(\"clover\", 3); // 这个是我们创建SpringBoot项目中所存在的，也就是jackson对象 // 序列化该对象 //String obj = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\",user); System.out.println(redisTemplate.opsForValue().get(\"user\")); } 产生的报错结果如下图： 我们编写一个自己的Tempalte package com.clover.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; i","date":"2021-07-04","objectID":"/redis/:16:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"RDB（Redis Database） 在主从复制中，RDB是用来备份的，存在在从机中，不占用主机内存！ 什么是RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建一个(fork)一个紫禁城来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ rdb保存的文件是 dump.rdb 都是在我们的配置文件中的快照进行配置的！ 触发机制 1、sava规则满足的情况下，会自动触发rdb规则 2、执行flushall命令，也会触发我们的rdb规则 3、退出redis，也会产生rdb文件 备份就会自动生成一个dump.rdb文件 注意，使用sava命令保存时，也会产生一个edb文件 如何恢复rdb文件 1、只需要将rdb文件放在我们redis启动目录就可以了，redis启动的时候会自动检查dump.rdb 恢复其中的数据 2、查看需要存放的位置 127.0.0.1:6379\u003e config get dir 1) \"dir\" 2) \"/usr/local/bin\" 几乎它自己默认的配置就够用了，但是我们还是要去学习 优点: 1、适合大规模的数据恢复！ 2、对数据的完整性要求不高！ 缺点： 1、需要一定的时间间隔进行操作！如果redis意外宕机了，这个最后一次修改的数据就没有了！ 2、fork进程的时候，会占用一定的内存空间! ","date":"2021-07-04","objectID":"/redis/:17:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"AOF(Append Only File) 以日志的形式来记录每个写操作。将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换而言之，redis重启的化就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF保存的是appendonly.aof文件 append 默认是不开启的，我们需要手动进行配置！我们只需要将appendonly 改为yes就开启了aof！ 重启，redis就可以生效了！ 如果这个aof文件有错误，这时候redis是启动不起来的，我们需要修复这个aof文件 redis 给我们提供了一个工具redis-check-aof --fix 如果文件正常，重启就可以直接恢复了！ 但是它对文件进行修复，也不是全部修复，是可能损坏部分值的！！！ 重写规则说明 aof默认就是文件的无限追加，文件会越来越大 如果aof文件大于64M，太大了的话，就会fork一个新的进程来将我们的文件进行重写！ 优点和缺点 优点： 1、每一次修改都同步，文件的完整性会更好 2、每秒同步一次，可能会丢失一秒的数据 3、从不同步，效率是最高的！ 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢！ 2、Aof运行效率也比rdb慢（因为其文件比rdb大），所以我们redis默认的配置就是rdb持久化！ 扩展： 1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 **3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 ** 4、同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。 Redis发布订阅 Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。 Redis客户端可以订阅任意数量的频道。 订阅/发布消息图： 下图展示了频道channel1，以及订阅这个频道的三个客户端–client2、client5和client1之间的关系： 当有新消息通过PUBLISH 命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端： 命令 测试 订阅端： 127.0.0.1:6379\u003e SUBSCRIBE clover Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"clover\" 3) (integer) 1 # 等待读取推送的信息 1) \"message\" # 接送的是什么，消息 2) \"clover\" # 哪个频道的消息 3) \"hello,world\" # 消息的具体内容 1) \"message\" 2) \"clover\" 3) \"hello,cloverfelix\" 发送端: 127.0.0.1:6379\u003e PUBLISH clover \"hello,world\" # 发布者发布消息到频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH clover \"hello,cloverfelix\" # 发布者发布消息到频道 (integer) 1 127.0.0.1:6379\u003e 原理 Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 Redis主从复制 ","date":"2021-07-04","objectID":"/redis/:18:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点 一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-07-04","objectID":"/redis/:19:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用（集群）基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-07-04","objectID":"/redis/:20:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"为什么使用集群 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下： 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大； 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是\"多读少写\"。 对于这种场景，我们可以使如下这种架构： 环境配置 只用配置从库，不用配置主库，因为每个Redis是默认自己是主库 127.0.0.1:6379\u003e info replication # 查看当前库的信息 # Replication role:master # 角色 master connected_slaves:0 # 没有从机 master_failover_state:no-failover master_replid:ce9e2da75c46b69ccaf4bea614598be642658691 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 复制3个配置文件，然后修改对应的信息 1、端口 2、pid 名字 3、log文件名字 4、dump.rdb 名字 修改完毕后，启动我们3个redis服务，可以通过进程信息查看 ","date":"2021-07-04","objectID":"/redis/:21:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"一主二从 127.0.0.1:6380\u003e SLAVEOF 127.0.0.1 6379 OK 127.0.0.1:6380\u003e info replication # Replication role:slave # 当前角色是从机 master_host:127.0.0.1 # 可以查看到主机的信息 master_port:6379 master_link_status:up master_last_io_seconds_ago:3 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 replica_announced:1 connected_slaves:0 master_failover_state:no-failover master_replid:80653bedaad4360f908ff72a68a47a4bd1045f0f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14 127.0.0.1:6380\u003e # 在主机中查看信息 127.0.0.1:6379\u003e info replication # Replication role:master connected_slaves:2 # 多了从机的信息，可以查看从机的信息 slave0:ip=127.0.0.1,port=6380,state=online,offset=56,lag=1 slave1:ip=127.0.0.1,port=6381,state=online,offset=56,lag=1 master_failover_state:no-failover master_replid:80653bedaad4360f908ff72a68a47a4bd1045f0f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:56 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:56 127.0.0.1:6379\u003e 如果两个都配置完了，就会显示两个从机 真实的主从配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，只是暂时的！ ","date":"2021-07-04","objectID":"/redis/:22:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"使用规则 1.从机只能读，不能写，主机可读可写但是多用于写。 2.从机只能读取内容，如果写入内容会报错 测试 主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息 如果是使用命令行来配置的从机，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！ 复制原理 Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！ 层层链路 上一个Master链接下一个Slave 这样也可以完成我们的主从复制！ 如果没有老大了，这个时候能不能选择一个老大出来呢？哨兵模式没出来之前是：手动选择 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其它的节点就可以手动连接到这个最新的主节点（手动）如果这个时候老大修复了，那就只有重新配置连接了！ ","date":"2021-07-04","objectID":"/redis/:23:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"哨兵模式 Redis缓存与雪崩 ","date":"2021-07-04","objectID":"/redis/:24:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Linux部署"],"content":"Linux部署","date":"2021-07-04","objectID":"/mutinodelinux/","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"部署项目到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:0:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"使用的是ruoyi进行试验 ","date":"2021-07-04","objectID":"/mutinodelinux/:1:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"第一步 首先将项目后端的数据库以及一些配置文件配置好 数据库配置： 对于这里的数据库必须使用远程的数据库，本地数据库是不起作用的 其次就是需要在服务器上创建对应的数据库，填写相关的信息 如果你有多台服务器的话你也可以架设到不同的服务器上（但我受限只有一台服务器，就在一台服务器上实验了） 修改redis配置 由于我们的项目全部是部署在服务器上的，所以我们所依赖的环境全部是存在于服务器上 由于我们服务器上的redis是没有设置密码的，所以默认为空 修改pom.xml文件中字符集的设置 注意：由于我采用的是ruoyi的项目，不同的项目对应不同的要求，ruoyi这个项目需要你改动一下pom.xml的配置文件 将encoder对应的地方的字符集编码改为UTF-8 4.修改pom.xml文件中的日志文件logs 如果是第一次运行的话是不存在改路径的，就需要改为自己日志文件存放的路径了 如果是以及运行过的，可以忽略不看 将一些环境配置修改好后就可以运行起来了，当你运行成功后，就可以先将前端打包传送到服务器上 使用terminus工具进行上传 注意：不要使用文件夹拖拽的形式，有可能存在一些隐藏的文件夹没有传递过去 传到服务器上的home目录下自己创建的文件夹中，然后在进行文件的解压 上传成功后，就对该文件夹进行解压**（前端）** 这就是解压后的文件 解压成功后，也把后端运行好的项目压缩上传到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:2:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"然后开始进行前端的打包操作 安装依赖 由于我们使用的是root权限所以我们在前面加上--unsafe-perm npm install --unsafe-perm --registry=https://registry.npm.taobao.org 注意：如果你没有安装node的话是执行不了的，那你就必须得先去安装node后才可以执行，Linux上安 装node的教程可以参考codesheep给的pdf上安装node的教程，只是，他最后配置node环境变量时，那个profile文件夹是存在于/etc下的profile文件夹中进行配置，而不是他pdf上所给的指令，使用pdf上的指令会提示我们没有权限 安装完依赖后就可以使用npm run build:prod打生产环境前端的包就可以了 但是在运行的过程中出现了错误信息提示 于是，我将node_modules模块删除掉了，再次运行npm install时，又有新的错误信息出现了 然后我找到一个博客找寻到了解决方法：https://blog.csdn.net/Jserm/article/details/105997504 原因是因为：For security reasons, if you run npm install as root, npm will set the user to “nobody” when running postinstall scripts, which does not have access to the project directory, thus the error message. 出于安全原因，如果您以 root 身份运行 npm install，npm 将在运行 postinstall 脚本时将用户设置为“nobody”，该脚本无权访问项目目录，因此会出现错误消息。 总结：出现这么多错误的原因是：因为之前我上传到服务器上的代码都是我之前已经运行好了，并且配置好了环境变量，已经依赖的，所以导致我上传至服务器后重复安装依赖出现错误。 所以刚才我是重新下载的一个源码直接上传到服务器上去后就直接打jar包成功了 但是，这也可能只是我的片面看法，有可能是其它的原因，是我目前所没有想到的，我暂且就将这个错误认为是我之前已经运行好的代码中有依赖环境存在，是我反复的运行没有成功，这个错误，我会在后期中再次进行验证 ","date":"2021-07-04","objectID":"/mutinodelinux/:3:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"现在对后端进行打jar包 前提：是服务器上装有maven环境 先去下载一个maven安装包，寻找一个3.6.x版本的maven，找到一个历史地址：https://archive.apache.org/dist/maven/maven-3/ 安装完成以后按照codesheep给的安装教程去配置环境变量，注意自己文件夹的命名与codesheep是不一样的 注意：为什么需要打jar包与war包，因为使用jar包是因为SpringBoot内置了Tomcat服务器，就可以不适用服务器上的Tomcat，而使用内置的Tomcat就行；而打war包就是不使用SpringBoot内置的Tomcat，而是使用服务器自己搭配的Tomcat服务器 将前后端打包好后，就可以将前端部署到Nginx 修改nginx配置文件 先将user改为root，以防止出现不必要的权限错误（这里指的是如果你的项目放在root目录下） 然后修改根目录下的代理，改为dist文件夹所在位置 修改配置文件夹后，切记一定要重新加载Nginx，让其重新加载配置文件，否则你就会一直报错 注意：修改完配置文件后，一定要记得将配置文件中的pid注释去掉，否则重新加载配置文件的时候就会报错，找不到pid文件 如果出现了报错就去配置文件中去除该注释，然后再次重新运行Nginx即可 如果不放心，可以使用命令行去查看进程号，出现这个就代表Nginx启动成功了 前端部署起来后就可以开始部署后端了 使用命令nohup java -jar ruoyi.jar \u0026 直接运行jar包使用后台运行的方式 但是现在前后端都运行起来了，但是没有对接起来，出现如图所示情况 所以，我们就得去nginx中的配置文件进行配置请求路径，将它的请求路径转到后端上，与之对应 location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://121.89.242.18:8081/; } 由于我部署的服务器部署到最后的时候前端连接后端一直超时，没有找到解决问题的原因，所以我暂时放置在这一步了 后续想法：搭载两台虚拟机进行再次搭建 ","date":"2021-07-04","objectID":"/mutinodelinux/:4:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["SQL常见问题"],"content":"SQL常见问题","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["SQL常见问题"],"content":"SQL常见问题 建立新连接时报错：can’t connect to mysql server on ‘localhost’ 原因：是因为本地服务器没开启 解决：用系统管理员打开命令行，输入net start mysql57启动服务器（这里如果是启动8.0服务器就是net start mysql80） 双数据库情况下，在普通命令行不输入密码直接进到mysql下服务器下 先进入mysql安装目录下的bin目录下 再输入mysql -uroot -P 3306 -p命令 直接回车，不需要输入密码 解决数据库建立新连接时报错access denied for user ‘root’@‘localhost’以及mysql命令行工具闪退问题 解决： 到安装的MySQL的目录下，找my.ini文件，在[mysqld]后添加skip-grant-tables，保存退出 在命令行中进入mysql安装目录下的bin目录 输入mysql -uroot -P 3306 -p命令（这里端口号要对应）（作用：使其登录时跳过权限检查） 直接回车，不用输入密码 输入ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 修改密码 报错： flush privileges; 刷新权限 再修改密码ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 成功 参考博客：https://blog.csdn.net/weixin_43589074/article/details/107728819 ","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["Mysql"],"content":"mysql","date":"2021-07-04","objectID":"/mysql/","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1、初始Mysql ","date":"2021-07-04","objectID":"/mysql/:0:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.1、为什么学习数据库 1、岗位技能需求 2、现在的世界,得数据者得天下 3、存储数据的方法 4、程序,网站中,大量数据如何长久保存? 5、数据库是几乎软件体系中最核心的一个存在。 ","date":"2021-07-04","objectID":"/mysql/:1:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.2、什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 保存,并能安全管理数据(如:增删改查等),减少冗余… 数据库总览 : 关系型数据库 ( SQL ) MySQL , Oracle , SQL Server , SQLite , DB2 , … 关系型数据库通过外键关联来建立表与表之间的关系 非关系型数据库 ( NOSQL ) Redis , MongoDB , … 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自 身的属性来决定 ","date":"2021-07-04","objectID":"/mysql/:2:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.3、什么是DBMS 数据库管理系统(DataBase Management System) 数据库管理软件，科学组织和存储数据，高效的获取和维护数据 为社么要说这个呢？ 因为我们要学习的Mysql应该算是一个数据库管理系统 ","date":"2021-07-04","objectID":"/mysql/:3:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.4、MySQL简介 概念：是现在流行的，开源的，免费的，关系型数据库 历史：由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。 特点： 免费，开源数据库 小巧，功能齐全 使用便捷 可运行与Windows或Linux操作系统 可适用于中小型甚至大型网站应用 官网 ","date":"2021-07-04","objectID":"/mysql/:4:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.5、安装MySQL 这里建议大家使用压缩版,安装快,方便.不复杂. 1、软件下载 MySQL5.7 64位下载地址 2、步骤 1、下载后得到zip压缩包 2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19 3、添加环境变量：我的电脑-\u003e属性-\u003e高级-\u003e环境变 选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹 4、编辑 my.ini 文件 ,注意替换路径位置 [mysqld] basedir=D:\\Program Files\\mysql-5.7\\ datadir=D:\\Program Files\\mysql-5.7\\data\\ port=3306 skip-grant-tables 5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install (安装 mysql) 6、再输入mysqld --initialize-insecure --user=mysql初始化数据文件 7、然后再次启动mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空） 8、进入界面后更改root密码 update mysql.user set authentication_string=password('xn123456') where user='root' and Host = 'localhost'; 9、刷新权限 flush privileges; 10、修改 my.ini文件删除最后一句skip-grant-tables 11、重启mysql即可正常使用 net stop mysql net start mysql 12、连接上测试出现以下结果就安装好了 一步步去做 , 理论上是没有任何问题的 . 如果以前装过,现在需要重装,一定要将环境清理干净 . 好了,到这里大家都装好了,因为刚接触,所以我们先不学习命令. 这里给大家推荐一个工具 : SQLyog . 即便有了可视化工具,可是基本的DOS命名大家还是要记住! ","date":"2021-07-04","objectID":"/mysql/:5:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.6、SQLyog 可手动操作,管理MySQL数据库的软件工具 特点 : 简洁 , 易用 , 图形化 使用SQLyog管理工具自己完成以下操作 : 连接本地MySQL数据库 新建MySchool数据库 数据库名称MySchool 新建数据库表(grade) 字段 GradeID : int(11) , Primary Key (pk) GradeName : varchar(50) 在历史记录中可以看到相对应的数据库操作的语句 . ","date":"2021-07-04","objectID":"/mysql/:6:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.7、连接数据库 打开MySQL命令窗口 在DOS命令行窗口进入 安装目录\\mysql\\bin 可设置环境遍历，设置了环境变量，可以在任意目录打开！ 连接数据库语句：mysql -h 服务器主机地址 -u 用户名 -p 用户密码 注意 : -p后面不能加空格,否则会被当做密码的内容,导致登录失败 ! 几个基本的数据库操作命令 update user set password=password('123456')where user='root'; 修改密码 flush privileges; 刷新数据库 show databases; 显示所有数据库 use dbname； 打开某个数据库 show tables; 显示数据库mysql中所有的表 describe user; 显示表mysql数据库中user表的列信息 create database name; 创建数据库 use databasename; 选择数据库 exit; 退出Mysql ? 命令关键词 : 寻求帮助 -- 表示注释 2、操作数据库 ","date":"2021-07-04","objectID":"/mysql/:7:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.1、结构化查询语句分类 ","date":"2021-07-04","objectID":"/mysql/:8:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.2、数据库操作 命令行操作数据库 创建数据库 :create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 对比工具操作数据库 学习方法： 对照SQLyog工具自动生成的语句学习 固定语法中的单词需要记忆 ","date":"2021-07-04","objectID":"/mysql/:9:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.3、创建数据表 属于DDL的一种语法： create table [if not exists] `表名`( '字段名1' 列类型 [属性][索引][注释], '字段名2' 列类型 [属性][索引][注释], #... '字段名n' 列类型 [属性][索引][注释] )[表类型][表字符集][注释]; 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键) ","date":"2021-07-04","objectID":"/mysql/:10:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.4、数据值和列类型 列类型：规定数据库中该列存放的数据类型 数值类型 字符串类型 日期和时间型数值类型 NULL值 理解为\"没有值\"或\"未知值\" 不要用NULL进行算术运算，结果仍为NULL ","date":"2021-07-04","objectID":"/mysql/:11:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.5、数据字段属性 UnSigned 无符号的 声明该数据列不允许负数 . ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如,性别字段,默认为\"男\" , 否则为 “女” ; 若无指定该列的值 , 则默认值为\"男\"的值 -- 目标 : 创建一个school数据库 -- 创建学生表(列,字段) -- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住 址,email -- 创建表之前 , 一定要先选择数据库 CREATE TABLE IF NOT EXISTS `student` ( `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` datetime DEFAULT NULL COMMENT '生日', `address` varchar(100) DEFAULT NULL COMMENT '地址', `email` varchar(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 -- 查看数据库的定义 SHOW CREATE DATABASE school; -- 查看数据表的定义 SHOW CREATE TABLE student; -- 显示表结构 DESC student; -- 设置严格检查模式(不能容错了) SET sql_mode='STRICT_TRANS_TABLES'; ","date":"2021-07-04","objectID":"/mysql/:12:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.6、数据表的类型 设置数据表的类型 CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释 )ENGINE = MyISAM (or InnoDB) -- 查看mysql所支持的引擎类型 (表类型) SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型： 经验(使用场合)： 使用M有ISAM：节约空间及相应速度 使用InnoDB：安全性，事务性及多用户操作数据表 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件，数据文件，以及数据库的选项文件 位置：Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 注意： InnoDB类型数据表只有一个*.frm文件，以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件： *.frm –表结构定义文件 *.MYD –数据文件(data) *.MYI –索引文件(index) 设置数据表字符集 我们可谓护具看，数据表，数据列设置不同的字符集，设定方法； 创建时通过命令来设置，如：CREATE TABLE 表名()CHARSET = utf8; 如果没有设置，则根据MySQL数据库配置文件my.ini中的参数设定 ","date":"2021-07-04","objectID":"/mysql/:13:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.7、修改数据库 修改表（ALTER ＴABLE） 修改表名：ALTER TABLE 旧表名 RENAME AS 新表名 添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性] 修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性] ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] 删除字段 : ALTER TABLE 表名 DROP 字段名 删除数据表 语法： DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 其它 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\' 5. CMD命令行内的语句结束符可以为 \";\", \"\\G\", \"\\g\"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 （关键字） 7. 清除已有语句：\\c ","date":"2021-07-04","objectID":"/mysql/:14:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mybatis"],"content":"mybatis","date":"2021-07-04","objectID":"/mybatis/","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1、简介 ","date":"2021-07-04","objectID":"/mybatis/:0:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.1、什么是Mybatis ","date":"2021-07-04","objectID":"/mybatis/:1:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.2、持久化（持久化是一个动作） 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（jdbc），io文件持久化。 为什么需要持久化有一些对象，不能让他丢掉。用时再取 对象：如支付宝里面的钱不能丢失以及页面的一些信息 因为内存有一个特点是断电即失 另外一个原因也是内存太贵（外在原因） ","date":"2021-07-04","objectID":"/mybatis/:2:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.3、持久层（是一个概念） Dao层，Service层，Controller层…等每一个层都有它们自己要做的事情 完成持久化工作的代码块 层是界限十分明显 ","date":"2021-07-04","objectID":"/mybatis/:3:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.4、为什么需要Mybatis 帮助程序员将数据存入到数据库中 方便 传统的JDBC代码太复杂了。所以将其简化，出现一个框架 不用Mybatis也可以。更容易上手。 2、第一个Mybatis程序 思路：搭建环境–\u003e导入Mybatis–\u003e编写代码–\u003e测试！ ","date":"2021-07-04","objectID":"/mybatis/:4:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.1、搭建环境 CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, # 设置id，并设为主键且不为空 `name` VARCHAR(30) DEFAULT NULL, # 设置名字，默认为空 `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; # 设置引擎为INNODB 默认字符集为utf8 INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'科比','123456'), (2,'哈登','123456'), (3,'威少','123456') 新建项目 1.新建一个普通的maven项目 2.删除src目录 3.导入maven依赖 \u003cdependencies\u003e \u003c!--mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-07-04","objectID":"/mybatis/:5:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.2、创建一个模块 编写mybatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003c!--此处的\u0026amp;相当于yml里面的\u0026\u0026,只是在xml文件中得进行转化--\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 编写mybatis工具类 package com.kuang.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { //提升作用域 private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } ","date":"2021-07-04","objectID":"/mybatis/:6:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.3、编写代码 实体类 package com.kuang.pojo; //实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } Dao接口 public interface UserDao { List\u003cUser\u003e getUserList(); } 接口实现类（由原来的Use人DaoImpl转变为一个Mapper配置文件） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace等于绑定一个对于的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.kuang.dao.UserDao\"\u003e \u003c!--select查询语句 id对应的是我们的方法名字--\u003e \u003cselect id=\"getUserList\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e 注意点：在使用resultType返回结果时，返回集合中的泛型，不要写集合 ","date":"2021-07-04","objectID":"/mybatis/:7:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.4、测试 注意点：org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册mappers \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e junit测试 package com.kuang.dao; import com.kuang.pojo.User; import com.kuang.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserDaoTest { @Test public void test(){ //第一步：活得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List\u003cUser\u003e userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlsession sqlSession.close(); } } 官网推荐的是我们将close放入finally中，自己手动添加一个try-catch语句 可能遇到的问题： 配置文件没有注册 绑定接口错误 namespace绑定问题 方法名不对 返回类型不对 resulttype返回类型 Maven导出资源问题 思路： 导入最基本需要的依赖包 创建一个工具类，构建SqlSessionFactory 编写核心配置文件 连接数据库，修改里面的属性 写完实体类后写接口，最后写实体类，用mapper.xml代替了原来的Impl 每次收到的HTTP请求（也就是连接我们的数据库），就可以打开一个SqlSession，返回一个响应，就关闭它。 3、CRUD ","date":"2021-07-04","objectID":"/mybatis/:8:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.1、namespace namespace中的包名要和Dao/mapper接口的包名一致！ ","date":"2021-07-04","objectID":"/mybatis/:9:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.2、select 选择，查询语句 id：就是对应的namespace中的方法名 resultType：SQL语句执行的返回值 parameterType：参数类型！ 1.编写接口 //根据ID查询用户 User getUserById(int id); 2.编写对应的mapper中的sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e 3.测试 public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); //关闭sqlsession sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:10:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.3、Insert \u003c!--对象中的属性可以直接提取出来--\u003e \u003cinsert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"\u003e insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e ","date":"2021-07-04","objectID":"/mybatis/:11:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.4、Update \u003cupdate id=\"updateUser\" parameterType=\"com.kuang.pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2021-07-04","objectID":"/mybatis/:12:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.5、delete \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id}; \u003c/delete\u003e 注意点： 增删改需要提交事务，否则添加不进去（代码执行没问题，数据库里面不显示） resource绑定mapper，需要使用路径 ","date":"2021-07-04","objectID":"/mybatis/:13:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.6、万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ Map传递参数，直接在sql中取出即可！【parameterType=“Map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ ","date":"2021-07-04","objectID":"/mybatis/:14:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.7、思考题 模糊查询 ​ 1.Java代码执行的时候，传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%李%\"); ​ 2.在sql拼接中使用通配符！ select * from mybatis.user where name like \"%\"#{value}\"%\" 4、配置解析 ","date":"2021-07-04","objectID":"/mybatis/:15:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-07-04","objectID":"/mybatis/:16:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.2、环境配置（environment） Mybatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 transactionManager：事务管理器，分为JDBC与MANAGED dataSource：数据源，分为UNPOOLED、POOLED、JNDI；最重要的概念就是：池：拥有回收机制，即下次可以继续执行 Mybatis默认的事务管理器就是JDBC，连接池：POOLED ","date":"2021-07-04","objectID":"/mybatis/:17:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】 编写一个配置文件：db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026userUnicode=true\u0026characterEncoding=UTF-8 username=root password=xn123456 在核心配置文件中引入 \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ ","date":"2021-07-04","objectID":"/mybatis/:18:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名，Mybatis会在包名下面搜索需要的Java Bean 扫描实体类的包，它的默认别名就为这个类的类名首字母小写 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e 在实体类比较少的时候，使用第一种方式 如果实体类十分多，建议使用第二种 第一种可以DIY别名，第二种则不行，如果非要使用别名，需要在实体类上增加注解，在实体类上注解的同时，也需要在核心配置文件中扫描指定的包。 @Alias(\"user\") public class User { ","date":"2021-07-04","objectID":"/mybatis/:19:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.5、设置 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 ","date":"2021-07-04","objectID":"/mybatis/:20:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.6、其它配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件] mybatis-generator-core mybatis-plus 通用mapper ","date":"2021-07-04","objectID":"/mybatis/:21:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.7、映射器（mappers） MapperRegistry：绑定注册我们的Mapper文件 方式一：【推荐使用】 \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/UserMapper.xml\"/\u003e \u003c/mappers\u003e 方式二：使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 \u003cmappers\u003e \u003cmapper package=\"com.kuang.dao\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ ","date":"2021-07-04","objectID":"/mybatis/:22:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.8、生命周期和作用域 生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 它是一个局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 因此SqlSessionFactory的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。使其保证全局唯一 SqlSession： 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题 ","date":"2021-07-04","objectID":"/mybatis/:23:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.1、问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } // select * from mybatis.user where id = #{id} //类型处理器 // select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select id,name,pwd as password from mybatis.user where id = #{id} \u003c/select\u003e ","date":"2021-07-04","objectID":"/mybatis/:24:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.2、resultMap 结果集映射 \u003c!--结果集映射：id就是你下面resultMap的值；type就是结果集要映射成谁就是什么类型--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\" \u003e select * from mybatis.user where id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本iju不需要显示地用到它们。 6、日志 ","date":"2021-07-04","objectID":"/mybatis/:25:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.1、日志工厂 如果一个数据库操作，出现了异常。日志就是最好的助手 曾经：sout、debug 现在：日志工厂！ SLF4J LOG4J LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 注意：使用标准日志输出时，出现报错：1、value后面的值又空格，切记！ 在mybatis核心配置文件中，配置我们的日志 \u003csettings\u003e \u003c--标准的日志工厂实现--\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c/settings\u003e ","date":"2021-07-04","objectID":"/mybatis/:26:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.2、Log4j 什么是log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 先导入log4j的包 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e kog4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PrepareStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e Log4j的使用，直接测试运行刚才的查询 [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VFS [org.apache.ibatis.io.JBoss6VFS]-JBoss 6 VFS API is not available in this environment. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VirtualFile [org.apache.ibatis.io.VFS]-VFS implementation org.apache.ibatis.io.JBoss6VFS is not valid in this environment. [org.apache.ibatis.io.VFS]-Using VFS adapter org.apache.ibatis.io.DefaultVFS [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Reader entry: User.class [org.apache.ibatis.io.DefaultVFS]-Listing file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Reader entry: ���� 4 @ [org.apache.ibatis.io.ResolverUtil]-Checking to see if class com.kuang.pojo.User matches criteria [is assignable to Object] [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection [org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 2044903525. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79e2c065] [com.kuang.dao.UserMapper.getUserList]-==\u003e Preparing: select * from mybatis.user [com.kuang.dao.UserMapper.getUserList]-==\u003e Parameters: [com.kuang.dao.UserMapper.getUserList]-\u003c== Total: 3 User{id=1, name='科比', pwd='123456'} User{id=2, name='哈登', pwd='123456'} User{id=3, name='威少', pwd='123456'} [org.apache.ibatis.tran","date":"2021-07-04","objectID":"/mybatis/:27:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.1、使用Limit 分页 语法： SELECT * from user limit startIndex,pageSize; startIndex:起始的位置，按数组下标开始进行分页 pageSize:每一页的数量 SELECT * from user limit 3; #类似于[0,n] 使用Mybatis实现分页，核心就是SQL 接口 //分页 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003emap); Mapper.xml \u003cselect id=\"getUserByLimit\" parameterType=\"map\" resultType=\"user\"\u003e select * from mybatis.user limit #{startIndex},#{pageSize}; \u003c/select\u003e 如果此处的pwd没有改成password，则不需要进行结果集映射，如果改了，则需要进行结果集映射，就不能使用resultType，则需要使用resultMap 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:28:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.2、RowBounds分页 不再使用sql实现分页 接口 //分页2 List\u003cUser\u003e getUserByRowBounds(); mapper.xml \u003cselect id=\"getUserByRowBounds\" resultType=\"user\"\u003e select * from mybatis.user; \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //通过RowBounds实现分页 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:29:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.3、分页插件 了解即可，==Mybatis PageHelper== 8、使用注解开发 ","date":"2021-07-04","objectID":"/mybatis/:30:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.1、面向接口编程 ","date":"2021-07-04","objectID":"/mybatis/:31:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.2、使用注解开发 注解直接在接口上实现 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); } 需要在核心配置文件中绑定接口！ \u003c!--绑定接口--\u003e \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 测试使用 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //底层主要应用反射 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUsers(); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 本质：反射机制实现 底层：动态代理！ ","date":"2021-07-04","objectID":"/mybatis/:32:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.3、注解的CRUD 我们可以在工具类创建的时候自动提交事务 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口，增加注解 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); //@Param方法存在多个参数，所有的参数前面必须加上@Param(\"id\")注解 @Select(\"select * from user where id = #{id}\") User getUserById(@Param(\"id\") int id); @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{pwd})\") int addUser(User user); @Update(\"update user set name=#{name},pwd=#{pwd} where id = #{id}\") int updateUser(User user); @Delete(\"delete from user where id = #{uid}\") int deleteUser(@Param(\"uid\") int id); } 注意：我们必须要将接口注册绑定到我们的核心配置文件中 使用Param注解时，里面对应的基本类型应当与sql语句中的类型一致，否则报错 关于@Param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上去 我们在SQL中引用的就是我们这里的@Param()中设置的属性名 9、Lombok 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入Lombok的ｊａｒ包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 这是一款懒人插件，虽然简化了许多，但是却对新手造成了困惑，不容易去阅读源码了；对于这种插件，合理的利用才是关键 说明： ＠Data：无参构造，get、set、toString、hashcode、equals @AllArgsConstructor：有参构造 @NoArgsConstructor：无参构造 10、多对一处理 多对一: 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 【多对一】 对于老师这边而言，集合…一个老师，有很多学生 【一对多】 SQL： CREATE TABLE `teacher`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY(`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`,`name`) VALUES (1,'秦老师'); CREATE TABLE `student`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY(`id`), KEY `fktid`(`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('1','小明','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('2','小红','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('3','小张','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('4','小李','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('5','小王','1'); 实体类： public class Student { private int id; private String name; //关联老师 private Teacher teacher; } public class Teacher { private int id; private String name; } ","date":"2021-07-04","objectID":"/mybatis/:33:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.1、按照查询嵌套处理 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.StudentMapper\"\u003e \u003c!--思路： 1.查询所有的学生信息 2.根据查询出来的学生的tid，寻找对应的那个老师 --\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性，我们需要单独处理，如果属性是对象，我们采用association，如果属性是集合，我们采用collection javaType是因为属性为对象，所以得给其设置一个类型，select作用是通过column中的字段要来进行什么操作 javaType=\"\" 指定属性的类型 集合中的泛型信息，我们使用ofType获取 --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher; \u003c/select\u003e \u003c/mapper\u003e 相当于是子查询，先查询出所有的学生，在通过查询出来的结果再进行一次查询。如下这种形式 select id,name,name from student where tid=(select .......); ","date":"2021-07-04","objectID":"/mybatis/:34:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.2、按照结果嵌套处理 \u003c--s.id sid相当于给其起一个别名，也就相当于数据库里面的id变成了sid--\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003c--这里是直接根据结果来返回结果的类型，再来嵌套进行查找；即相当于从结果入手，反向查询--\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 回顾M以上情况多对一查询方式： 子查询 联表查询（即第二种方法） 11、一对多 比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系 实体类： @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List\u003cStudent\u003e students; } public class Student { private int id; private String name; private int tid; } ","date":"2021-07-04","objectID":"/mybatis/:35:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.1、按照结果嵌套查询（推荐） \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname ,t.name tname ,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--集合中的泛型信息，我们使用ofType获取 这里取出来的是每一个值，取出每一个值所对应的，所以我们采用ofType--\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 注意点：一对多，对于按结果查询使用collection时，如果是取出的一个个值，则 需使用ofType来指定其类型，而不使用JavaType 而对于按查询嵌套使用collection时，我们取出的是一个集合，而不是一个个值，则需要使用JavaType来指定属性的对象类型，同时还得将泛型的信息使用ofType写上 ","date":"2021-07-04","objectID":"/mybatis/:36:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.2、按照查询嵌套处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from Teacher where id=#{tid}; \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003c--这里是相同属性名的话可以省略不用写--\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--这里所取出来的值就是一个集合，所以得写上其JavaType的类型，也就是集合的对象类型，并且里面的泛型信息也得写上--\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudent\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent\" resultType=\"Student\"\u003e \u003c--这个地方的#{id}中的id可以随意填，因为mybatis会自动去匹配，但是为了规范还是正规写--\u003e select * from Student where tid=#{id}; \u003c/select\u003e ","date":"2021-07-04","objectID":"/mybatis/:37:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.3、小结 1. 关联--assocation 【多对一】 2. 集合--collection 【一对多】 3. JavaType \u0026\u0026 ofType 1. Java Type 用来指定实体类中属性的类型 2. ofType 用来指定映射到List或者集合中的pojo类型，即泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题 如果问题不好排查错误，可以使用日志，建议使用Log4j 12、动态SQL 什么是动态SQL：动态SQL就是根据不同的条件生成不同的语句 ","date":"2021-07-04","objectID":"/mybatis/:38:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.1、搭建环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` VARCHAR(100) NOT NULL COMMENT '博客标题', `author` VARCHAR(30) NOT NULL COMMENT '博客作者', `create_time` DATETIME NOT NULL COMMENT '创建时间', `views` INT(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 创建一个基础工程 导包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c!--是否开启驼峰命名自动映射--\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 编写实体类 @Data public class Blog { private String id; private String title; private String author; private Date createTime;//属性名和字段名不一致，可以开启Setting中的驼峰命名规则 private int views; } 编写实体类对应Mapper接口和Mapper.xml文件 public interface BlogMapper { //插入数据 int addBlog(Blog blog); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.BlogMapper\"\u003e \u003cinsert id=\"addBlog\" parameterType=\"blog\"\u003e insert into mybatis.blog (id,title,author,create_time,views) values (#{id},#{title},#{author},#{createTime},#{views}); \u003c/insert\u003e \u003c/mapper\u003e 测试 @Test public void addBlogTest() { SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getId()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:39:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.2、IF \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/select\u003e @Test public void queryBlogif(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); //map.put(\"title\",\"Mybatis\"); map.put(\"author\",\"狂神说\"); List\u003cBlog\u003e blogList = mapper.queryBlogIf(map); for (Blog blog : blogList) { System.out.println(blog) ; } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:40:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.3、choose（when,otherwise） \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title=#{title} \u003c/when\u003e \u003cwhen test=\"author != null\"\u003e and author=#{author} \u003c/when\u003e \u003cotherwise\u003e and views=#{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e **注意点：**使用where的时候，当条件成立的时候where会自动去除and或者or 使用choose时，当条件成立时，只会选择一个语句进行执行，其它语句则不执行，当所有语句都不成立时，则会使用otherwise中的语句；类似与switch-case，执行一个case后面有break，执行完就跳出 ","date":"2021-07-04","objectID":"/mybatis/:41:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.4、trim(where，set) \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e \u003cupdate id=\"updateBlog\" parameterType=\"map\"\u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title=#{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author=#{author} \u003c/if\u003e \u003c/set\u003e where id =#{id} \u003c/update\u003e set元素会动态前置SET关键字，同时也会删掉无关的逗号 所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 ","date":"2021-07-04","objectID":"/mybatis/:42:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.5、SQL片段 有时候，我们可能会将一些功能的部分抽取出来，方便复用 使用SQL标签抽取公共的部分 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项： 最好基于单表来定义SQL片段（如果是多表查询会让其效率变低，公共部分的拼接就会很复杂） 不要存在where标签 ","date":"2021-07-04","objectID":"/mybatis/:43:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.6、Foreach \u003c!-- 这个地方我们在使用foreach时，是遍历的一个集合，而我们传递的参数为map，所有我们的map中可以存在一个集合 item：从集合中遍历出来的值,也就是传到#{}中的值 separator：中间的分隔符 --\u003e \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"\u003e id=#{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 13、缓存（了解） ","date":"2021-07-04","objectID":"/mybatis/:44:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.1、简介 查询---\u003e连接数据库，耗资源 一次查询的结果，给它暂存到一个可以直接取值的地方！--\u003e内存：缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存 经常查询并且不经常改变的数据【可以使用缓存】 不经常查询并且经常改变的数据【不可以使用缓存】 ","date":"2021-07-04","objectID":"/mybatis/:45:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存。缓存可以极大的提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定于了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-07-04","objectID":"/mybatis/:46:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.3、一级缓存 一级缓存也叫本地缓存：SqlSession就是一个一级缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Sqlsession中查询两次相同的记录 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); System.out.println(\"================\"); User user1 = mapper.queryUserById(1); System.out.println(user1); System.out.println(user==user1); sqlSession.close(); } 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 小结：一级缓存默认是开启的，只在一次Sqlsession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个map ","date":"2021-07-04","objectID":"/mybatis/:47:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会存放在自己对应的缓存（map）中 步骤： 开启全局缓存 \u003c!--开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在要使用二级缓存的Mapper中开启 \u003c!--开启二级缓存--\u003e \u003ccache/\u003e 也可以自定义参数 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题：当我们没有设置策略时，我们需要将实体类实例化！否则就会报错 Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ ","date":"2021-07-04","objectID":"/mybatis/:48:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.5、缓存原理 缓存顺序： 先看二级缓存中有没有 再看一级缓存中有没有 两个都没有，再去查数据库 ","date":"2021-07-04","objectID":"/mybatis/:49:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.6、自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用Ehcache步骤 先导包 \u003c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.caches\u003c/groupId\u003e \u003cartifactId\u003emybatis-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.2.1\u003c/version\u003e \u003c/dependency\u003e 在mapper中指定使用我们的ahcache缓存实现 \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/\u003e ehcache.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"\u003e \u003cdiskStore path=\"./tmpdir/Tmp_EhCache\"/\u003e \u003cdefaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003ccache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003c/ehcache\u003e ","date":"2021-07-04","objectID":"/mybatis/:50:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Linux"],"content":"linux","date":"2021-07-04","objectID":"/linux/","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Linux 基本使用 /bin: bin是Binary的缩写，这个目录存放着最经常使用的命令。 /boot: 这里存放的是启动Linux是使用的一些核心文件，包括一些连接文件以及镜像文件。 (不要动) /dev：dev是Device（设备）的缩写，存放的是Linux的外部设备，在Linux中访问设备的方式和文件的方式是相同的。 ==/etc==：这个目录用来存放所有的系统管理所需要的配置文件和子目录。重要 ==/home==：用户的主目录，在Linux中，每个用户都拥有一个自己的目录，一般该目录是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接库，其与Windows里的DLL文件 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（不要动，存放一些突然关机文件） /media：Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂在到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统，我们看将光驱挂载在/mnt上，然后进入该目录就可以查看光驱里面的内容了。 ==/opt==：这是给主机额外安装软件所摆放的目录。比如你安装有一个Oracle数据库，则就可以用放在这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统的信息。（不用管） /root：该目录为系统管理员，也称作超级权限这的与用户主目录。 /sbin：s就是Super User的isi，这里存放的就是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是Linux2.6内核的有一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。 /tmp：这个目录用来存放一些临时文件的。（用完即丢的文件可以放在这个目录下） ==/usr==：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下。类似与Windows下的progra files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。Super /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统同启动以来的信息。当系统重启时，这个目录下的文件一个被删掉或者清除。 Linux常用的基本命令 ","date":"2021-07-04","objectID":"/linux/:0:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"目录管理 绝对路径、相对路径 绝对路径的全称：F:\\deskBackground\\xxxx cd：切换目录命令 ./：当前目录 cd ..：退回到上一级目录 ls（列出目录） 在Linux中ls可能时最常常被使用的！ -a 参数：all，查看全部的文件，包括隐藏的文件 -l 参数：列出所有的文件，包含文件的属性和权限，没有隐藏文件 所有的Linux可以组合使用。 cd命令 切换目录 cd 目录命令（绝对路径都是以/开头，相对路径，对于当前目录该如何寻找../../） pwd显示当前用户所在的目录 mkdir 创建一个目录 白色代表文件。蓝色代表文件夹 创建一个层级目录， 要加入一个 -p rmdir 删除目录 如果要删除一个层级目录，则也需要加入一个参数 -p rmdir仅仅只能删除空的目录，如果下面存在文件，需要先删除文件，递归删除多个目录加入-p参数即可 如果删除文件夹中的内容，可以采用 rm -f 强制删除 \\-r 向下递归，不管有多少级目录，一并删除。 \\-f 直接强行删除，没有任何提示。 cp （复制文件或者目录） cp 原来的地方 新的地方 如果是重复复制一个文件会产生覆盖现象，它会提示你是否覆盖。 rm （移出文件或者目录） -f 忽略不存在的文件，不会出现警告，强制删除！ -r 递归删除目录！ -i 互动，删除询问是否删除 rm -f / 系统中所有的文件就被删除了，删库跑路就是这么操作的！ mv 移动文件或者目录！ 重命名文件 -f 强制移动 -u 只替换已经更新过的文件 ","date":"2021-07-04","objectID":"/linux/:1:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用\"d\"表示。“d\"在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： ==当为[ d ]则是目录== ==当为[ - ]则是文件；== ==若是[ l ]则表示为链接文档 ( link file )；==如Windows系统中应用的快捷方式 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，\\[ r \\]代表可读(read)、\\[ w \\]代表可写(write)、\\[ x \\]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号\\[ - \\]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用\"r\"字符表示，则有读权限，如果用\"-\"字符表示，则没有读权限； 第2、5、8位表示写权限，如果用\"w\"字符表示，则有写权限，如果用\"-\"字符表示没有写权限； 第3、6、9位表示可执行权限，如果用\"x\"字符表示，则有执行权限，如果用\"-\"字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 属主：表示属于哪一个主人 属组：表示属于哪一个组 chgrp \\[-R\\] 属组名 文件名 \\ -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown \\[–R\\] 属主名 文件名 chown \\[-R\\] 属主名：属组名 文件名 3、chmod：更改文件9个属性 ==（必须掌握）== chmod \\[-R\\] xyz 文件或目 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： - owner = rwx = 4+2+1 = 7 - group = rwx = 4+2+1 = 7 - others= --- = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ ","date":"2021-07-04","objectID":"/linux/:2:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"文件内容查看 Linux系统中使用以下命令来查看文件内容 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出tac 是 cat 的倒着写 nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容==按空格进行下翻页，enter代表像下一行看，:f查看行号== less 与 more 类似，但是比more 更好的是，它可以往前翻页！==按空格进行下翻页，上下键代表翻动页面，退出使用q命令，查找字符串 /要查找的字符串 向下查询；向上查询使用？要查询的字符串 ；n 继续搜寻下一个，N 向上寻找== head 只看头几行 ==它通过-n 参数来控制显示几行 tail 只看尾巴几行 ==也是通过-n参数来控制看那几行 可以使用man[命令]来查看各个命令的使用文档，如：man cp 网络配置目录：cd /etc/sysconfig/network-scripts/ 默认网络配置文件： Linux链接的概念（了解即可） Linux的链接分为两种：硬链接、软连接！ 硬链接：A—B，假设B是A的硬链接，那么他们两个指向了同一个文件！允许一个文件拥有多个路径，用户可通过这种机制建议硬链接到一些重要文件上，防止误删。 软链接：类似Windows下的快捷方式，删除了原文件，快捷方式也访问不了！ 创建链接 ln 命令 touch 命令创建文件 echo 输入字符串 [root@iZ8vb8plggk0dqs0rr5kzfZ /]# cd home [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 ln: failed to access ‘f1’: No such file or directory [root@iZ8vb8plggk0dqs0rr5kzfZ home]# touch f1 # 创建一个f1文件 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 f2 # 创建一个硬链接 f2 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln -s f1 f3 # 创建一个软链接 f3 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ll total 4 -rw-r--r-- 2 root root 0 May 25 20:49 f1 -rw-r--r-- 2 root root 0 May 25 20:49 f2 lrwxrwxrwx 1 root root 2 May 25 20:49 f3 -\u003e f1 drwx------ 3 www www 4096 May 9 17:03 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# echo \"yeziqi hanhan\" \u003e\u003e f1 # 给f1文件中写入一些字符串！ [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f1 # 查看f1 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 # 查看f2 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 # 查看f3 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# 删除f1之后，查看f2和f3的区别 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# rm -rf f1 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 #f2硬链接还在 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 #f3（软链接、符号链接失效）快捷方式失效 cat: f3: No such file or directory ","date":"2021-07-04","objectID":"/linux/:3:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Vim编辑器 vim通过一些插件可以实现和IDE一样的功能！ 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式！ESC！ 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： Vim按键说明 除了上面简易示范的 i ，Esc ， :wq 之外，其实vim还有非常多的按键可以使用 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键==(常用)== [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 ==(常用)== [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 数字\u003c space\u003e 那个 n 表示『数字』，例如 20 。快捷切换光标 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 ==(常用)== $ 或功能键[End] 移动到这一行的最后面字符处==(常用)== H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行==(常用)== nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！==常用)== 数字\u003c Enter\u003e 光标向下移动 n 行==(常用)== 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) ==(常用)== nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行==(常用)== ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 ==(常用)== d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行==(常用)== nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行==(常用)== y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p,P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。==(常用)== J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。==(常用)== [Ctrl]+r 重做上一个动作。==(常用)== 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i,I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。==(常用)== a,A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。==(常用)== o,O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！==(常用)== r,R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；==(常用)== [Esc] 退出编辑模式，回到一般模式中==(常用)== 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中==(常用)== :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi ==(常用)== :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 ==(常用)== ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 以上标绿的是要熟练掌握的，其余的做了解即可！ ","date":"2021-07-04","objectID":"/linux/:4:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"账号管理 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 useradd 命令 添加用户 useradd -选项 用户名 -m：自动创建这个用户的主目录–\u003e /home/用户名 参数说明： 选项 : \\-c comment 指定一段注释性描述。 \\-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 \\-g 用户组 指定用户所属的用户组。 \\-G 用户组，用户组 指定用户所属的附加组。 \\-m　使用者目录如不存在则自动建立。 \\-s Shell文件 指定用户的登录Shell。 \\-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# useradd -m wei [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls wei www 理解一下本质：Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户信息了！/etc/passwd 删除用户 userdel userdel -r wei 删除用户的时候将他的目录页一并删掉！ 修改用户 usermod 修改用户 usermod 对应修改的内容 修改的用户 usermod -d /home/test wei 在进行修改某一个用户时，也要修改其文件的时候，应当先创建要移动到的文件，否则可能当前目录不显示移动后的文件，但是在配置文件中是存在的！ ​ Linux 下如何切换用户 root用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 与用户的密码设置问题 我们一般它通过root创建用户的时候！要配置密码 Linux上输入密码时不会显示的，正常输入即可！ 在公司中，一般拿不到公司服务器的root权限，都是有一些分配的账号！ 锁定账户 root一旦冻结这个账号，这个人就登录不上系统了！ passwd -l wei #锁定之后这个用户也就不能登录了 passwd -d wei #没有密码也不能登录 ","date":"2021-07-04","objectID":"/linux/:5:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"用户组管理 属主（属于那一个主人）、属组 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发、测试、运维、root）。不同Linux 系统对用户 组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。==组的增加、删除和修改实际上就是对/etc/group文件的更新。 创建一个用户组 groupadd wei 创建完用户组后可以得到一个Id，这个Id是可以指定的！-g 520 如果不指定就是自增1 用户如果要切换用户组怎么办呢？ # 登录当前用户 wei $ newgrp root 这样转换的前提是你得需要有这个权限，否则切换不成功！ 删除用户组 groupdel groupdel wei 修改与用户组的权限信息和名字 groupmod -g：修改端口号 -n：修改用户名字 拓展；文件的查看！（了解即可） /etc/passwd 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 这个文件中的灭有一行都代表这一个用户，我们可以用从这里看出这个用户的主目录在哪里，可以看到属于哪一个组！ 登录口令：把真正的加密后的用户口令字存放到/etc/shadow文件中 用户组的所有信息都存放在/etc/group文件中 ","date":"2021-07-04","objectID":"/linux/:6:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"磁盘管理 df （列出文件系统整体的磁盘使用量） du（检查磁盘空间的使用量） df du Mac或者想要使用Linux挂载我们的ixie本地磁盘或者文件！ 挂载：使用mount命令 卸载：unmount -f [挂载位置] 强制卸载 ","date":"2021-07-04","objectID":"/linux/:7:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"进程管理 Linux中一切皆文件 ==(文件: 读、写、执行（查看，创建，删除，移动，复制，编辑），权限（用户，用户组），系统（磁盘，进程））== 什么是进程（基本概念） 在Linux中，每一个进程都是有自己的一个进程，每一个进程都有一个id号 每一个进程，都有一个父进程 进程可以拥有两种方式存在：前台！后台运行 一般的话服务都是后台运行的，基本的程序都是前台运行的！ 命令 ps 查看当前系统中正在执行的各种进程信息 ps -xxx: a 显示当前终端运行的所有进程信息(当前的进程是一个) u 以用户的信息显示进程 x 显示后台运行进程的参数! ps -aux 查看所有的进程 ps -aux |grep mysql # | 在Linux中这个叫做管道符 # grep 查找文件中符合条件的字符串(相当于过滤) 对于我们来说, 这里目前只需要记住一个命令即可 ps -xx|grep 进程名字!过滤进程信息! ps -ef: 可以查看到父进程的信息 ps -ef|grep mysql # 看父进程我们一般可以通过目录树结构来查看！ # 进程树 pstree -pu -p 显示父id -u 显示用户组 结束进程： 杀掉进程，等价与Windows结束任务 kill -9 进程的id kill -9 进程的id 表示强制结束进程 ","date":"2021-07-04","objectID":"/linux/:8:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"环境安装 安装软件有一般有三种方式： rpm（Jdk：在线发布一个SpringBoot项目） 解压缩（tomcat，启动并通过外网访问，也就是发布网站） yum在线安装（docker：直接运行跑起来docker就可以！） ","date":"2021-07-04","objectID":"/linux/:9:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"JDK安装 下载JDK rpm。去Oracle官网下载即可！ 安装Java环境 # 检测当前系统是否存在Java环境！ Java -version # 如果有的话就需要先卸载 # rpm -qa|grep jdk # 检测JDK版本信息 # rpm -e --nodeps jdk所在文件夹 # --nodeps 代表强制删除 # 卸载完毕后即可安装JDK # rpm -ivh rpm包 # 配置环境变量 配置环境变量：etc/profile在文件的最后面增加Java的配置和Windows安装环境变量一样 JAVA_HOME=/usr/java/jdk # Java根路径 CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib # 类路径文件 PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin # 环境变量文件 export PATH CLASSPATH JAVA_HOME 让这个配置文件生效！source /etc/profile 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 ","date":"2021-07-04","objectID":"/linux/:9:1","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Tomcat安装 安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 将文件移动到/usr/tomcat/下，并解压！ root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz /usr [root@kuangshen kuangshen]# cd /usr [root@kuangshen usr]# ls apache-tomcat-9.0.22.tar.gz [root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --\u003e启动tomcat # 执行：shutdown.sh --\u003e关闭tomcat ./startup.sh ./shutdown.sh 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 域名解析完毕后，如果端口是80 -http或者443 -https，可以直接访问，如果是9000 8080，就需要通过Apache或者Nginx做一下反向代理即可，配置文件即可。 ","date":"2021-07-04","objectID":"/linux/:9:2","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["JavaWeb"],"content":"javaweb","date":"2021-07-04","objectID":"/javaweb/","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、基本概念 ","date":"2021-07-04","objectID":"/javaweb/:0:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.1、静态web 静态web存在的缺点 web页面无法更新 它无法和数据库交互（数据无法持久化，用户无法交互） ","date":"2021-07-04","objectID":"/javaweb/:1:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.2、动态web 页面会动态展示：“web的页面展示的效果因人而异” 动态web存在的缺点： 假如服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布； 动态web的优点： Web页面可以动态更新，所有用户看到的都不是同一个页面 它可以与数据库交互 2、web服务器 ","date":"2021-07-04","objectID":"/javaweb/:2:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.1、技术讲解 PHP： PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大量访问的情况 JSP/Servlet： B/S：浏览器和服务器 C/S：客户端和服务器 sun公司主推的B/S架构 基于Java语言（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响 高可用 高并发 高性能 语法像ASP ","date":"2021-07-04","objectID":"/javaweb/:3:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.2、web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息 IIS 微软的：ASP…….，Windows中自带的 Tomcat 下载tomcat： 解压 or 安装 了解配置文件以及目录结构 这个东西的作用 3、Tomcat ","date":"2021-07-04","objectID":"/javaweb/:4:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.1、安装Tomcat Tomcat官网 ","date":"2021-07-04","objectID":"/javaweb/:5:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.2、Tomcat启动和配置 文件夹的作用 访问测试：Tomcat测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 ","date":"2021-07-04","objectID":"/javaweb/:6:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.3、配置 可以配置启动的端口号 tomcat的默认端口是：8080 \u003cConnector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 可以配置主机的名称 默认主机名为：localhost—\u003e127.0.0.1 默认网站应用存放的位置：webapps \u003cHost name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"\u003e 高难度面试题： 请你谈谈网站是如何进行访问的！ 1. 输入一个域名；回车 2. 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 1. 有：直接返回对应的IP地址，这个地址中，有我们需要访问的web程序，可以直接访问 2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到 ","date":"2021-07-04","objectID":"/javaweb/:7:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.4、发布一个web网站 查看Tomcat自带的一些样例 将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 网站应有的结构 --webapps ：Tomcat服务器的web目录 --ROOT --clover ： 网站的目录名 - WEB-INF - classes ： Java程序 - lib ：web应用所有依赖的jar包 - web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img 4、Http ","date":"2021-07-04","objectID":"/javaweb/:8:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.1、什么是Http HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上 文本：html，字符串 超文本： 图片，音乐，视频，定位，地图。。。。。 默认端口：80 HTTPS：安全的 默认端口：443 ","date":"2021-07-04","objectID":"/javaweb/:9:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.2、两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，就断开连接。 http2.0 HTTP/2.0：客户端可以与web服务器连接后，可以获得多个web资源。 ","date":"2021-07-04","objectID":"/javaweb/:10:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.3、HTTP请求 客户端—发请求–服务器 1. Request URL: https://www.baidu.com/ 请求地址 2. Request Method: GET get方法/post方法 3. Status Code: 200 OK 状态码：200 4. Remote Address: 14.215.177.39:443 远程地址 ","date":"2021-07-04","objectID":"/javaweb/:11:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT get：一次请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效。 post：一次请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 ","date":"2021-07-04","objectID":"/javaweb/:11:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、消息头 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 ","date":"2021-07-04","objectID":"/javaweb/:11:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.4、HTTP响应 服务器—响应—客户端 百度： Cache-Control: private 缓存控制 Connection: keep-alive 连接 Content-Encoding: gzip 编码 Content-Type: ext/html 类型 ","date":"2021-07-04","objectID":"/javaweb/:12:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、响应体 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 Refrush：告诉客户端多久刷新一次 Location： 让网页重新定位 ","date":"2021-07-04","objectID":"/javaweb/:12:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、相应状态码 200：代表请求响应成功 3**：请求重定向 重定向：你重新到我给你的新位置去 4xx：找不到资源 资源不存在 5xx：服务器代码错误 502：网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么！ 5、Maven ","date":"2021-07-04","objectID":"/javaweb/:12:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.1、Maven项目架构管理工具 我们目前用来就是方便导入Jar包的！ Maven的核心思想：约定大于配置 有约束就不要去违反 Maven会规定好你该如何去编写我们的Java代码，必须按照这个规定来 ","date":"2021-07-04","objectID":"/javaweb/:13:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.2、配置环境变量 在系统环境变量中配置如下配置： M2_HOME maven 目录下的bin目录 MAVEN_HOME　maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 测试maven是否安装成功，必须配置完毕 ","date":"2021-07-04","objectID":"/javaweb/:14:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.3、阿里云镜像 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2021-07-04","objectID":"/javaweb/:15:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.4、本地仓库 有本地仓库，就有远程仓库！ 建立一个本地仓库：localRepository \u003clocalRepository\u003eE:\\maven repository\\.m2\\repository\u003c/localRepository\u003e ","date":"2021-07-04","objectID":"/javaweb/:16:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.5、IDEA使用Maven Maven官网：https://mvnrepository.com/ IDEAMaven自动配置问题 在IDEA中标记文件夹功能 ","date":"2021-07-04","objectID":"/javaweb/:17:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.6、配置Tomcat的问题 解决警告问题 必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹的名字 maven由于它的约定大于配置，我们之后可能遇到我们写的配置文件，无法被导出或者生效的问题。 解决方案： \u003c!--在build中配置resources，来防止我们资源导出失败的问题--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 6、Servlet ","date":"2021-07-04","objectID":"/javaweb/:18:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.1、HelloSevlet Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建议Moudel； 这个空的工程就是Maven主工程 关于Maven父子工程的理解： 父项目中会有 \u003cmodules\u003e \u003cmodule\u003eservlet-01\u003c/module\u003e \u003c/modules\u003e 子项目会有 \u003cparent\u003e \u003cartifactId\u003ejavaweb-03-servlet\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e 父项目中的Jar包子项目可以直接使用，而子项目中的jar包父项目不可以使用 Maven环境优化 修改web.xml为最新版本（可以去tomcat中的webapps里面找到） 将Maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.print(\"Hello,Servlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写Servlet映射 为什么需要映射：我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所 有我们需要在web服务器中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径； \u003c!--注册Servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!-- Servlet的请求路径--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 配置tomcat 注意：配置项目的发布路径就可以了 启动测试 ","date":"2021-07-04","objectID":"/javaweb/:19:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.2、Servlet原理 Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会有如下操作： ","date":"2021-07-04","objectID":"/javaweb/:20:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.3、Mapping 一个Servlet请求可以指定一个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定多个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello5\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定通用映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\\*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 默认请求路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 指定一些后缀或者前缀等等 \u003c!--可以自定义后缀实现请求映射 注意点：*前面不能加项目映射的路径 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e*.clover\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求了 \u003c!--404--\u003e \u003cservlet\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ErrorServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 注意：在使用IDEA创建多个webapps工程时，在第二个运行可能会出现404找不到资源问题 这里是因为新创建的webapps文件上没有带蓝色点点,需要自己手动去加上，然后运行才会成功。 如若创建新的工程的pom.xml中没有parent那一行，重新创建即可 另外在创建新文件时应当先创建java跟resources两个文件夹，并且要标记，否则无法创建package ","date":"2021-07-04","objectID":"/javaweb/:21:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.4、ServletContext web容器在启动的时候，它会为每个web应用程序都创建一个对应的ServletContext对象，它代 表了当前的web应用； ","date":"2021-07-04","objectID":"/javaweb/:22:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、共享数据 我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数 很少用 // this.getServletConfig() Servlet参数 很少用 // this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = \"韋\"; context.setAttribute(\"username\",username);//将一个数据保存在了ServletContext中，名字为：username，值为：username System.out.println(\"hello\"); } } public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(\"username\"); //设置显示页面不乱码问题 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(\"名字为：\"+username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.GetServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003curl-pattern\u003e/getc\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 测试结果： ","date":"2021-07-04","objectID":"/javaweb/:22:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、获取初始化参数 \u003ccontext-param\u003e \u003cparam-name\u003eurl\u003c/param-name\u003e \u003cparam-value\u003ejdbc:mysql//localhost:3306/mybatis\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo03\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e public class ServletDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //此处获取上下文对象，获取初始化参数对应web.xml中的context-param中的参数，当你访问这个路径的时候，页面进行跳转的时候，就会获取到该路径对应的值 String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2021-07-04","objectID":"/javaweb/:22:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、请求转发 public class ServletDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); System.out.println(\"进入demo4\"); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/sd3\");//转发的请求路径 // requestDispatcher.forward(req,resp);//调用forward实现转发请求 context.getRequestDispatcher(\"/sd3\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo04\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2021-07-04","objectID":"/javaweb/:22:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、读取资源文件 Properties 在Java目录下新建一个properties 在resources目录下新建一个properties 发现：都打包到了同一个路径下：classes；我们俗称这个路径为classpath 思路：需要一个文件流 username=root password=123456 public class ServletDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"username\"); String pwd = properties.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pwd); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 访问测试结果： ","date":"2021-07-04","objectID":"/javaweb/:22:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.5、HttpServletResponse web服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest对 象，代表一个响应的HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse ","date":"2021-07-04","objectID":"/javaweb/:23:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、简单分类 负责向浏览器发送数据的方法 ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentLengthLong(long var1); void setContentType(String var1); void addDateHeader(String var1, long var2); void setHeader(String var1, String var2); void addHeader(String var1, String var2); void setIntHeader(String var1, int var2); void addIntHeader(String var1, int var2); ","date":"2021-07-04","objectID":"/javaweb/:23:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、常见应用 向浏览器输出消息 下载文件 要获取下载文件的路径 下载的文件名时什么？ 想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1. 要获取下载文件的路径 String realPath = \"G:\\\\IDEADocument\\\\javaweb\\\\javaweb-03-servlet\\\\response\\\\target\\\\classes\\\\韋.png\"; System.out.println(\"下载文件的路径：\"+realPath); //2. 下载的文件名时什么？如果有/则需要进行转义 String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); //3. 想办法让浏览器能够支持下载我们需要的东西,下载我们需要的东西，中文文件名，则使用URLEncoder.encode编码，否则有可能乱码 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+ URLEncoder.encode(fileName,\"UTF-8\")); //4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(realPath); //5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; //6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); //7. 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ while((len = in.read(buffer))\u003e0){ out.write(buffer,0,len); } in.close(); out.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 注意：如果图片采用中文名字命名，则需要将其转化，使用URLEncoder.encoder编码，有可能会乱码 ","date":"2021-07-04","objectID":"/javaweb/:23:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、验证码功能 验证怎么来的？ 前端实现 后端实现，需要用到Java的图片类，生成一个图片 public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如何让一个浏览器3秒自动刷新一次 resp.setHeader(\"refresh\",\"3\"); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D) image.getGraphics();//笔 //设置图片的背景颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.red); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(\"image/jpeg\"); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(\"expires\",-1); resp.setHeader(\"Cache-Control\",\"no-cache\"); resp.setHeader(\"Pragma\",\"no-cache\"); //把图片写给浏览器 ImageIO.write(image,\"jpg\",resp.getOutputStream()); } //生成随机数 private String makeNum(){ Random random = new Random(); String num = random.nextInt(999999) + \"\"; StringBuffer sb = new StringBuffer(); //如果num产生的长度为4，这里就让其空下来的地方填充0，保证其数字长度为6 for (int i = 0; i \u003c6 - num.length() ; i++) { sb.append(\"0\"); } num = sb.toString() + num; return num; } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ImageServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003curl-pattern\u003e/img\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 关于expries一些简单的简介：https://www.jianshu.com/p/f331d5f0b979 ","date":"2021-07-04","objectID":"/javaweb/:23:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、实现重定向 B一个web资源收到客户端A请求后，B它会通知A客户端去访问另外一个web资源C，这个过程叫重定向 常见场景： 用户登录 void sendRedirect(String var1) throws IOException; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //重定向 /* resp.setHeader(\"Location\",\"/r/img\"); resp.setStatus(302); * */ resp.sendRedirect(\"/r/img\"); } \u003cbody\u003e \u003ch2\u003eHello World!\u003c/h2\u003e \u003c%--这里提交的路径，需要寻找到项目的路径--%\u003e \u003c%--${pageContext.request.contextPath()}代表当前项目的路径--%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"get\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/body\u003e \u003c/html\u003e 面试题：请你聊聊重定向和转发的区别？. 相同点 页面都会实现跳转 不同点 请求转发的时候，url不会产生变化 重定向的时候，url地址栏会发生变化 ","date":"2021-07-04","objectID":"/javaweb/:23:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.6、HttpServletRequest HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装 到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息 ","date":"2021-07-04","objectID":"/javaweb/:24:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、获取参数,请求转发 //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); 注意：如果这里使用`/`它会默认的找不到路径资源，因为这里的`/`就代表着当前的web应用 重定向的时候需要写全路径 而转发的时候时不需要写全路径的 \u003ch1\u003e登录\u003c/h1\u003e \u003cdiv\u003e \u003c%-- 这里表单表示的依视：以post方式提交表单，提交到我们的login请求--%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e 爱好： \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"女孩\"\u003e女孩 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"代码\"\u003e代码 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"唱歌\"\u003e唱歌 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"电影\"\u003e电影 \u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/div\u003e public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String[] hobbys = req.getParameterValues(\"hobbys\"); System.out.println(\"====================\"); //后台接受中文乱码问题 System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbys)); System.out.println(\"====================\"); System.out.println(req.getContextPath()); //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 7、Cookie、Session ","date":"2021-07-04","objectID":"/javaweb/:24:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.1、会话 会话：用户打开一个浏览器，点击了很多超链接，访问web资源，关闭浏览器，这个过程可以称之为会话 有状态会话： 一个同学来过教室，下次再来教室，我们会指定这个同学，曾经来过，称之为有状态会话 一个网站怎么证明你来过？ 客户端（自己） 服务端（网站） 服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookie 服务器登记你来过了，下次你来的时候我来匹配你；session ","date":"2021-07-04","objectID":"/javaweb/:25:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.2、保存会话的两种技术 cookie 客户端技术（响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据存放在session中！ 常见例子：网站登录之后，你下次就不用在登录了，可以直接进去 ","date":"2021-07-04","objectID":"/javaweb/:26:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.3、Cookie 注意：使用谷歌浏览器解决浏览器显示中文乱码，要多设置一个resp.setContentType(\"text/html;charset=utf-8\"); 从请求中拿到cookie信息 服务器响应给客户端cookie Cookie[] cookies = req.getCookies();//获得cookie cookie.getName();//获得cookie中的key cookie.getValue();//获得cookie中的value new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\");//新建一个cookie loginTime.setMaxAge(24*60*60);//设置cookie的有效期 resp.addCookie(loginTime);//响应给客户端一个cookie 数据之间的转化 //获取cookie中的值![[Pasted image 20210608115423.png]] cookie.getValue(); //将cookie中的值转化为Long型 long lastLoginTime = Long.parseLong(cookie.getValue()); //以时间格式显示 Date date = new Date(lastLoginTime); //以字符串的形式输出 out.write(date.toLocaleString()); cookie：一般会保存在本地的用户目录下的AppData 一个网站的cookie是否存在上限！ 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie cookie大小有限制4kb 300个cookie浏览器上限 删除Cookie 不设置有效期，关闭浏览器，自动失效 设置有效期为0 public class CookieDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //创建一个Cookie，名字必须要和删除的名字一致 Cookie cookie = new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\"); //设置Cookie的有效期为0，立马过期 cookie.setMaxAge(0); //给客户端响应一个cookie resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 传递中文数据的时候，可能会出现乱码 所以可以采用编码、解码 URLEncoder.encode(\"韋\",\"utf-8\") URLDecoder.decode(cookie.getValue(),\"utf-8\") ","date":"2021-07-04","objectID":"/javaweb/:27:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.4、Session（重点） 什么是Session： 服务器会给每一个用户（浏览器）创建一个Session对象； 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站它都可以访问！－－＞保存用户的信息；保存购物车的信息．．．．．． Session和Cookie的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存（保存重要的信息，减少服务器资源的浪费 Session对象由服务器创建 使用场景： 保存一个登录用户的信息 购物车信息 在整个网站中经常会使用的数据，我们将它保存在Session中 //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); resp.addCookie(cookie); Session是在网页一打开就会创建并且一直存在，就算你关闭了网页他也会存在，除非你手动删除 使用Session： package com.clover.servlet; import com.clover.pojo.Person; import javax.servlet.ServletException; import javax.servlet.http.*; import java.io.IOException; public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); //给Session中存放东西 session.setAttribute(\"name\",new Person(\"韋\",1)); //获取Session的ID String sessionId = session.getId(); //判断Session是不是新创建的 if(session.isNew()){ resp.getWriter().write(\"session创建成功，ID：\"+sessionId); }else { resp.getWriter().write(\"session已经在服务器中存在了，ID：\"+sessionId); } //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ // Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); // resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } --------------------------------------------------------- 获取对象中的值 public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); Person name = (Person) session.getAttribute(\"name\"); System.out.println(name); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ----------------------------------------------------------- 手动注销session public class SessionDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); //取消刚刚获取的name session.removeAttribute(\"name\"); //并且注销掉该session，注销后立马生成新的sessionId，手动注销Session session.invalidate(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 会话自动过期：web.xml中配置 \u003c!--设置session默认失效时间--\u003e \u003csession-config\u003e \u003c!--1分钟后session自动失效，以分钟为单位--\u003e \u003csession-timeout\u003e1\u003c/session-timeout\u003e \u003c/session-config\u003e 8、JSP ","date":"2021-07-04","objectID":"/javaweb/:28:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.1、什么是JSP Java Server Pages ：Java服务器端页面，也和Servlet一样，用于动态Web技术 最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据 ","date":"2021-07-04","objectID":"/javaweb/:29:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.2、JSP原理 思路：JSP到底是怎么执行的？ 代码层面没有任何问题 服务器内部工作 tomcat有一个work目录 IDEA中使用Tomcat会在IDEA的tomcat中产生一个work目录 我电脑的地址： C:\\Users\\REN\\.IntelliJIdea2019.3\\system\\tomcat\\Tomcat_9_0_411_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 发现页面转变成了Java程序！ 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet JSP最终也会被转换成为一个Java类！ JSP本质上就是一个Servlet //初始化 public void _jspInit() { } //销毁 public void _jspDestroy() { } //JSPServlet public void _jspService(HttpServletRequest request, HttpServletResponse response) 判断请求 内置一些对象 final javax.servlet.jsp.PageContext pageContext; //页面上下文 javax.servlet.http.HttpSession session = null; //session final javax.servlet.ServletContext application; //applicationContext final javax.servlet.ServletConfig config; //配置 javax.servlet.jsp.JspWriter out = null; //输出对象 final java.lang.Object page = this; //当前页 HttpServletRequest request //请求 HttpServletResponse response //响应 输出页面前增加的代码 response.setContentType(\"text/html\"); //设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; 以上的这些个对象，我们可以在JSP页面中直接使用 在JSP页面中；只要是JAVA代码就会原封不动的输出；如果是HTML代码就会被转化为： out.write(\"\u003chtml\u003e\\n\"); 这样的格式，输出到前端！ ","date":"2021-07-04","objectID":"/javaweb/:30:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.3、JSP基础语法 JSP表达式 \u003c%-- JSP表达式 作用：用来将程序的输出，输出到客户端 \u003c%= 变量或者表达式%\u003e --%\u003e \u003c%= new java.util.Date()%\u003e JSP脚本片段 \u003c%-- jsp脚本片段--%\u003e \u003c% int sum = 0; for (int i = 1; i \u003c= 100; i++) { sum+=i; } out.println(\"\u003ch1\u003eSum=\"+sum+\"\u003c/h1\u003e\"); %\u003e 脚本片段的再实现 \u003c% int x = 10; out.println(x); %\u003e \u003cp\u003e这是一个JSP文档\u003c/p\u003e \u003c% int y = 20; out.println(x); out.println(y); %\u003e \u003c%-- 在代码中嵌入HTML元素--%\u003e \u003c% for (int i = 0; i \u003c 5; i++) { %\u003e \u003ch1\u003ehello,world\u003c%= i%\u003e\u003c/h1\u003e \u003c% } %\u003e JSP声明 \u003c%! static { System.out.println(\"Loading servlet\"); } private int globalvar = 0; public void clover(){ System.out.println(\"进入了clover方法\"); } %\u003e 注意：这里使用的\u003c\u003e里面有一个感叹号存在 JSP声明：会被编译到JSP生成的Java类中！其他的，就会被生成到_jspService方法中！ JSP的注释，不会在客户端显示，HTML就会！ ","date":"2021-07-04","objectID":"/javaweb/:31:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.4、JSP指令 \u003c%@page args......%\u003e \u003c%@include file=\"\"%\u003e \u003c%--@include会将两个页面合二为一--%\u003e \u003c%@include file=\"common/header.jsp\"%\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003c%@include file=\"common/footer.jsp\"%\u003e \u003chr\u003e \u003c%--jsp标签 jsp:include：拼接页面，本质上还是三个 --%\u003e \u003cjsp:include page=\"/common/header.jsp\"/\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003cjsp:include page=\"/common/footer.jsp\"/\u003e 注意：使用 jsp:include，其中的page代表当web页面，所以需要在common前面加一个/ 而两者也是有区别，使用@include，如果同时定义一个名字相同的变量，则会报错 使用 jsp:include则不会报错 ","date":"2021-07-04","objectID":"/javaweb/:32:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.5、九大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【ServletContext】存东西 config 【ServletConfig】 out page exception 在pageContextDemo01中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--内置对象--%\u003e \u003c% pageContext.setAttribute(\"name1\",\"clover一号\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\",\"clover二号\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\",\"clover三号\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\",\"clover四号\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器 %\u003e \u003c%--脚本片段中的代码，会被原封不动生成到.JSP.java 要求：这里面的代码，必须保证Java语法的正确性 --%\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）:page--\u003erequest--\u003esession--\u003eapplication String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 2.在pageContextDemo02中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）: String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 这里由于时在另外一个页面访问，也没有请求转发，所以一号与二号就消亡了 测试结果： 3.在pageContextDemo03中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% pageContext.forward(\"/index.jsp\"); //就相当于执行了request.getRequestDispatcher(\"/index.jsp\").forward(request,response); %\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用了的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车 application：客户端向服务器发送请求，产生的数据，一个用户用完了，其它用户还可能使用，比如：聊天数据 ","date":"2021-07-04","objectID":"/javaweb/:33:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.6、JSP标签、JSTL标签，EL表达式 所需依赖 \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp.jstl\u003c/groupId\u003e \u003cartifactId\u003ejstl-api\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003etaglibs\u003c/groupId\u003e \u003cartifactId\u003estandard\u003c/artifactId\u003e \u003cversion\u003e1.1.2\u003c/version\u003e \u003c/dependency\u003e EL表达式：${} 获取数据 执行运算 获取web开发常用对象 JSP标签 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--jsp:include--%\u003e \u003c%-- http://localhost:8080/jsptag.jsp?name=clover$age=3 --%\u003e \u003cjsp:forward page=\"jsptag2.jsp\"\u003e \u003cjsp:param name=\"name\" value=\"clover\"/\u003e \u003cjsp:param name=\"age\" value=\"3\"/\u003e \u003c/jsp:forward\u003e \u003c/body\u003e \u003c/html\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--取出参数--%\u003e 名字：\u003c%=request.getParameter(\"name\")%\u003e 年龄：\u003c%=request.getParameter(\"age\")%\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： JSTL表达式 JSTL标签库的使用就是为了弥补HTML标签的不足，它自定义许多标签，可以供我们使用，标签的功能和Java代码一样 核心标签（掌握部分） JSTL标签使用步骤 引入对应的taglib 使用其中的方法 注意：在Tomcat也需要引入jstl的包，否则会报错，JSTL解析错误 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch4\u003eif测试\u003c/h4\u003e \u003chr\u003e \u003cform action=\"coreif.jsp\" method=\"get\"\u003e \u003c%-- EL表达式获取表单中的数据 ${param.参数名} --%\u003e \u003cinput type=\"text\" name=\"username\" value=\"${param.username}\"\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/form\u003e \u003c%--判断如果提交的用户名是管理员，则登录成功--%\u003e \u003cc:if test=\"${param.username=='admin'}\" var=\"isAdmin\"\u003e \u003cc:out value=\"管理员欢迎您！\"/\u003e \u003c/c:if\u003e \u003c%--自闭和标签--%\u003e \u003cc:out value=\"${isAdmin}\"/\u003e \u003c/body\u003e \u003c/html\u003e 登录账户不为admin时的结果： 登录账户为admin时的结果： corechoose 与 corewhen \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--定义一个变量score，值为85--%\u003e \u003cc:set var=\"score\" value=\"90\"/\u003e \u003cc:choose\u003e \u003cc:when test=\"${score\u003e=90}\"\u003e 你的成绩为优秀 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=80}\"\u003e 你的成绩为良好 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=70}\"\u003e 你的成绩为一般 \u003c/c:when\u003e \u003cc:when test=\"${score\u003c=60}\"\u003e 你的成绩为不及格 \u003c/c:when\u003e \u003c/c:choose\u003e \u003c/body\u003e \u003c/html\u003e 注意：如果有一个值满足多个条件，它会按照顺序去执行 coreforeach \u003c%@ page import=\"java.util.ArrayList\" %\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% ArrayList\u003cString\u003e people = new ArrayList\u003c\u003e(); people.add(0,\"张三\"); people.add(1,\"李四\"); people.add(2,\"王五\"); people.add(3,\"张六\"); people.add(4,\"田七\"); request.setAttribute(\"list\",people); %\u003e \u003c%-- var,每一次遍历出来的变量 item，要遍历的对象 begin，从哪开始 end，到哪结束 step，每一次执行的步长 --%\u003e \u003cc:forEach var=\"people\" items=\"${list}\"\u003e \u003cc:out value=\"${people}\"/\u003e\u003cbr\u003e \u003c/c:forEach\u003e \u003cbr\u003e \u003cc:forEach var=\"people\" items=\"${list}\" begin=\"1\" end=\"3\" step=\"2\"\u003e \u003cc:out value=\"${people}\" /\u003e \u003c/c:forEach\u003e \u003c/body\u003e \u003c/html\u003e 使用了begin end 变量后的情况 9、JavaBean JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法 一般用来和数据库的字段做映射 ORM：对象关系映射 10、MVC三层架构 ","date":"2021-07-04","objectID":"/javaweb/:34:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.1、原来的操作模式 用户直接访问控制层，控制层就可以直接操作数据库 servlet---CRUD---数据库 弊端：程序十分臃肿，不利于维护（在servlet中加入了处理jdbc的代码） Servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 架构思想：没有什么是加一层解决不了的！ ","date":"2021-07-04","objectID":"/javaweb/:35:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.2、MVC三层架构 Model 业务处理：业务逻辑（Service） 数据持久层：CRUD（Dao） View 展示数据 提供连接发起Servlet请求 Controller 接受用户的请求：（req：请求参数、session信息） 交给业务层处理对应的代码 控制视图的跳转 登录---\u003e接受用户的登录请求---\u003e处理用户的请求（获取用户登录的参数，username，password）---\u003e交给业务层处理登录业务（判断用户名密码是否正确：事务）---\u003eDao层查询用户名和密码是否正确---\u003e数据库 11、Filter（重点） Filter：过滤器，用来过滤网站的数据 处理中文乱码 登录验证 Filter开发步骤： 导包 编写过滤器 导包不能导入错误 编写过滤器，实现Filter接口，重写对应的方法 package com.clover.filter; import javax.servlet.*; import java.io.IOException; public class CharacterEncodingFilter implements Filter { //初始化：web服务器启动，就已经初始化了，随时等待过滤对象出现！ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"CharacterEncodingFilter初始化\"); } //Chain：链 /* * 1.过滤器中的所有代码，再过滤特定请求的时候都会执行 * 2.必须要让过滤器继续执行（因为可能存在多个过滤器，所以要继续执行下去） * */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(\"UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"CharacterEncodingFilter执行前.........\"); chain.doFilter(request,response);//让我们的请求继续走，如果不屑，程序执行到这里就会被拦截停止！ System.out.println(\"CharacterEncodingFilter执行后.........\"); } //销毁 @Override public void destroy() { System.out.println(\"CharacterEncodingFilter销毁\"); } } 3.编写web.xml配置Filter \u003cfilter\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.clover.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003c!-- 只要是 /servlet下的任何请求，都会经过这个过滤器--\u003e \u003curl-pattern\u003e/servlet/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e 12、监听器 编写一个监听器 实现一个监听器的接口 package com.clover.listener; import javax.servlet.ServletContext; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class OnlineCountListener implements HttpSessionListener { //创建session监听：查看你的一举一动 //一旦创建Session就会出发一次这个事件！ @Override public void sessionCreated(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count+1); } context.setAttribute(\"OnlineCount\",onlineCount); } //销毁Session监听 //一旦销毁Session就会出发一次这个事件！ @Override public void sessionDestroyed(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count-1); } context.setAttribute(\"OnlineCount\",onlineCount); } /* * 销毁session有两种方法 *1.自动销毁 getSession().invalidate(); *2.手动销毁 在web.xml中设置session存活时间 */ } 在web.xml中注册监听器 \u003c!--注册监听器--\u003e \u003clistener\u003e \u003clistener-class\u003ecom.clover.listener.OnlineCountListener\u003c/listener-class\u003e \u003c/listener\u003e 13、过滤器、监听器常见应用 ","date":"2021-07-04","objectID":"/javaweb/:36:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["Thread"],"content":"Thread","date":"2021-07-04","objectID":"/thread/","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程简介 ","date":"2021-07-04","objectID":"/thread/:1:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Process：进程 程序是指令和数据的有效集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。一个进程中可以包含若干个线程，当然一个进程中最少包含一个线程。线程是CPU调度和执行的单位。 ","date":"2021-07-04","objectID":"/thread/:1:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Thread：线程 ","date":"2021-07-04","objectID":"/thread/:1:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"两条线程是同时、交替执行的 注意，线程开启不一定立即执行，由CPU调度执行 ","date":"2021-07-04","objectID":"/thread/:1:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"方法一：继承Thread类，重写run()方法，调用start开启线程 package com.ren.lesson01; //创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由CPU调度执行 public class TestThread01 extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 TestThread01 testThread01 = new TestThread01(); //调用start()方法开启线程 testThread01.start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： 从网络上下载图片，通过一个下载器方法实现 package com.ren.lesson01; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestThread02(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public void run() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestThread02 t2 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestThread02 t3 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //这三个不是按照顺序来执行的，是同时进行，小的先完成 t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } 小结：","date":"2021-07-04","objectID":"/thread/:1:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 package com.ren.lesson01; //创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 public class TestThread03 implements Runnable{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //创建runnable接口的实现类对象 TestThread03 testThread03 = new TestThread03(); //创建线程对象，通过线程对象来开启我们的线程，代理 // Thread thread = new Thread(testThread03); // // thread.start(); new Thread(testThread03).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： package com.ren.lesson01; //多个线程同时操作同一个对象 //买火车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread04 implements Runnable{ //票数 private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums\u003c=0){ break; } //模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //Thread.currentThread().getName()获取当前线程的名称 System.out.println(Thread.currentThread().getName()+\"--\u003e拿到了第\"+ticketNums--+\"票\"); } } public static void main(String[] args) { TestThread04 ticket = new TestThread04(); new Thread(ticket,\"你\").start(); new Thread(ticket,\"我\").start(); new Thread(ticket,\"他\").start(); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程创建方式三：实现Callable接口 package com.ren.lesson02; import com.ren.lesson01.TestThread02; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; //线程创建方式三：实现Callable接口 /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ public class TestCallable implements Callable\u003cBoolean\u003e { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public Boolean call() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行(通过服务来提交我们的线程) Future\u003cBoolean\u003e r1 = ser.submit(t1); Future\u003cBoolean\u003e r2 = ser.submit(t2); Future\u003cBoolean\u003e r3 = ser.submit(t3); //获取结果（获取的结果就是线程调用了call函数所返回的结果） Boolean rs1 = r1.get(); Boolean rs2 = r1.get(); Boolean rs3 = r1.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ 结果图： ","date":"2021-07-04","objectID":"/thread/:1:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"静态代理 使用结婚这个例子来阐述，可以将其与线程进行比较 package com.ren.lesson02; /** * 静态代理模式总结： * 真实对象（目标对象）和代理对象都要实现同一个接口 * 代理对象要代理真实角色 * 好处：代理对象可以做很多真实对象做不了的事情 * 真实对象专注做自己的事情 */ public class StaticProxy { public static void main(String[] args) { You you = new You(); //将其与多线程对比 /** * Thread就相当于WeddingCompany * Thread是一个代理，它代理的是他括号里面的真实对象（Runnable接口） * HappyMarry是来自于它的接口中的（代理对象中的），start是Thread里面去弄的，它们都有一个共同的方法，run方法 */ new Thread(()-\u003e System.out.println(\"我爱你\")).start(); new WeddingCompany(you).HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry() { System.out.println(\"我要结婚了！\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁--\u003e真实目标角色 private Marry target; public WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry();//这就是真实对象 after(); } private void after() { System.out.println(\"结婚之后，收尾款\"); } private void before() { System.out.println(\"结婚之前，布置现场\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lamda表达式 ","date":"2021-07-04","objectID":"/thread/:2:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"函数式接口的定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lamda表达式来创建该接口的对象 一步步的简化过程 package com.ren.lesson02; /** * 推导lamda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda2\"); } } public static void main(String[] args) { ILike like = new Like(); like.lamda(); like = new Like2(); like.lamda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda3\"); } } like = new Like3(); like.lamda(); //5.匿名内部类,没有类的名称，必须借助接口或者父类 like = new ILike() { @Override public void lamda() { System.out.println(\"i like lamda4\"); } }; like.lamda(); //3.用lamda简化 like = ()-\u003e{ System.out.println(\"i like lamda5\"); }; like.lamda(); } } //1.定义一个函数式接口 interface ILike{ void lamda(); } //2.实现类 class Like implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda\"); } } 实例过程 package com.ren.lesson02; public class TestLamda2 { public static void main(String[] args) { //lamda表达式简化 ILove love = (int a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化1.去掉参数类型 love = (a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化2.去掉括号 love = a-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化3.去掉花括号 love = a-\u003e System.out.println(\"i love you--\u003e\"+a); /** * 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 */ love.love(8); } } interface ILove{ void love(int a); } 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 ","date":"2021-07-04","objectID":"/thread/:2:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程五大状态 ","date":"2021-07-04","objectID":"/thread/:3:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程方法 ","date":"2021-07-04","objectID":"/thread/:3:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不涉及到多个线程操作一个对象可以直接继承Thread，涉及道路就采用继承Runnable接口 ","date":"2021-07-04","objectID":"/thread/:4:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程停止 package com.ren.lesson03; /** * 测试stop(停止线程) * 1.建议使用线程正常停止---\u003e利用次数，不建议死循环 * 2.建议使用标志位---\u003e设置一个标志位 * 3.不要使用stop或者destory等过时或者JDK不建议使用的方法 */ public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while(flag){ System.out.println(\"run......Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\"+i); if(i==900){ //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"该线程停止了\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程休眠 package com.ren.lesson03; import java.text.SimpleDateFormat; import java.util.Date; //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取系统当前时间 while(true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if(num\u003c=0){ break; } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程礼让 package com.ren.lesson03; /** * 测试礼让线程 * 礼让不一定成功，看CPU心情 */ public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行！\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行！\"); } } 结果图： 注意：礼让有可能是成功的，也有可能礼让失败！！！ ","date":"2021-07-04","objectID":"/thread/:4:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程强制执行_Join Join合并线程，待此线程执行完成后，再执行其它线程，其它线程阻塞。可以想象成插队。 package com.ren.lesson03; //测试join方法，想象成插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"线程VIP来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); //主线程 for (int i = 0; i \u003c 500; i++) { if(i==200){ thread.start(); thread.join();//插队 } System.out.println(\"main\"+i); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程状态观测 package com.ren.lesson03; //观察测试线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"//////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//New //观察启动后 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//Run //只要线程不终止，就一直输出状态 while(state != Thread.State.TERMINATED){ Thread.sleep(100);//1秒运行十次 state = thread.getState();//线程状态的更新 System.out.println(state); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程优先级 线程优先级越高，所获取的资源越多 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度 package com.ren.lesson03; //测试线程的优先级 public class Testpriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，在启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(5); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); // t5.setPriority(11); // t5.start(); // // t6.setPriority(-1); // t6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"守护线程 package com.ren.lesson03; //测试守护线程 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(); thread.setDaemon(true);//默认是false表示的用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程启动 new Thread(you).start();// 你 用户线程启动 } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\"1111111111111111111111111\"); } } } class You implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 36500; i++) { System.out.println(\"你一生都开心的活着！\"); } System.out.println(\"============goodbye world==============\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程同步机制 ","date":"2021-07-04","objectID":"/thread/:4:8","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"三大不安全案例 ","date":"2021-07-04","objectID":"/thread/:5:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"买票 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //模拟延时 放大问题的发生性 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"取钱 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不安全的集合 package com.ren.lesson04; import java.util.ArrayList; import java.util.List; //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步方法 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); //模拟延时 放大问题的发生性 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } //synchronized 同步方法，锁的是this private synchronized void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } ","date":"2021-07-04","objectID":"/thread/:6:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步块 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(1000,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 //synchronized 默认锁的是this @Override public void run() { //锁的对象就是变化的量，需要增、删、改的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } } ","date":"2021-07-04","objectID":"/thread/:6:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"CopyOnWriteArrayList package com.ren.lesson04; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //打印是在主线程，操作list是在子线程，sleep是保证子线程执行完在执行主线程的打印 System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:7:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁 ","date":"2021-07-04","objectID":"/thread/:8:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁避免方法 package com.ren.lesson05; //死锁：多个线程互相抱着对方需要的资源，形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑凉\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); //选择 int choice; //使用化妆品的人 String girlName; public Makeup(int choice,String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException { if(choice == 0){ /** * 这个地方解决的方法就是不让其一个人抱着两个人的资源，将其写到外面来 */ synchronized (lipstick){//获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } synchronized (mirror){//一秒钟后想获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){//获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } synchronized (lipstick){//两秒钟后想获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:8:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lock ","date":"2021-07-04","objectID":"/thread/:9:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"synchronized与Lock的对比 package com.ren.lesson05; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try{ //加锁 lock.lock(); if(ticketNums\u003e0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { //解锁 lock.unlock(); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:9:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"生产者消费者问题 ","date":"2021-07-04","objectID":"/thread/:10:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"管程法 package com.ren.lesson05; //测试：生产者消费者模型--\u003e利用缓冲区解决：管程法 //生产者， 消费者 ， 产品， 缓冲区 public class TestPC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); } } //生产者 class Productor extends Thread{ SynContainer container; public Productor(SynContainer container){ this.container = container; } //生产 @Override public void run() { for (int i = 0; i \u003c 100; i++) { container.push(new Chicken(i)); System.out.println(\"生产了第\"+i+\"只鸡\"); } } } //消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } //消费 @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(\"消费了第--\u003e\"+container.pop().id+\"只鸡\"); } } } //产品 class Chicken{ //产品编号 int id; public Chicken(int id) { this.id = id; } } //缓冲区 class SynContainer{ //需要一个容器大小 Chicken[] chickens = new Chicken[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Chicken chicken){ //如果容器满了，就需要等待消费者消费产品 if(count==chickens.length){ //通知消费者生产，生产者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果没有满，我们就需要丢入产品 chickens[count] = chicken; count++; //可以通知消费者消费了 this.notifyAll(); } //消费者消费产品 public synchronized Chicken pop(){ //判断能否消费 if(count == 0){ //等待生产者生产，消费者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果可以消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"信号灯法 package com.ren.lesson05; //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--\u003e演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if(i%2==0){ tv.play(\"快乐大本营播放中！\"); }else{ tv.play(\"抖音记录美好生活\"); } } } } //消费者--\u003e观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { tv.watch(); } } } //产品--\u003e节目 class TV{ //演员表演，观众等待 T //观众观看，演员等待 F //表演的节目 String voice; //标志位 boolean flag = true; //演员表演 public synchronized void play(String voice){ if(!flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice = voice; this.flag = !flag; } //观众观看 public synchronized void watch(){ if(flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"观众观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !flag; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"使用线程池 package com.ren.lesson05; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable的实现类 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:11:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了  结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new G","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["Docker"],"content":"docker","date":"2021-07-04","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-07-04","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-07-04","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-07-04","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 ","date":"2021-07-04","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 ","date":"2021-07-04","objectID":"/docker/:3:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 ","date":"2021-07-04","objectID":"/docker/:3:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-07-04","objectID":"/docker/:3:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 ","date":"2021-07-04","objectID":"/docker/:4:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 ","date":"2021-07-04","objectID":"/docker/:4:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 ","date":"2021-07-04","objectID":"/docker/:4:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 ","date":"2021-07-04","objectID":"/docker/:4:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Centos安装 https://docs.docker.com/engine/install/centos/ ","date":"2021-07-04","objectID":"/docker/:4:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ","date":"2021-07-04","objectID":"/docker/:4:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils ","date":"2021-07-04","objectID":"/docker/:4:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 ","date":"2021-07-04","objectID":"/docker/:4:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ ","date":"2021-07-04","objectID":"/docker/:4:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images ","date":"2021-07-04","objectID":"/docker/:4:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 ","date":"2021-07-04","objectID":"/docker/:4:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-07-04","objectID":"/docker/:4:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-07-04","objectID":"/docker/:5:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 ","date":"2021-07-04","objectID":"/docker/:6:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 ","date":"2021-07-04","objectID":"/docker/:6:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 ","date":"2021-07-04","objectID":"/docker/:6:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，变成了centos的容器id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minutes stoic_wilson edbd9366d959 centos \"/bin/bash\" 35 minutes ago Up 35 minutes affectionate_bartik 9939864fa2e6 centos \"bin/bash\" 48 minutes ago Exited (0) 48 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 52 minutes ago Exited (0) 49 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 20 hours ago Exited (0) 20 hours ago gracious_bhabha [root@192 ~]# docker rm 5f42e9930435 5f42e9930435 [root@192 ~]# docker rm edbd9366d959 # 注意正在运行的容器不能删除 Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove [root@192 ~]# docker ps -aq # 所有容器id bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d [root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除 bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d 启动和停止容器的操作 docker start docker restart docker stop docker kill [root@192 ~]# docker run -it centos /bin/bash [root@7b1a7dd10ea4 /]# exit exit [root@192 ~]# docker ps #查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a # 查看历史运行过的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 54 seconds ago Exited (0) 42 seconds ago fervent_mirzakhani [root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来 7b1a7dd10ea4 [root@192 ~]# docker ps # 查看当前运行容器 发现启动成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 2 minutes ago Up 28 seconds fervent_mirzakhani [root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行 7b1a7dd10ea4 [root@192 ~]# docker ps # 再次查看 没有这个容器了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","date":"2021-07-04","objectID":"/docker/:6:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"常用其他命令 后台启动docker docker run -d 镜像名 # 用docker ps 查看的时候 发现停止了 # 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止 Last login: Wed Jun 17 19:47:35 2020 [root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker [root@192 ~]# docker run -d centos # 运行 8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded [root@192 ~]# docker ps -a # 查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ce188e5fee3 centos \"/bin/bash\" 19 seconds ago Exited (0) 18 seconds ago tender_dirac 7b1a7dd10ea4 centos \"/bin/bash\" 8 hours ago Exited (0) 8 hours ago fervent_mirzakhani 查看日志 docker logs # -tf #显示日志 #--tail number # 要显示日志条数 docker logs -f -t --tail n 【id】 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps # 时间戳 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) # 自己编写的一个脚本 whiel true;do echo shenzai;sleep # 运行一个 [root@192 ~]# docker run -it centos /bin/bash [root@c2887d35c71d /]# [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c2887d35c71d centos \"/bin/bash\" 57 seconds ago Up 56 seconds vigorous_kare # 查看日志，由于没有运行脚本，所以啥也没显示 [root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d ^C # ctrl+c退出 # 运行centos里面加个脚本 [root@192 ~]# docker run -d centos /bin/sh -c \"while true;do echo shenzai;sleep 1;done\" cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb6d7fbc3f27 centos \"/bin/sh -c 'while t…\" 7 seconds ago Up 6 seconds dreamy_almeida c2887d35c71d centos \"/bin/bash\" 3 minutes ago Up 3 minutes vigorous_kare # 查看日志 发现隔一秒打印一条 [root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27 2020-06-17T12:02:11.293765084Z shenzai 2020-06-17T12:02:12.297675608Z shenzai 2020-06-17T12:02:13.301845582Z shenzai 2020-06-17T12:02:14.304800996Z shenzai 2020-06-17T12:02:15.307130238Z shenzai 2020-06-17T12:02:16.310574235Z shenzai 2020-06-17T12:02:17.312946923Z shenzai 2020-06-17T12:02:18.314841295Z shenzai 2020-06-17T12:02:19.317021705Z shenzai 2020-06-17T12:02:20.319670013Z shenzai 2020-06-17T12:02:21.322651649Z shenzai 2020-06-17T12:02:22.325466918Z shenzai 2020-06-17T12:02:23.327984704Z shenzai 2020-06-17T12:02:24.329656919Z shenzai 查看容器中进程信息 # 命令 docker top 容器id # UID：当前用户id PID：父id PPID：进程ID UID PID PPID C STIME root 1424 31183 0 15:13 root 31183 31163 0 14:50 查看正在镜像的元数据 # 命令 docker inspect 容器id [root@192 ~]# docker inspect cb6d7fbc3f27 [ { # 容器的完整id \"Id\": \"cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\", # 创建时间 \"Created\": \"2020-06-17T12:00:50.706906186Z\", # 脚本位置 \"Path\": \"/bin/sh\", # 运行的脚本 \"Args\": [ \"-c\", \"while true;do echo shenzai;sleep 1;done\" ], \"State\": { \"Status\": \"running\", # 状态，正在运行 \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1909, # 父进程id \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-06-17T12:00:51.093617477Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, # 镜像来源 \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname\", \"HostsPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts\", \"LogPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log\", \"Name\": \"/dreamy_almeida\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"Mou","date":"2021-07-04","objectID":"/docker/:6:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"可视化 portainer(先用这个) Rancher(CI/CD时用) portainer Docker图像化界面管理工具，提供一个后台面板供我们操作！ docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer 访问外网8088 用户名 密码 【中午吃饭重连了一下，失败，不知道发生了啥】 【平时不会用这个，好吧，先往下】 ","date":"2021-07-04","objectID":"/docker/:6:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 ","date":"2021-07-04","objectID":"/docker/:7:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 ","date":"2021-07-04","objectID":"/docker/:7:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-07-04","objectID":"/docker/:7:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 ","date":"2021-07-04","objectID":"/docker/:8:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 ","date":"2021-07-04","objectID":"/docker/:8:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 ","date":"2021-07-04","objectID":"/docker/:8:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 ","date":"2021-07-04","objectID":"/docker/:8:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"具名和匿名挂载 ","date":"2021-07-04","objectID":"/docker/:8:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 ","date":"2021-07-04","objectID":"/docker/:8:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-07-04","objectID":"/docker/:8:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 ","date":"2021-07-04","objectID":"/docker/:9:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 ","date":"2021-07-04","objectID":"/docker/:9:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 # 表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ ","date":"2021-07-04","objectID":"/docker/:9:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile命令 ","date":"2021-07-04","objectID":"/docker/:9:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 ","date":"2021-07-04","objectID":"/docker/:9:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 ","date":"2021-07-04","objectID":"/docker/:9:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 ","date":"2021-07-04","objectID":"/docker/:9:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包 tomcat压缩包 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html ","date":"2021-07-04","objectID":"/docker/:9:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login -u cloverfelix Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [root@iZ2zejeormv0s24sdvazvxZ ~]# 4、登录完毕后就可以提交镜像了，就是一步 docker push # push到自己的镜像到服务器上 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker push divtomcat Using default tag: latest The push refers to repository [docker.io/library/divtomcat] b23ff398b23f: Preparing e0403d0b82a9: Preparing d252d00ff518: Preparing 537a66dda3f7: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied # push请求被拒绝了 [root@iZ2zejeormv0s24sdvazvxZ ~]# push上去的时候一定记得带上版本号 ","date":"2021-07-04","objectID":"/docker/:9:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"小结： ","date":"2021-07-04","objectID":"/docker/:9:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 ","date":"2021-07-04","objectID":"/docker/:10:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是--link 技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：--link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用--link了！ 使用的都是自定义网络！不使用docker0！ docker0问题：它不支持容器名连接访问！ ","date":"2021-07-04","objectID":"/docker/:10:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE e3ed9ad5b74b bridge bridge local 51f1bd18d34e host host local f833096b830f mynet bridge local bb8aa0300ba6 none null local 我们自己的网络就创建好了 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-01 tomcat 7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-02 tomcat 11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111\", \"Created\": \"2021-02-03T00:17:44.277900481+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"1b542176401a508f905acbb09ab2d07c45c3280e6f60e66428a565766470b46e\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"872b36e9c2a5d9f59a2931e1edad34c3eded6d693c3fef830e29bcdae511b4d9\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] # 再次测试ping连接 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.121 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.096 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.100 ms --- 192.168.0.3 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.096/0.105/0.121/0.016 ms #现在不使用--link也可以ping名字了！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.099 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.103 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.093 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.100 ms --- tomcat-net-02 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.069/0.092/0.103/0.017 ms 结论：我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络 好处： redis - 不同的集群使用不同的网络，保证集群是安全和健康的 mysql - 不同的集群使用不同的网络，保证集群是安全和健康的 ","date":"2021-07-04","objectID":"/docker/:10:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"网络连通 # 测试打通 tomcat01 到 mynet # 连通之后就是将我们的 tomcat01 加到 mynet网络下 # 一个容器两个ip地址 #阿里云服务器： 一个公网 一个私网地址 # tomcat01 可以与 tomcat-net-01 连通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.4 PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data. 64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.134 ms 64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.095 ms 64 bytes from 192.168.0.4: icmp_seq=3 ttl=64 time=0.097 ms 64 bytes from 192.168.0.4: icmp_seq=4 ttl=64 time=0.096 ms ^C --- 192.168.0.4 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.095/0.105/0.134/0.019 ms # tomcat02 与 tomcat-net-01依旧打不通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat-net-01 ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ ","date":"2021-07-04","objectID":"/docker/:10:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战：部署Redis集群 ","date":"2021-07-04","objectID":"/docker/:10:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-07-04","objectID":"/docker/:11:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-07-04","objectID":"/docker/:12:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-07-04","objectID":"/docker/:13:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-07-04","objectID":"/docker/:14:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug ","date":"2021-07-04","objectID":"/docker/:15:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-07-04","objectID":"/docker/:15:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"}]