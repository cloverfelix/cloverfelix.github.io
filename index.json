[{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了  结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new G","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["Docker"],"content":"docker","date":"2021-07-04","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-07-04","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-07-04","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-07-04","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 ","date":"2021-07-04","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 ","date":"2021-07-04","objectID":"/docker/:3:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 ","date":"2021-07-04","objectID":"/docker/:3:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-07-04","objectID":"/docker/:3:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 ","date":"2021-07-04","objectID":"/docker/:4:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 ","date":"2021-07-04","objectID":"/docker/:4:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 ","date":"2021-07-04","objectID":"/docker/:4:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 ","date":"2021-07-04","objectID":"/docker/:4:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Centos安装 https://docs.docker.com/engine/install/centos/ ","date":"2021-07-04","objectID":"/docker/:4:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ","date":"2021-07-04","objectID":"/docker/:4:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils ","date":"2021-07-04","objectID":"/docker/:4:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 ","date":"2021-07-04","objectID":"/docker/:4:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ ","date":"2021-07-04","objectID":"/docker/:4:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images ","date":"2021-07-04","objectID":"/docker/:4:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 ","date":"2021-07-04","objectID":"/docker/:4:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-07-04","objectID":"/docker/:4:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是真么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-07-04","objectID":"/docker/:5:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 ","date":"2021-07-04","objectID":"/docker/:6:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 ","date":"2021-07-04","objectID":"/docker/:6:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 ","date":"2021-07-04","objectID":"/docker/:6:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，编程了centos的id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minutes stoic_wilson edbd9366d959 centos \"/bin/bash\" 35 minutes ago Up 35 minutes affectionate_bartik 9939864fa2e6 centos \"bin/bash\" 48 minutes ago Exited (0) 48 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 52 minutes ago Exited (0) 49 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 20 hours ago Exited (0) 20 hours ago gracious_bhabha [root@192 ~]# docker rm 5f42e9930435 5f42e9930435 [root@192 ~]# docker rm edbd9366d959 # 注意正在运行的容器不能删除 Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove [root@192 ~]# docker ps -aq # 所有容器id bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d [root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除 bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d 启动和停止容器的操作 docker start docker restart docker stop docker kill [root@192 ~]# docker run -it centos /bin/bash [root@7b1a7dd10ea4 /]# exit exit [root@192 ~]# docker ps #查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a # 查看历史运行过的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 54 seconds ago Exited (0) 42 seconds ago fervent_mirzakhani [root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来 7b1a7dd10ea4 [root@192 ~]# docker ps # 查看当前运行容器 发现启动成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 2 minutes ago Up 28 seconds fervent_mirzakhani [root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行 7b1a7dd10ea4 [root@192 ~]# docker ps # 再次查看 没有这个容器了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","date":"2021-07-04","objectID":"/docker/:6:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"常用其他命令 后台启动docker docker run -d 镜像名 # 用docker ps 查看的时候 发现停止了 # 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止 Last login: Wed Jun 17 19:47:35 2020 [root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker [root@192 ~]# docker run -d centos # 运行 8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded [root@192 ~]# docker ps -a # 查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ce188e5fee3 centos \"/bin/bash\" 19 seconds ago Exited (0) 18 seconds ago tender_dirac 7b1a7dd10ea4 centos \"/bin/bash\" 8 hours ago Exited (0) 8 hours ago fervent_mirzakhani 查看日志 docker logs # -tf #显示日志 #--tail number # 要显示日志条数 docker logs -f -t --tail n 【id】 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps # 时间戳 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) # 自己编写的一个脚本 whiel true;do echo shenzai;sleep # 运行一个 [root@192 ~]# docker run -it centos /bin/bash [root@c2887d35c71d /]# [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c2887d35c71d centos \"/bin/bash\" 57 seconds ago Up 56 seconds vigorous_kare # 查看日志，由于没有运行脚本，所以啥也没显示 [root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d ^C # ctrl+c退出 # 运行centos里面加个脚本 [root@192 ~]# docker run -d centos /bin/sh -c \"while true;do echo shenzai;sleep 1;done\" cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb6d7fbc3f27 centos \"/bin/sh -c 'while t…\" 7 seconds ago Up 6 seconds dreamy_almeida c2887d35c71d centos \"/bin/bash\" 3 minutes ago Up 3 minutes vigorous_kare # 查看日志 发现隔一秒打印一条 [root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27 2020-06-17T12:02:11.293765084Z shenzai 2020-06-17T12:02:12.297675608Z shenzai 2020-06-17T12:02:13.301845582Z shenzai 2020-06-17T12:02:14.304800996Z shenzai 2020-06-17T12:02:15.307130238Z shenzai 2020-06-17T12:02:16.310574235Z shenzai 2020-06-17T12:02:17.312946923Z shenzai 2020-06-17T12:02:18.314841295Z shenzai 2020-06-17T12:02:19.317021705Z shenzai 2020-06-17T12:02:20.319670013Z shenzai 2020-06-17T12:02:21.322651649Z shenzai 2020-06-17T12:02:22.325466918Z shenzai 2020-06-17T12:02:23.327984704Z shenzai 2020-06-17T12:02:24.329656919Z shenzai 查看容器中进程信息 # 命令 docker top 容器id # UID：当前用户id PID：父id PPID：进程ID UID PID PPID C STIME root 1424 31183 0 15:13 root 31183 31163 0 14:50 查看正在镜像的元数据 # 命令 docker inspect 容器id [root@192 ~]# docker inspect cb6d7fbc3f27 [ { # 容器的完整id \"Id\": \"cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\", # 创建时间 \"Created\": \"2020-06-17T12:00:50.706906186Z\", # 脚本位置 \"Path\": \"/bin/sh\", # 运行的脚本 \"Args\": [ \"-c\", \"while true;do echo shenzai;sleep 1;done\" ], \"State\": { \"Status\": \"running\", # 状态，正在运行 \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1909, # 父进程id \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-06-17T12:00:51.093617477Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, # 镜像来源 \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname\", \"HostsPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts\", \"LogPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log\", \"Name\": \"/dreamy_almeida\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"Mou","date":"2021-07-04","objectID":"/docker/:6:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"可视化 portainer(先用这个) Rancher(CI/CD时用) portainer Docker图像化界面管理工具，提供一个后台面板供我们操作！ docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer 访问外网8088 用户名 密码 【中午吃饭重连了一下，失败，不知道发生了啥】 【平时不会用这个，好吧，先往下】 ","date":"2021-07-04","objectID":"/docker/:6:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 ","date":"2021-07-04","objectID":"/docker/:7:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 ","date":"2021-07-04","objectID":"/docker/:7:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-07-04","objectID":"/docker/:7:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 ","date":"2021-07-04","objectID":"/docker/:8:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 ","date":"2021-07-04","objectID":"/docker/:8:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 ","date":"2021-07-04","objectID":"/docker/:8:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 ","date":"2021-07-04","objectID":"/docker/:8:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"具名和匿名挂载 ","date":"2021-07-04","objectID":"/docker/:8:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 ","date":"2021-07-04","objectID":"/docker/:8:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-07-04","objectID":"/docker/:8:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 ","date":"2021-07-04","objectID":"/docker/:9:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 ","date":"2021-07-04","objectID":"/docker/:9:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 *#*表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ ","date":"2021-07-04","objectID":"/docker/:9:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile命令 ","date":"2021-07-04","objectID":"/docker/:9:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":" FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 ","date":"2021-07-04","objectID":"/docker/:9:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 ","date":"2021-07-04","objectID":"/docker/:9:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 ","date":"2021-07-04","objectID":"/docker/:9:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包：https://blog.csdn.net/doupeihua/article/details/51831947 tomcat压缩包：https://tomcat.apache.org/download-90.cgi 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html ","date":"2021-07-04","objectID":"/docker/:9:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login -u cloverfelix Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [root@iZ2zejeormv0s24sdvazvxZ ~]# 4、登录完毕后就可以提交镜像了，就是一步 docker push # push到自己的镜像到服务器上 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker push divtomcat Using default tag: latest The push refers to repository [docker.io/library/divtomcat] b23ff398b23f: Preparing e0403d0b82a9: Preparing d252d00ff518: Preparing 537a66dda3f7: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied # push请求被拒绝了 [root@iZ2zejeormv0s24sdvazvxZ ~]# push上去的时候一定记得带上版本号 ","date":"2021-07-04","objectID":"/docker/:9:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"小结： ","date":"2021-07-04","objectID":"/docker/:9:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 ","date":"2021-07-04","objectID":"/docker/:10:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们没每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是**–link**技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：–link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用-link了！ 使用的都是自定义网络！不适用docker0！ docker0问题：它不支持容器名连接访问！ ","date":"2021-07-04","objectID":"/docker/:10:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE e3ed9ad5b74b bridge bridge local 51f1bd18d34e host host local f833096b830f mynet bridge local bb8aa0300ba6 none null local 我们自己的网络就创建好了 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-01 tomcat 7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-02 tomcat 11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111\", \"Created\": \"2021-02-03T00:17:44.277900481+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"1b542176401a508f905acbb09ab2d07c45c3280e6f60e66428a565766470b46e\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"872b36e9c2a5d9f59a2931e1edad34c3eded6d693c3fef830e29bcdae511b4d9\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] # 再次测试ping连接 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.121 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.096 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.100 ms --- 192.168.0.3 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.096/0.105/0.121/0.016 ms #现在不使用--link也可以ping名字了！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.099 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.103 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.093 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.100 ms --- tomcat-net-02 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.069/0.092/0.103/0.017 ms 结论：我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络 好处： redis - 不同的集群使用不同的网络，保证集群是安全和健康的 mysql - 不同的集群使用不同的网络，保证集群是安全和健康的 ","date":"2021-07-04","objectID":"/docker/:10:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"网络连通 # 测试打通 tomcat01 到 mynet # 连通之后就是将我们的 tomcat01 加到 mynet网络下 # 一个容器两个ip地址 #阿里云服务器： 一个公网 一个私网地址 # tomcat01 可以与 tomcat-net-01 连通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.4 PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data. 64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.134 ms 64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.095 ms 64 bytes from 192.168.0.4: icmp_seq=3 ttl=64 time=0.097 ms 64 bytes from 192.168.0.4: icmp_seq=4 ttl=64 time=0.096 ms ^C --- 192.168.0.4 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.095/0.105/0.134/0.019 ms # tomcat02 与 tomcat-net-01依旧打不通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat-net-01 ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ ","date":"2021-07-04","objectID":"/docker/:10:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战：部署Redis集群 ","date":"2021-07-04","objectID":"/docker/:10:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-07-04","objectID":"/docker/:11:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-07-04","objectID":"/docker/:12:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-07-04","objectID":"/docker/:13:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-07-04","objectID":"/docker/:14:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug ","date":"2021-07-04","objectID":"/docker/:15:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-07-04","objectID":"/docker/:15:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"}]