[{"categories":["Docker"],"content":"docker","date":"2021-07-04","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-07-04","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-07-04","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-07-04","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 ","date":"2021-07-04","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 ","date":"2021-07-04","objectID":"/docker/:3:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 ","date":"2021-07-04","objectID":"/docker/:3:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-07-04","objectID":"/docker/:3:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 ","date":"2021-07-04","objectID":"/docker/:4:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 ","date":"2021-07-04","objectID":"/docker/:4:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 ","date":"2021-07-04","objectID":"/docker/:4:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 ","date":"2021-07-04","objectID":"/docker/:4:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Centos安装 https://docs.docker.com/engine/install/centos/ ","date":"2021-07-04","objectID":"/docker/:4:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ","date":"2021-07-04","objectID":"/docker/:4:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils ","date":"2021-07-04","objectID":"/docker/:4:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 ","date":"2021-07-04","objectID":"/docker/:4:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ ","date":"2021-07-04","objectID":"/docker/:4:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images ","date":"2021-07-04","objectID":"/docker/:4:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 ","date":"2021-07-04","objectID":"/docker/:4:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-07-04","objectID":"/docker/:4:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是真么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-07-04","objectID":"/docker/:5:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 ","date":"2021-07-04","objectID":"/docker/:6:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 ","date":"2021-07-04","objectID":"/docker/:6:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 ","date":"2021-07-04","objectID":"/docker/:6:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，编程了centos的id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minutes stoic_wilson edbd9366d959 centos \"/bin/bash\" 35 minutes ago Up 35 minutes affectionate_bartik 9939864fa2e6 centos \"bin/bash\" 48 minutes ago Exited (0) 48 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 52 minutes ago Exited (0) 49 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 20 hours ago Exited (0) 20 hours ago gracious_bhabha [root@192 ~]# docker rm 5f42e9930435 5f42e9930435 [root@192 ~]# docker rm edbd9366d959 # 注意正在运行的容器不能删除 Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove [root@192 ~]# docker ps -aq # 所有容器id bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d [root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除 bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d 启动和停止容器的操作 docker start docker restart docker stop docker kill [root@192 ~]# docker run -it centos /bin/bash [root@7b1a7dd10ea4 /]# exit exit [root@192 ~]# docker ps #查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a # 查看历史运行过的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 54 seconds ago Exited (0) 42 seconds ago fervent_mirzakhani [root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来 7b1a7dd10ea4 [root@192 ~]# docker ps # 查看当前运行容器 发现启动成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 2 minutes ago Up 28 seconds fervent_mirzakhani [root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行 7b1a7dd10ea4 [root@192 ~]# docker ps # 再次查看 没有这个容器了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","date":"2021-07-04","objectID":"/docker/:6:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"常用其他命令 后台启动docker docker run -d 镜像名 # 用docker ps 查看的时候 发现停止了 # 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止 Last login: Wed Jun 17 19:47:35 2020 [root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker [root@192 ~]# docker run -d centos # 运行 8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded [root@192 ~]# docker ps -a # 查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ce188e5fee3 centos \"/bin/bash\" 19 seconds ago Exited (0) 18 seconds ago tender_dirac 7b1a7dd10ea4 centos \"/bin/bash\" 8 hours ago Exited (0) 8 hours ago fervent_mirzakhani 查看日志 docker logs # -tf #显示日志 #--tail number # 要显示日志条数 docker logs -f -t --tail n 【id】 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps # 时间戳 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) # 自己编写的一个脚本 whiel true;do echo shenzai;sleep # 运行一个 [root@192 ~]# docker run -it centos /bin/bash [root@c2887d35c71d /]# [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c2887d35c71d centos \"/bin/bash\" 57 seconds ago Up 56 seconds vigorous_kare # 查看日志，由于没有运行脚本，所以啥也没显示 [root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d ^C # ctrl+c退出 # 运行centos里面加个脚本 [root@192 ~]# docker run -d centos /bin/sh -c \"while true;do echo shenzai;sleep 1;done\" cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb6d7fbc3f27 centos \"/bin/sh -c 'while t…\" 7 seconds ago Up 6 seconds dreamy_almeida c2887d35c71d centos \"/bin/bash\" 3 minutes ago Up 3 minutes vigorous_kare # 查看日志 发现隔一秒打印一条 [root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27 2020-06-17T12:02:11.293765084Z shenzai 2020-06-17T12:02:12.297675608Z shenzai 2020-06-17T12:02:13.301845582Z shenzai 2020-06-17T12:02:14.304800996Z shenzai 2020-06-17T12:02:15.307130238Z shenzai 2020-06-17T12:02:16.310574235Z shenzai 2020-06-17T12:02:17.312946923Z shenzai 2020-06-17T12:02:18.314841295Z shenzai 2020-06-17T12:02:19.317021705Z shenzai 2020-06-17T12:02:20.319670013Z shenzai 2020-06-17T12:02:21.322651649Z shenzai 2020-06-17T12:02:22.325466918Z shenzai 2020-06-17T12:02:23.327984704Z shenzai 2020-06-17T12:02:24.329656919Z shenzai 查看容器中进程信息 # 命令 docker top 容器id # UID：当前用户id PID：父id PPID：进程ID UID PID PPID C STIME root 1424 31183 0 15:13 root 31183 31163 0 14:50 查看正在镜像的元数据 # 命令 docker inspect 容器id [root@192 ~]# docker inspect cb6d7fbc3f27 [ { # 容器的完整id \"Id\": \"cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\", # 创建时间 \"Created\": \"2020-06-17T12:00:50.706906186Z\", # 脚本位置 \"Path\": \"/bin/sh\", # 运行的脚本 \"Args\": [ \"-c\", \"while true;do echo shenzai;sleep 1;done\" ], \"State\": { \"Status\": \"running\", # 状态，正在运行 \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1909, # 父进程id \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-06-17T12:00:51.093617477Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, # 镜像来源 \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname\", \"HostsPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts\", \"LogPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log\", \"Name\": \"/dreamy_almeida\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"Mou","date":"2021-07-04","objectID":"/docker/:6:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"可视化 portainer(先用这个) Rancher(CI/CD时用) portainer Docker图像化界面管理工具，提供一个后台面板供我们操作！ docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer 访问外网8088 用户名 密码 【中午吃饭重连了一下，失败，不知道发生了啥】 【平时不会用这个，好吧，先往下】 ","date":"2021-07-04","objectID":"/docker/:6:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 ","date":"2021-07-04","objectID":"/docker/:7:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 ","date":"2021-07-04","objectID":"/docker/:7:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-07-04","objectID":"/docker/:7:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 ","date":"2021-07-04","objectID":"/docker/:8:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 ","date":"2021-07-04","objectID":"/docker/:8:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 ","date":"2021-07-04","objectID":"/docker/:8:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 ","date":"2021-07-04","objectID":"/docker/:8:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"具名和匿名挂载 ","date":"2021-07-04","objectID":"/docker/:8:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 ","date":"2021-07-04","objectID":"/docker/:8:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-07-04","objectID":"/docker/:8:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 ","date":"2021-07-04","objectID":"/docker/:9:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 ","date":"2021-07-04","objectID":"/docker/:9:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 *#*表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ ","date":"2021-07-04","objectID":"/docker/:9:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile命令 ","date":"2021-07-04","objectID":"/docker/:9:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":" FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 ","date":"2021-07-04","objectID":"/docker/:9:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 ","date":"2021-07-04","objectID":"/docker/:9:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 ","date":"2021-07-04","objectID":"/docker/:9:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包：https://blog.csdn.net/doupeihua/article/details/51831947 tomcat压缩包：https://tomcat.apache.org/download-90.cgi 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html ","date":"2021-07-04","objectID":"/docker/:9:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login -u cloverfelix Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [root@iZ2zejeormv0s24sdvazvxZ ~]# 4、登录完毕后就可以提交镜像了，就是一步 docker push # push到自己的镜像到服务器上 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker push divtomcat Using default tag: latest The push refers to repository [docker.io/library/divtomcat] b23ff398b23f: Preparing e0403d0b82a9: Preparing d252d00ff518: Preparing 537a66dda3f7: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied # push请求被拒绝了 [root@iZ2zejeormv0s24sdvazvxZ ~]# push上去的时候一定记得带上版本号 ","date":"2021-07-04","objectID":"/docker/:9:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"小结： ","date":"2021-07-04","objectID":"/docker/:9:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 ","date":"2021-07-04","objectID":"/docker/:10:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们没每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是**–link**技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：–link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用-link了！ 使用的都是自定义网络！不适用docker0！ docker0问题：它不支持容器名连接访问！ ","date":"2021-07-04","objectID":"/docker/:10:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE e3ed9ad5b74b bridge bridge local 51f1bd18d34e host host local f833096b830f mynet bridge local bb8aa0300ba6 none null local 我们自己的网络就创建好了 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-01 tomcat 7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-02 tomcat 11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111\", \"Created\": \"2021-02-03T00:17:44.277900481+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"1b542176401a508f905acbb09ab2d07c45c3280e6f60e66428a565766470b46e\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"872b36e9c2a5d9f59a2931e1edad34c3eded6d693c3fef830e29bcdae511b4d9\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] # 再次测试ping连接 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.121 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.096 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.100 ms --- 192.168.0.3 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.096/0.105/0.121/0.016 ms #现在不使用--link也可以ping名字了！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.099 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.103 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.093 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.100 ms --- tomcat-net-02 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.069/0.092/0.103/0.017 ms 结论：我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络 好处： redis - 不同的集群使用不同的网络，保证集群是安全和健康的 mysql - 不同的集群使用不同的网络，保证集群是安全和健康的 ","date":"2021-07-04","objectID":"/docker/:10:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"网络连通 # 测试打通 tomcat01 到 mynet # 连通之后就是将我们的 tomcat01 加到 mynet网络下 # 一个容器两个ip地址 #阿里云服务器： 一个公网 一个私网地址 # tomcat01 可以与 tomcat-net-01 连通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.4 PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data. 64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.134 ms 64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.095 ms 64 bytes from 192.168.0.4: icmp_seq=3 ttl=64 time=0.097 ms 64 bytes from 192.168.0.4: icmp_seq=4 ttl=64 time=0.096 ms ^C --- 192.168.0.4 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.095/0.105/0.134/0.019 ms # tomcat02 与 tomcat-net-01依旧打不通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat-net-01 ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ ","date":"2021-07-04","objectID":"/docker/:10:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战：部署Redis集群 ","date":"2021-07-04","objectID":"/docker/:10:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-07-04","objectID":"/docker/:11:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-07-04","objectID":"/docker/:12:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-07-04","objectID":"/docker/:13:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-07-04","objectID":"/docker/:14:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug ","date":"2021-07-04","objectID":"/docker/:15:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-07-04","objectID":"/docker/:15:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"}]