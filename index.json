[{"categories":["Mybatis"],"content":"mybatis","date":"2021-06-01","objectID":"/mybatis/","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1、简介 ","date":"2021-06-01","objectID":"/mybatis/:0:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.1、什么是Mybatis ","date":"2021-06-01","objectID":"/mybatis/:1:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.2、持久化（持久化是一个动作） 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（jdbc），io文件持久化。 为什么需要持久化有一些对象，不能让他丢掉。用时再取 对象：如支付宝里面的钱不能丢失以及页面的一些信息 因为内存有一个特点是断电即失 另外一个原因也是内存太贵（外在原因） ","date":"2021-06-01","objectID":"/mybatis/:2:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.3、持久层（是一个概念） Dao层，Service层，Controller层…等每一个层都有它们自己要做的事情 完成持久化工作的代码块 层是界限十分明显 ","date":"2021-06-01","objectID":"/mybatis/:3:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.4、为什么需要Mybatis 帮助程序员将数据存入到数据库中 方便 传统的JDBC代码太复杂了。所以将其简化，出现一个框架 不用Mybatis也可以。更容易上手。 2、第一个Mybatis程序 思路：搭建环境–\u003e导入Mybatis–\u003e编写代码–\u003e测试！ ","date":"2021-06-01","objectID":"/mybatis/:4:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.1、搭建环境 CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, # 设置id，并设为主键且不为空 `name` VARCHAR(30) DEFAULT NULL, # 设置名字，默认为空 `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; # 设置引擎为INNODB 默认字符集为utf8 INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'科比','123456'), (2,'哈登','123456'), (3,'威少','123456') 新建项目 1.新建一个普通的maven项目 2.删除src目录 3.导入maven依赖 \u003cdependencies\u003e \u003c!--mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-06-01","objectID":"/mybatis/:5:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.2、创建一个模块 编写mybatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003c!--此处的\u0026amp;相当于yml里面的\u0026\u0026,只是在xml文件中得进行转化--\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 编写mybatis工具类 package com.kuang.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { //提升作用域 private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } ","date":"2021-06-01","objectID":"/mybatis/:6:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.3、编写代码 实体类 package com.kuang.pojo; //实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } Dao接口 public interface UserDao { List\u003cUser\u003e getUserList(); } 接口实现类（由原来的Use人DaoImpl转变为一个Mapper配置文件） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace等于绑定一个对于的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.kuang.dao.UserDao\"\u003e \u003c!--select查询语句 id对应的是我们的方法名字--\u003e \u003cselect id=\"getUserList\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e 注意点：在使用resultType返回结果时，返回集合中的泛型，不要写集合 ","date":"2021-06-01","objectID":"/mybatis/:7:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.4、测试 注意点：org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册mappers \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e junit测试 package com.kuang.dao; import com.kuang.pojo.User; import com.kuang.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserDaoTest { @Test public void test(){ //第一步：活得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List\u003cUser\u003e userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlsession sqlSession.close(); } } 官网推荐的是我们将close放入finally中，自己手动添加一个try-catch语句 可能遇到的问题： 配置文件没有注册 绑定接口错误 namespace绑定问题 方法名不对 返回类型不对 resulttype返回类型 Maven导出资源问题 思路： 导入最基本需要的依赖包 创建一个工具类，构建SqlSessionFactory 编写核心配置文件 连接数据库，修改里面的属性 写完实体类后写接口，最后写实体类，用mapper.xml代替了原来的Impl 每次收到的HTTP请求（也就是连接我们的数据库），就可以打开一个SqlSession，返回一个响应，就关闭它。 3、CRUD ","date":"2021-06-01","objectID":"/mybatis/:8:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.1、namespace namespace中的包名要和Dao/mapper接口的包名一致！ ","date":"2021-06-01","objectID":"/mybatis/:9:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.2、select 选择，查询语句 id：就是对应的namespace中的方法名 resultType：SQL语句执行的返回值 parameterType：参数类型！ 1.编写接口 //根据ID查询用户 User getUserById(int id); 2.编写对应的mapper中的sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e 3.测试 public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); //关闭sqlsession sqlSession.close(); } ","date":"2021-06-01","objectID":"/mybatis/:10:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.3、Insert \u003c!--对象中的属性可以直接提取出来--\u003e \u003cinsert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"\u003e insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e ","date":"2021-06-01","objectID":"/mybatis/:11:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.4、Update \u003cupdate id=\"updateUser\" parameterType=\"com.kuang.pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2021-06-01","objectID":"/mybatis/:12:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.5、delete \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id}; \u003c/delete\u003e 注意点： 增删改需要提交事务，否则添加不进去（代码执行没问题，数据库里面不显示） resource绑定mapper，需要使用路径 ","date":"2021-06-01","objectID":"/mybatis/:13:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.6、万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ Map传递参数，直接在sql中取出即可！【parameterType=“Map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ ","date":"2021-06-01","objectID":"/mybatis/:14:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.7、思考题 模糊查询 ​ 1.Java代码执行的时候，传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%李%\"); ​ 2.在sql拼接中使用通配符！ select * from mybatis.user where name like \"%\"#{value}\"%\" 4、配置解析 ","date":"2021-06-01","objectID":"/mybatis/:15:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-06-01","objectID":"/mybatis/:16:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.2、环境配置（environment） Mybatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 transactionManager：事务管理器，分为JDBC与MANAGED dataSource：数据源，分为UNPOOLED、POOLED、JNDI；最重要的概念就是：池：拥有回收机制，即下次可以继续执行 Mybatis默认的事务管理器就是JDBC，连接池：POOLED ","date":"2021-06-01","objectID":"/mybatis/:17:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】 编写一个配置文件：db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026userUnicode=true\u0026characterEncoding=UTF-8 username=root password=xn123456 在核心配置文件中引入 \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ ","date":"2021-06-01","objectID":"/mybatis/:18:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名，Mybatis会在包名下面搜索需要的Java Bean 扫描实体类的包，它的默认别名就为这个类的类名首字母小写 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e 在实体类比较少的时候，使用第一种方式 如果实体类十分多，建议使用第二种 第一种可以DIY别名，第二种则不行，如果非要使用别名，需要在实体类上增加注解，在实体类上注解的同时，也需要在核心配置文件中扫描指定的包。 @Alias(\"user\") public class User { ","date":"2021-06-01","objectID":"/mybatis/:19:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.5、设置 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 ","date":"2021-06-01","objectID":"/mybatis/:20:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.6、其它配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件] mybatis-generator-core mybatis-plus 通用mapper ","date":"2021-06-01","objectID":"/mybatis/:21:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.7、映射器（mappers） MapperRegistry：绑定注册我们的Mapper文件 方式一：【推荐使用】 \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/UserMapper.xml\"/\u003e \u003c/mappers\u003e 方式二：使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 \u003cmappers\u003e \u003cmapper package=\"com.kuang.dao\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ ","date":"2021-06-01","objectID":"/mybatis/:22:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.8、生命周期和作用域 生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 它是一个局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 因此SqlSessionFactory的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。使其保证全局唯一 SqlSession： 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ 5、解决属性名和字段名不一致的问题 ","date":"2021-06-01","objectID":"/mybatis/:23:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.1、问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } // select * from mybatis.user where id = #{id} //类型处理器 // select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select id,name,pwd as password from mybatis.user where id = #{id} \u003c/select\u003e ","date":"2021-06-01","objectID":"/mybatis/:24:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.2、resultMap 结果集映射 \u003c!--结果集映射：id就是你下面resultMap的值；type就是结果集要映射成谁就是什么类型--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\" \u003e select * from mybatis.user where id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本iju不需要显示地用到它们。 6、日志 ","date":"2021-06-01","objectID":"/mybatis/:25:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.1、日志工厂 如果一个数据库操作，出现了异常。日志就是最好的助手 曾经：sout、debug 现在：日志工厂！ SLF4J LOG4J LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 注意：使用标准日志输出时，出现报错：1、value后面的值又空格，切记！ 在mybatis核心配置文件中，配置我们的日志 \u003csettings\u003e \u003c--标准的日志工厂实现--\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c/settings\u003e ","date":"2021-06-01","objectID":"/mybatis/:26:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.2、Log4j 什么是log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 先导入log4j的包 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e kog4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PrepareStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e Log4j的使用，直接测试运行刚才的查询 [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VFS [org.apache.ibatis.io.JBoss6VFS]-JBoss 6 VFS API is not available in this environment. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VirtualFile [org.apache.ibatis.io.VFS]-VFS implementation org.apache.ibatis.io.JBoss6VFS is not valid in this environment. [org.apache.ibatis.io.VFS]-Using VFS adapter org.apache.ibatis.io.DefaultVFS [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Reader entry: User.class [org.apache.ibatis.io.DefaultVFS]-Listing file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Reader entry: ���� 4 @ [org.apache.ibatis.io.ResolverUtil]-Checking to see if class com.kuang.pojo.User matches criteria [is assignable to Object] [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection [org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 2044903525. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79e2c065] [com.kuang.dao.UserMapper.getUserList]-==\u003e Preparing: select * from mybatis.user [com.kuang.dao.UserMapper.getUserList]-==\u003e Parameters: [com.kuang.dao.UserMapper.getUserList]-\u003c== Total: 3 User{id=1, name='科比', pwd='123456'} User{id=2, name='哈登', pwd='123456'} User{id=3, name='威少', pwd='123456'} [org.apache.ibatis.tran","date":"2021-06-01","objectID":"/mybatis/:27:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.1、使用Limit 分页 语法： SELECT * from user limit startIndex,pageSize; startIndex:起始的位置，按数组下标开始进行分页 pageSize:每一页的数量 SELECT * from user limit 3; #类似于[0,n] 使用Mybatis实现分页，核心就是SQL 接口 //分页 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003emap); Mapper.xml \u003cselect id=\"getUserByLimit\" parameterType=\"map\" resultType=\"user\"\u003e select * from mybatis.user limit #{startIndex},#{pageSize}; \u003c/select\u003e 如果此处的pwd没有改成password，则不需要进行结果集映射，如果改了，则需要进行结果集映射，就不能使用resultType，则需要使用resultMap 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-06-01","objectID":"/mybatis/:28:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.2、RowBounds分页 不再使用sql实现分页 接口 //分页2 List\u003cUser\u003e getUserByRowBounds(); mapper.xml \u003cselect id=\"getUserByRowBounds\" resultType=\"user\"\u003e select * from mybatis.user; \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //通过RowBounds实现分页 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-06-01","objectID":"/mybatis/:29:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.3、分页插件 了解即可，==Mybatis PageHelper== 8、使用注解开发 ","date":"2021-06-01","objectID":"/mybatis/:30:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.1、面向接口编程 ","date":"2021-06-01","objectID":"/mybatis/:31:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.2、使用注解开发 注解直接在接口上实现 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); } 需要在核心配置文件中绑定接口！ \u003c!--绑定接口--\u003e \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 测试使用 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //底层主要应用反射 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUsers(); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 本质：反射机制实现 底层：动态代理！ ","date":"2021-06-01","objectID":"/mybatis/:32:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.3、注解的CRUD 我们可以在工具类创建的时候自动提交事务 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口，增加注解 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); //@Param方法存在多个参数，所有的参数前面必须加上@Param(\"id\")注解 @Select(\"select * from user where id = #{id}\") User getUserById(@Param(\"id\") int id); @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{pwd})\") int addUser(User user); @Update(\"update user set name=#{name},pwd=#{pwd} where id = #{id}\") int updateUser(User user); @Delete(\"delete from user where id = #{uid}\") int deleteUser(@Param(\"uid\") int id); } 注意：我们必须要将接口注册绑定到我们的核心配置文件中 使用Param注解时，里面对应的基本类型应当与sql语句中的类型一致，否则报错 关于@Param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上去 我们在SQL中引用的就是我们这里的@Param()中设置的属性名 9、Lombok 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入Lombok的ｊａｒ包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 这是一款懒人插件，虽然简化了许多，但是却对新手造成了困惑，不容易去阅读源码了；对于这种插件，合理的利用才是关键 说明： ＠Data：无参构造，get、set、toString、hashcode、equals @AllArgsConstructor：有参构造 @NoArgsConstructor：无参构造 10、多对一处理 多对一: 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 【多对一】 对于老师这边而言，集合…一个老师，有很多学生 【一对多】 SQL： CREATE TABLE `teacher`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY(`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`,`name`) VALUES (1,'秦老师'); CREATE TABLE `student`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY(`id`), KEY `fktid`(`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('1','小明','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('2','小红','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('3','小张','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('4','小李','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('5','小王','1'); 实体类： public class Student { private int id; private String name; //关联老师 private Teacher teacher; } public class Teacher { private int id; private String name; } ","date":"2021-06-01","objectID":"/mybatis/:33:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.1、按照查询嵌套处理 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.StudentMapper\"\u003e \u003c!--思路： 1.查询所有的学生信息 2.根据查询出来的学生的tid，寻找对应的那个老师 --\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性，我们需要单独处理，如果属性是对象，我们采用association，如果属性是集合，我们采用collection javaType是因为属性为对象，所以得给其设置一个类型，select作用是通过column中的字段要来进行什么操作 javaType=\"\" 指定属性的类型 集合中的泛型信息，我们使用ofType获取 --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher; \u003c/select\u003e \u003c/mapper\u003e 相当于是子查询，先查询出所有的学生，在通过查询出来的结果再进行一次查询。如下这种形式 select id,name,name from student where tid=(select .......); ","date":"2021-06-01","objectID":"/mybatis/:34:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.2、按照结果嵌套处理 \u003c--s.id sid相当于给其起一个别名，也就相当于数据库里面的id变成了sid--\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003c--这里是直接根据结果来返回结果的类型，再来嵌套进行查找；即相当于从结果入手，反向查询--\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 回顾M以上情况多对一查询方式： 子查询 联表查询（即第二种方法） 11、一对多 比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系 实体类： @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List\u003cStudent\u003e students; } public class Student { private int id; private String name; private int tid; } ","date":"2021-06-01","objectID":"/mybatis/:35:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.1、按照结果嵌套查询（推荐） \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname ,t.name tname ,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--集合中的泛型信息，我们使用ofType获取 这里取出来的是每一个值，取出每一个值所对应的，所以我们采用ofType--\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 注意点：一对多，对于按结果查询使用collection时，如果是取出的一个个值，则 需使用ofType来指定其类型，而不使用JavaType 而对于按查询嵌套使用collection时，我们取出的是一个集合，而不是一个个值，则需要使用JavaType来指定属性的对象类型，同时还得将泛型的信息使用ofType写上 ","date":"2021-06-01","objectID":"/mybatis/:36:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.2、按照查询嵌套处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from Teacher where id=#{tid}; \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003c--这里是相同属性名的话可以省略不用写--\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--这里所取出来的值就是一个集合，所以得写上其JavaType的类型，也就是集合的对象类型，并且里面的泛型信息也得写上--\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudent\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent\" resultType=\"Student\"\u003e \u003c--这个地方的#{id}中的id可以随意填，因为mybatis会自动去匹配，但是为了规范还是正规写--\u003e select * from Student where tid=#{id}; \u003c/select\u003e ","date":"2021-06-01","objectID":"/mybatis/:37:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.3、小结 1. 关联--assocation 【多对一】 2. 集合--collection 【一对多】 3. JavaType \u0026\u0026 ofType 1. Java Type 用来指定实体类中属性的类型 2. ofType 用来指定映射到List或者集合中的pojo类型，即泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题 如果问题不好排查错误，可以使用日志，建议使用Log4j 12、动态SQL 什么是动态SQL：动态SQL就是根据不同的条件生成不同的语句 ","date":"2021-06-01","objectID":"/mybatis/:38:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.1、搭建环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` VARCHAR(100) NOT NULL COMMENT '博客标题', `author` VARCHAR(30) NOT NULL COMMENT '博客作者', `create_time` DATETIME NOT NULL COMMENT '创建时间', `views` INT(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 创建一个基础工程 导包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c!--是否开启驼峰命名自动映射--\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 编写实体类 @Data public class Blog { private String id; private String title; private String author; private Date createTime;//属性名和字段名不一致，可以开启Setting中的驼峰命名规则 private int views; } 编写实体类对应Mapper接口和Mapper.xml文件 public interface BlogMapper { //插入数据 int addBlog(Blog blog); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.BlogMapper\"\u003e \u003cinsert id=\"addBlog\" parameterType=\"blog\"\u003e insert into mybatis.blog (id,title,author,create_time,views) values (#{id},#{title},#{author},#{createTime},#{views}); \u003c/insert\u003e \u003c/mapper\u003e 测试 @Test public void addBlogTest() { SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getId()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.close(); } ","date":"2021-06-01","objectID":"/mybatis/:39:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.2、IF \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/select\u003e @Test public void queryBlogif(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); //map.put(\"title\",\"Mybatis\"); map.put(\"author\",\"狂神说\"); List\u003cBlog\u003e blogList = mapper.queryBlogIf(map); for (Blog blog : blogList) { System.out.println(blog) ; } sqlSession.close(); } ","date":"2021-06-01","objectID":"/mybatis/:40:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.3、choose（when,otherwise） \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title=#{title} \u003c/when\u003e \u003cwhen test=\"author != null\"\u003e and author=#{author} \u003c/when\u003e \u003cotherwise\u003e and views=#{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e **注意点：**使用where的时候，当条件成立的时候where会自动去除and或者or 使用choose时，当条件成立时，只会选择一个语句进行执行，其它语句则不执行，当所有语句都不成立时，则会使用otherwise中的语句；类似与switch-case，执行一个case后面有break，执行完就跳出 ","date":"2021-06-01","objectID":"/mybatis/:41:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.4、trim(where，set) \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e \u003cupdate id=\"updateBlog\" parameterType=\"map\"\u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title=#{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author=#{author} \u003c/if\u003e \u003c/set\u003e where id =#{id} \u003c/update\u003e set元素会动态前置SET关键字，同时也会删掉无关的逗号 所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 ","date":"2021-06-01","objectID":"/mybatis/:42:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.5、SQL片段 有时候，我们可能会将一些功能的部分抽取出来，方便复用 使用SQL标签抽取公共的部分 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项： 最好基于单表来定义SQL片段（如果是多表查询会让其效率变低，公共部分的拼接就会很复杂） 不要存在where标签 ","date":"2021-06-01","objectID":"/mybatis/:43:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.6、Foreach \u003c!-- 这个地方我们在使用foreach时，是遍历的一个集合，而我们传递的参数为map，所有我们的map中可以存在一个集合 item：从集合中遍历出来的值,也就是传到#{}中的值 separator：中间的分隔符 --\u003e \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"\u003e id=#{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 13、缓存（了解） ","date":"2021-06-01","objectID":"/mybatis/:44:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.1、简介 查询---\u003e连接数据库，耗资源 一次查询的结果，给它暂存到一个可以直接取值的地方！--\u003e内存：缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存 经常查询并且不经常改变的数据【可以使用缓存】 不经常查询并且经常改变的数据【不可以使用缓存】 ","date":"2021-06-01","objectID":"/mybatis/:45:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存。缓存可以极大的提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定于了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-06-01","objectID":"/mybatis/:46:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.3、一级缓存 以及缓存也叫本地缓存：SqlSession就是一个一级缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Sqlsession中查询两次相同的记录 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); System.out.println(\"================\"); User user1 = mapper.queryUserById(1); System.out.println(user1); System.out.println(user==user1); sqlSession.close(); } 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 小结：一级缓存默认是开启的，只在一次Sqlsession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个map ","date":"2021-06-01","objectID":"/mybatis/:47:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会存放在自己对应的缓存（map）中 步骤： 开启全局缓存 \u003c!--开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在要使用二级缓存的Mapper中开启 \u003c!--开启二级缓存--\u003e \u003ccache/\u003e 也可以自定义参数 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题：当我们没有设置策略时，我们需要将实体类实例化！否则就会报错 Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ ","date":"2021-06-01","objectID":"/mybatis/:48:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.5、缓存原理 缓存顺序： 先看二级缓存中有没有 再看一级缓存中有没有 两个都没有，再去查数据库 ","date":"2021-06-01","objectID":"/mybatis/:49:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.6、自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用Ehcache步骤 先导包 \u003c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.caches\u003c/groupId\u003e \u003cartifactId\u003emybatis-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.2.1\u003c/version\u003e \u003c/dependency\u003e 在mapper中指定使用我们的ahcache缓存实现 \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/\u003e ehcache.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"\u003e \u003cdiskStore path=\"./tmpdir/Tmp_EhCache\"/\u003e \u003cdefaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003ccache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003c/ehcache\u003e ","date":"2021-06-01","objectID":"/mybatis/:50:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Docker"],"content":"docker","date":"2021-06-01","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-06-01","objectID":"/docker/:0:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-06-01","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-06-01","objectID":"/docker/:2:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 ","date":"2021-06-01","objectID":"/docker/:3:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 ","date":"2021-06-01","objectID":"/docker/:3:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 ","date":"2021-06-01","objectID":"/docker/:3:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-06-01","objectID":"/docker/:3:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 ","date":"2021-06-01","objectID":"/docker/:4:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 ","date":"2021-06-01","objectID":"/docker/:4:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 ","date":"2021-06-01","objectID":"/docker/:4:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 ","date":"2021-06-01","objectID":"/docker/:4:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Centos安装 https://docs.docker.com/engine/install/centos/ ","date":"2021-06-01","objectID":"/docker/:4:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine ","date":"2021-06-01","objectID":"/docker/:4:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils ","date":"2021-06-01","objectID":"/docker/:4:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 ","date":"2021-06-01","objectID":"/docker/:4:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ ","date":"2021-06-01","objectID":"/docker/:4:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images ","date":"2021-06-01","objectID":"/docker/:4:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 ","date":"2021-06-01","objectID":"/docker/:4:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-06-01","objectID":"/docker/:4:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是真么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-06-01","objectID":"/docker/:5:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 ","date":"2021-06-01","objectID":"/docker/:6:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 ","date":"2021-06-01","objectID":"/docker/:6:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 ","date":"2021-06-01","objectID":"/docker/:6:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，编程了centos的id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minutes stoic_wilson edbd9366d959 centos \"/bin/bash\" 35 minutes ago Up 35 minutes affectionate_bartik 9939864fa2e6 centos \"bin/bash\" 48 minutes ago Exited (0) 48 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 52 minutes ago Exited (0) 49 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 20 hours ago Exited (0) 20 hours ago gracious_bhabha [root@192 ~]# docker rm 5f42e9930435 5f42e9930435 [root@192 ~]# docker rm edbd9366d959 # 注意正在运行的容器不能删除 Error response from daemon: You cannot remove a running container edbd9366d9596c744dd449119269b04de2f2a494e7fc471f6396bcefd94c33fe. Stop the container before attempting removal or force remove [root@192 ~]# docker ps -aq # 所有容器id bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d [root@192 ~]# docker rm -f $(docker ps -aq) # 全部删除 bfcea13c40cd edbd9366d959 9939864fa2e6 a89ddb393d3d 启动和停止容器的操作 docker start docker restart docker stop docker kill [root@192 ~]# docker run -it centos /bin/bash [root@7b1a7dd10ea4 /]# exit exit [root@192 ~]# docker ps #查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a # 查看历史运行过的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 54 seconds ago Exited (0) 42 seconds ago fervent_mirzakhani [root@192 ~]# docker start 7b1a7dd10ea4 # 启动当前这个容器 container id 粘过 来 7b1a7dd10ea4 [root@192 ~]# docker ps # 查看当前运行容器 发现启动成功 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 7b1a7dd10ea4 centos \"/bin/bash\" 2 minutes ago Up 28 seconds fervent_mirzakhani [root@192 ~]# docker stop 7b1a7dd10ea4 # 停止运行 7b1a7dd10ea4 [root@192 ~]# docker ps # 再次查看 没有这个容器了 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES ","date":"2021-06-01","objectID":"/docker/:6:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"常用其他命令 后台启动docker docker run -d 镜像名 # 用docker ps 查看的时候 发现停止了 # 后台运行，docker发现前台没有，容器启动后，发现自己没有提供服务，会立刻停止 Last login: Wed Jun 17 19:47:35 2020 [root@192 ~]# systemctl start docker # 关机后重启了，需要启动docker [root@192 ~]# docker run -d centos # 运行 8ce188e5fee31c2fac93c0a405ee1a95c38dbc50cb47c35b19c0039c27558ded [root@192 ~]# docker ps -a # 查看正在运行的 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8ce188e5fee3 centos \"/bin/bash\" 19 seconds ago Exited (0) 18 seconds ago tender_dirac 7b1a7dd10ea4 centos \"/bin/bash\" 8 hours ago Exited (0) 8 hours ago fervent_mirzakhani 查看日志 docker logs # -tf #显示日志 #--tail number # 要显示日志条数 docker logs -f -t --tail n 【id】 [root@192 ~]# docker logs --help Usage: docker logs [OPTIONS] CONTAINER Fetch the logs of a container Options: --details Show extra details provided to logs -f, --follow Follow log output --since string Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) --tail string Number of lines to show from the end of the logs (default \"all\") -t, --timestamps Show timestamps # 时间戳 --until string Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes) # 自己编写的一个脚本 whiel true;do echo shenzai;sleep # 运行一个 [root@192 ~]# docker run -it centos /bin/bash [root@c2887d35c71d /]# [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES c2887d35c71d centos \"/bin/bash\" 57 seconds ago Up 56 seconds vigorous_kare # 查看日志，由于没有运行脚本，所以啥也没显示 [root@192 ~]# docker logs -f -t --tail 10 c2887d35c71d ^C # ctrl+c退出 # 运行centos里面加个脚本 [root@192 ~]# docker run -d centos /bin/sh -c \"while true;do echo shenzai;sleep 1;done\" cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388 [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb6d7fbc3f27 centos \"/bin/sh -c 'while t…\" 7 seconds ago Up 6 seconds dreamy_almeida c2887d35c71d centos \"/bin/bash\" 3 minutes ago Up 3 minutes vigorous_kare # 查看日志 发现隔一秒打印一条 [root@192 ~]# docker logs -f -t --tail 10 cb6d7fbc3f27 2020-06-17T12:02:11.293765084Z shenzai 2020-06-17T12:02:12.297675608Z shenzai 2020-06-17T12:02:13.301845582Z shenzai 2020-06-17T12:02:14.304800996Z shenzai 2020-06-17T12:02:15.307130238Z shenzai 2020-06-17T12:02:16.310574235Z shenzai 2020-06-17T12:02:17.312946923Z shenzai 2020-06-17T12:02:18.314841295Z shenzai 2020-06-17T12:02:19.317021705Z shenzai 2020-06-17T12:02:20.319670013Z shenzai 2020-06-17T12:02:21.322651649Z shenzai 2020-06-17T12:02:22.325466918Z shenzai 2020-06-17T12:02:23.327984704Z shenzai 2020-06-17T12:02:24.329656919Z shenzai 查看容器中进程信息 # 命令 docker top 容器id # UID：当前用户id PID：父id PPID：进程ID UID PID PPID C STIME root 1424 31183 0 15:13 root 31183 31163 0 14:50 查看正在镜像的元数据 # 命令 docker inspect 容器id [root@192 ~]# docker inspect cb6d7fbc3f27 [ { # 容器的完整id \"Id\": \"cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388\", # 创建时间 \"Created\": \"2020-06-17T12:00:50.706906186Z\", # 脚本位置 \"Path\": \"/bin/sh\", # 运行的脚本 \"Args\": [ \"-c\", \"while true;do echo shenzai;sleep 1;done\" ], \"State\": { \"Status\": \"running\", # 状态，正在运行 \"Running\": true, \"Paused\": false, \"Restarting\": false, \"OOMKilled\": false, \"Dead\": false, \"Pid\": 1909, # 父进程id \"ExitCode\": 0, \"Error\": \"\", \"StartedAt\": \"2020-06-17T12:00:51.093617477Z\", \"FinishedAt\": \"0001-01-01T00:00:00Z\" }, # 镜像来源 \"Image\": \"sha256:831691599b88ad6cc2a4abbd0e89661a121aff14cfa289ad840fd3946f274f1f\", \"ResolvConfPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/resolv.conf\", \"HostnamePath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hostname\", \"HostsPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/hosts\", \"LogPath\": \"/var/lib/docker/containers/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388/cb6d7fbc3f27a064137d58282de97b97365dea2705211ebfbad642079cc1b388-json.log\", \"Name\": \"/dreamy_almeida\", \"RestartCount\": 0, \"Driver\": \"overlay2\", \"Platform\": \"linux\", \"Mou","date":"2021-06-01","objectID":"/docker/:6:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"可视化 portainer(先用这个) Rancher(CI/CD时用) portainer Docker图像化界面管理工具，提供一个后台面板供我们操作！ docker run -d -p 8088:9000 --restart=always -v /var/run/docker.sock:/var/run/docker --privileged=true portainer/portainer 访问外网8088 用户名 密码 【中午吃饭重连了一下，失败，不知道发生了啥】 【平时不会用这个，好吧，先往下】 ","date":"2021-06-01","objectID":"/docker/:6:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 ","date":"2021-06-01","objectID":"/docker/:7:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 ","date":"2021-06-01","objectID":"/docker/:7:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-06-01","objectID":"/docker/:7:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 ","date":"2021-06-01","objectID":"/docker/:8:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 ","date":"2021-06-01","objectID":"/docker/:8:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 ","date":"2021-06-01","objectID":"/docker/:8:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 ","date":"2021-06-01","objectID":"/docker/:8:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"具名和匿名挂载 ","date":"2021-06-01","objectID":"/docker/:8:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 ","date":"2021-06-01","objectID":"/docker/:8:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-06-01","objectID":"/docker/:8:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 ","date":"2021-06-01","objectID":"/docker/:9:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 ","date":"2021-06-01","objectID":"/docker/:9:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 *#*表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ ","date":"2021-06-01","objectID":"/docker/:9:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile命令 ","date":"2021-06-01","objectID":"/docker/:9:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":" FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 ","date":"2021-06-01","objectID":"/docker/:9:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 ","date":"2021-06-01","objectID":"/docker/:9:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 ","date":"2021-06-01","objectID":"/docker/:9:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包：https://blog.csdn.net/doupeihua/article/details/51831947 tomcat压缩包：https://tomcat.apache.org/download-90.cgi 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html ","date":"2021-06-01","objectID":"/docker/:9:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the password from stdin -u, --username string Username [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login -u cloverfelix Password: WARNING! Your password will be stored unencrypted in /root/.docker/config.json. Configure a credential helper to remove this warning. See https://docs.docker.com/engine/reference/commandline/login/#credentials-store Login Succeeded [root@iZ2zejeormv0s24sdvazvxZ ~]# 4、登录完毕后就可以提交镜像了，就是一步 docker push # push到自己的镜像到服务器上 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker push divtomcat Using default tag: latest The push refers to repository [docker.io/library/divtomcat] b23ff398b23f: Preparing e0403d0b82a9: Preparing d252d00ff518: Preparing 537a66dda3f7: Preparing 2653d992f4ef: Preparing denied: requested access to the resource is denied # push请求被拒绝了 [root@iZ2zejeormv0s24sdvazvxZ ~]# push上去的时候一定记得带上版本号 ","date":"2021-06-01","objectID":"/docker/:9:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"小结： ","date":"2021-06-01","objectID":"/docker/:9:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 ","date":"2021-06-01","objectID":"/docker/:10:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们没每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是**–link**技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：–link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用-link了！ 使用的都是自定义网络！不适用docker0！ docker0问题：它不支持容器名连接访问！ ","date":"2021-06-01","objectID":"/docker/:10:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network ls NETWORK ID NAME DRIVER SCOPE e3ed9ad5b74b bridge bridge local 51f1bd18d34e host host local f833096b830f mynet bridge local bb8aa0300ba6 none null local 我们自己的网络就创建好了 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-01 tomcat 7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --net mynet --name tomcat-net-02 tomcat 11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network inspect mynet [ { \"Name\": \"mynet\", \"Id\": \"f833096b830f85a24a3fe4d1f4e9e0cc9f5327bc8a0059ec9577d600fb54b111\", \"Created\": \"2021-02-03T00:17:44.277900481+08:00\", \"Scope\": \"local\", \"Driver\": \"bridge\", \"EnableIPv6\": false, \"IPAM\": { \"Driver\": \"default\", \"Options\": {}, \"Config\": [ { \"Subnet\": \"192.168.0.0/16\", \"Gateway\": \"192.168.0.1\" } ] }, \"Internal\": false, \"Attachable\": false, \"Ingress\": false, \"ConfigFrom\": { \"Network\": \"\" }, \"ConfigOnly\": false, \"Containers\": { \"11795f8616ff8b5df0bc172fc4f67c68d30ead31442dfd812f1d09959ab0600c\": { \"Name\": \"tomcat-net-02\", \"EndpointID\": \"1b542176401a508f905acbb09ab2d07c45c3280e6f60e66428a565766470b46e\", \"MacAddress\": \"02:42:c0:a8:00:03\", \"IPv4Address\": \"192.168.0.3/16\", \"IPv6Address\": \"\" }, \"7904d3327a0c8c7f32e43c0611aeecf97f5b1ae9878957c3a09aae53c8c262bb\": { \"Name\": \"tomcat-net-01\", \"EndpointID\": \"872b36e9c2a5d9f59a2931e1edad34c3eded6d693c3fef830e29bcdae511b4d9\", \"MacAddress\": \"02:42:c0:a8:00:02\", \"IPv4Address\": \"192.168.0.2/16\", \"IPv6Address\": \"\" } }, \"Options\": {}, \"Labels\": {} } ] # 再次测试ping连接 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.3 PING 192.168.0.3 (192.168.0.3) 56(84) bytes of data. 64 bytes from 192.168.0.3: icmp_seq=1 ttl=64 time=0.121 ms 64 bytes from 192.168.0.3: icmp_seq=2 ttl=64 time=0.096 ms 64 bytes from 192.168.0.3: icmp_seq=3 ttl=64 time=0.100 ms --- 192.168.0.3 ping statistics --- 3 packets transmitted, 3 received, 0% packet loss, time 1001ms rtt min/avg/max/mdev = 0.096/0.105/0.121/0.016 ms #现在不使用--link也可以ping名字了！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping tomcat-net-02 PING tomcat-net-02 (192.168.0.3) 56(84) bytes of data. 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.069 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.099 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.103 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.093 ms 64 bytes from tomcat-net-02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.100 ms --- tomcat-net-02 ping statistics --- 5 packets transmitted, 5 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.069/0.092/0.103/0.017 ms 结论：我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络 好处： redis - 不同的集群使用不同的网络，保证集群是安全和健康的 mysql - 不同的集群使用不同的网络，保证集群是安全和健康的 ","date":"2021-06-01","objectID":"/docker/:10:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"网络连通 # 测试打通 tomcat01 到 mynet # 连通之后就是将我们的 tomcat01 加到 mynet网络下 # 一个容器两个ip地址 #阿里云服务器： 一个公网 一个私网地址 # tomcat01 可以与 tomcat-net-01 连通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat-net-01 ping 192.168.0.4 PING 192.168.0.4 (192.168.0.4) 56(84) bytes of data. 64 bytes from 192.168.0.4: icmp_seq=1 ttl=64 time=0.134 ms 64 bytes from 192.168.0.4: icmp_seq=2 ttl=64 time=0.095 ms 64 bytes from 192.168.0.4: icmp_seq=3 ttl=64 time=0.097 ms 64 bytes from 192.168.0.4: icmp_seq=4 ttl=64 time=0.096 ms ^C --- 192.168.0.4 ping statistics --- 4 packets transmitted, 4 received, 0% packet loss, time 1002ms rtt min/avg/max/mdev = 0.095/0.105/0.134/0.019 ms # tomcat02 与 tomcat-net-01依旧打不通 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat-net-01 ping: tomcat-net-01: Name or service not known 结论：假设要跨网络操作别人，就需要使用docker network connect 连通！ ","date":"2021-06-01","objectID":"/docker/:10:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"实战：部署Redis集群 ","date":"2021-06-01","objectID":"/docker/:10:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-06-01","objectID":"/docker/:11:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-06-01","objectID":"/docker/:12:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-06-01","objectID":"/docker/:13:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-06-01","objectID":"/docker/:14:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug ","date":"2021-06-01","objectID":"/docker/:15:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-06-01","objectID":"/docker/:15:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Test"],"content":"test","date":"2021-06-01","objectID":"/first/","tags":["Test"],"title":"Springboot","uri":"/first/"},{"categories":["SpringBoot"],"content":"springboot","date":"2021-06-01","objectID":"/springboot/","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["Spring"],"content":"spring","date":"2021-06-01","objectID":"/spring/","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.Spring ","date":"2021-06-01","objectID":"/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.1 简介 下载spring所有版本信息的地址入口：https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/spring-framework-reference/ 下载spring所有版本信息的地址：http://repo.spring.io/release/org/springframework/spring github：https://github.com/spring-projects/spring-framework 导入spring-webmvc，可以快速一次性导入所有java包） \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.0.RELEASE\u003c/version\u003e \u003c/dependency\u003e 导入spring web jdbc \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-06-01","objectID":"/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.2 优点 开源的免费容器 轻量级，非入侵式的框架（引入不会对原来的代码产生任何影响） 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持 spring就是一个轻量级的控制反转和面向切面编程的框架 ","date":"2021-06-01","objectID":"/spring/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.3 组成 ","date":"2021-06-01","objectID":"/spring/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.4 学习路线 SpringBoot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 要先学Spring和SpringMVC SpringCloud 基于SpringBoot实现的 2.坑 多态父类实现子类独有的方法需要向下强转 public static void main(String[] args){} 可以由快捷键psvm加回车打出来 无参构造函数，只要一new就会执行 只要有new一定要写在main方法里 3.IOC DI ","date":"2021-06-01","objectID":"/spring/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.1 理论推导（依赖注入：set注入） //利用set进行动态实现值的注入 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } 之前程序是主动创建对象！控制权在程序员手上 使用set注入后，程序不再具有主动性，而是变成了被动的接受对象 这种思想从本质上解决了问题，我们程序员不用再去管理对象的创建了 ","date":"2021-06-01","objectID":"/spring/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.2 IOC本质 是一种通过描述（XML或注解）并通过第三方生产或获取特定对象的方式，在spring中实现控制反转的是Ioc容器，其实现方法是依赖注入（DI） ","date":"2021-06-01","objectID":"/spring/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.3 IOC容器(控制反转) 配置文件 xml中的bean标签就是一个对象，把类用bean标签添加在配置文件中，就相当于：类名 变量名=new 类名()，而标签中的id就是变量名，class就等于new的对象。所以myHello就是一个Hello类对象。这里的对象是由spring创建的，而不是java new出来的。 property相当于给对象中的基本数据类型的属性设置一个值（注意！！！，类中一定要有：set属性名(参数类型 参数值){this.属性名=参数值} 这个方法 \u003cbean id=\"myHello\" class=\"com.kua.pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"spring\"/\u003e \u003c/bean\u003e property如果要给对象中的对象数据设置值，那就是\u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e其中name表示对象属性名，表示引用spring中创建好的对象 \u003cbean id=\"myServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e \u003c/bean\u003e 初始化时，先读取配置文件，获得spring的上下文对象（固定语句不可变） ApplicationContext context=new ClassPathXmlApplicationContext(\"bean.xml\");//这里的bean.xml是配置文件名 通过上下文对象context的getBean方法从Ioc容器中直接取出对象 Hello myHello=(Hello)context.getBean(\"hello\"); ","date":"2021-06-01","objectID":"/spring/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.4 IOC综合 控制：谁来控制对象的创建，传统的应用程序是由程序本身来控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：利用set方法进行注入 IOC编程思想：由主动编程，变成被动接收，对象由Spring来创建，管理，装配 ","date":"2021-06-01","objectID":"/spring/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.5 IOC创建对象的方式（依赖注入：构造器注入） 使用构造器方式注入可以不写set 使用无参构造创建对象（默认的） 如果要用有参构造函数创建对象 方式一：下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e index表示参数的下标，value表示给参数赋值 方式二：匹配参数类型（不建议使用） \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e 注意：基本类型可以直接写，但是引用类型如：String得写全名 方式三：直接通过参数名 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e ","date":"2021-06-01","objectID":"/spring/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.6 IOC初始化对象的时间 在new ClassPathXmlApplicationContext，即加载完配置文件后就已经初始化好了所有bean对象，然后你需要getBean谁就取谁 4.Spring配置 ","date":"2021-06-01","objectID":"/spring/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"4.1 Spring配置 alias，给bean对象取别名（一对一） 给容器中的东西取别名 \u003calias name=\"user\" alias=\"user2\"/\u003e bean配置 id：bean的唯一标识符 class：bean对象所对应的全限定名（包+类） name：给bean对象取别名，可以同时取多个别名，中间可以用逗号、空格、分号隔开 import：一般用于团队开发使用，他可以将多个文件导入合并为一个 用import可以导入这个模块的其他bean文件，合并为一个总的，然后通过总的xml文件可以取到所有导入的bean里面的东西，如果不同bean中有相同的配置，但是配置的值不同，则下面的xml文件会覆盖上面的 5.DI依赖注入之set注入 ","date":"2021-06-01","objectID":"/spring/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"5.1、依赖注入之set注入 依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性值由容器注入 复杂类型： public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 真实测试对象： public class Student { private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003e card; private Set\u003cString\u003e games; private String wife; private Properties info; } bean4.xml \u003cbean id=\"adress\" class=\"com.kuang.pojo.Address\"/\u003e \u003cbean id=\"student\" class=\"com.kuang.pojo.Student\"\u003e \u003c!-- 普通值注入,value--\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c!-- bean注入，ref--\u003e \u003cproperty name=\"address\" ref=\"adress\"/\u003e \u003c!-- 数组注入--\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!-- List注入--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e打篮球\u003c/value\u003e \u003cvalue\u003e看剧\u003c/value\u003e \u003cvalue\u003e敲代码\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- Map注入--\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"学号\" value=\"2918378\"/\u003e \u003centry key=\"身份证\" value=\"2917321\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- Set注入--\u003e \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003e找你妹\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- null--\u003e \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c!-- Properties配置类型--\u003e \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"学号\"\u003e21342\u003c/prop\u003e \u003cprop key=\"性别\"\u003e女\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e 测试类： ApplicationContext context=new ClassPathXmlApplicationContext(\"bean4.xml\"); Student student=(Student) context.getBean(\"student\"); System.out.println(student.toString()); 6.导入test测试包（junit） ","date":"2021-06-01","objectID":"/spring/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"6.1、导入test测试包 \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.7.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 然后在测试类中@Test，这样在测试类中写出的方法，会自动被执行 7.c命名和p命名空间注入 ","date":"2021-06-01","objectID":"/spring/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"7.1、命名空间 p命名空间的注入，可以直接注入属性的值：property（本质还是set注入） 前提： 导入约束xmlns:p=“http://www.springframework.org/schema/p\" 要有set方法 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" p:age=\"18\" p:name=\"yzq\"/\u003e 可以直接在bean标签内注入属性的值 如果是注入对象则： 导入junit，并在测试文件中@Test（插曲） c命名空间（本质是构造器注入） 前提： 导入约束 要有set方法 必须要有无参构造函数和有参构造函数两种 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\"/\u003e 测试： @Test public void test2(){ ApplicationContext context=new ClassPathXmlApplicationContext(\"beans4.xml\"); User user=context.getBean(\"user\",User.class); System.out.println(user); }; 8.Bean Scopes（bean作用域） ","date":"2021-06-01","objectID":"/spring/:14:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"8.1、bean作用域 单例模式singleton（Spring默认机制） 对象只有一个，不管从相同的bean对象中getBean多少个对象，都是表示同一个对象，如下：输出true 用法：在bean的后面加上scope=“singleton”，也可以不加，因为这种作用域是spring默认的 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\" scope=\"singleton\"/\u003e User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 原型模式prototype 用法：scope=“prototype” 每次从容器中get时都会产生新对象，每个对象都不一样 User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 输入false 其他四个只能在web开发中使用 9.bean的自动装配（Autowired） ","date":"2021-06-01","objectID":"/spring/:15:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"9.1、bean自动装配 Spring会在上下文中自动寻找，并自动给bean装配属性，只针对bean对象 在Spring中有三种装配方式： 在xml中显示的配置 在java中显示的配置 隐式的自动装配bean（重要） 自动装配就是：可以不用在bean中自己手动装备bean对象的属性 用法：用autowired=““实现 People.java public void setCat(Cat cat) { this.cat = cat; } public void setDog(Dog dog) { this.dog = dog; } bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c/bean\u003e byName表示在容器上下文中查找和自己set方法后面的值对应的beanid，弊端：名字必须相同 byType表示在容器上下文中查找和自己set方法中对象类型相同的对应的beanid，都可以省略id。弊端：容器中所有bean的class唯一，即只有一个对象，如下就会报错 \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byType\"\u003e 10.使用注解实现自动装配 ","date":"2021-06-01","objectID":"/spring/:16:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.1 @Autowired 可以删掉set方法，但是需要get方法！！！ 前提：只针对bean对象，通过byType方式实现，如果有多个对象，就通过byName方式实现 导入约束 xmlns:context=\"http://www.springframework.org/schema/context\" 配置注解的支持 \u003c!--所有注解驱动--\u003e \u003ccontext:annotation-config/\u003e 容器中和.java中的名字要相同 使用： 在配置文件中注入所有你要自动装配的对象，然后直接在属性上面或者set方法上面使用@Autowired bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\"/\u003e People.java @Autowired private Cat cat; @Autowired private Dog dog; 也可以放在set方法上面 ","date":"2021-06-01","objectID":"/spring/:17:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.2 @Nullable(拓展) 如果显示定义@Autowired的require属性为false，那么那个对象的属性值为null也不会报错（但是完全没有定义，只有声明，就会报错） 与这有相同效果的是@Nullable，用法：在构造函数的形参前面 public People(@Nullable String name) { this.name = name; } ","date":"2021-06-01","objectID":"/spring/:18:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.3 @Qualifier 当容器中和.java中的对象名字和类型都不匹配时，这时@Autowired就没办法用，但如果又想要自动匹配，就可以使用@Qualifier(value=\"\")实现名字匹配 \u003cbean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e @Autowired @Qualifier(value=\"dog1\") private Dog dog; 但是可能在运行前要去maven里clean一下，再运行 ","date":"2021-06-01","objectID":"/spring/:19:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.4 @Resource 以上三种都是Spring注解，这一个是java注解 @Resource与@Autowired用法一样，但是@Resource先通过byName，再通过byType 当名字和类型都不匹配时：加一个name属性可以指定名字匹配 @Resource(name=\"\") ","date":"2021-06-01","objectID":"/spring/:20:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.5 @Component 见11的第2条的方法二 ","date":"2021-06-01","objectID":"/spring/:21:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.6 @Scope 见11的第5条 11.使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入，所以出错时检查这个包有没有问题 导入约束 增加支持 bean 属性如何注入（开启注解的支持） 方法一： 注解驱动 \u003ccontext:annotation-config/\u003e 方法二： 指定包中的全部注解都生效 \u003ccontext:component-scan base-package=\"com.kuang.pojo\"/\u003e 用@Component注解： 放在类上面，表示 这个类被Spring管理了，就是一个bean，而@Value就相当于bean中的property，给属性注入值，@Value也可以放在set方法上面 //相当于在配置文件中 //\u003cbean id=\"user\" class=\"com.kuang.pojo.User\" /\u003e @Component public class User { @Value(\"yzq\") private String name; } 衍生的注解 @Component有几个衍生注解，在web开发中，会按照mvc三层架构分层 poji层：@Component dao层：@Repository service层：@Service controller层：@Controller 这四个注解功能一样，都是讲某个类注入到容器中 自动装配置 以上所有注解 作用域 也可以使用注解：@Scope(“作用域类型”)，也是放在类上面的 @Component @Scope(\"prototype\") public class User{ } 小结 xml和注解： xml更加万能，适用于任何场所|维护简单方便 注解：不是自己的类使用不了，维护复杂，因为每个不同的类的注解是独立的 xml与注解最佳实践 xml用来管理bean 注解只负责完成属性的注入 注意：一定要开启注解的支持 12.使用java方式配置Spring ","date":"2021-06-01","objectID":"/spring/:22:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.1 用@Configuration配置过程 写一个类作为配置类，将@Configuration放在类上面，@Bean放在一个返回类的方法里面 @Configuration代表最这是一个配置类，和之前的bean.xml是一样的，本身也会被spring容器托管，注册到容器中，因为他本来就是一个@Component @Bean代表bean，哪个类的bean就写一个返回类的方法，然后bean的id就是方法的方法名 配置类： @Configuration public class myConfig { @Bean public User getUser(){ //返回要注入到bean中的对象 return new User(); } } 给bean中的属性注入值 @Value(\"yzq\") private String name; public String getName() { return name; } 测试类：注意是用的AnnotationConfigApplicationContext实现类，因为没有配置文件xml了，完全是用java+注解配置的，实参是写的配置类，bean的id名是配置类中的方法名 ApplicationContext context = new AnnotationConfigApplicationContext(myConfig.class); User getUser=(User) context.getBean(\"getUser\"); System.out.println(getUser.getName()); ","date":"2021-06-01","objectID":"/spring/:23:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.2 @Configuration扫描 也可以显示的扫描包 @Configuration //包中所有注解都生效 @ComponentScan(\"com.kuang.pojo\") public class myConfig { @Bean public User getUser(){ return new User(); } } 因为肯定有多个bean，所以就根据几个bean创建几个java配置类，然后每个类上面都加上@Configuration，代表这是一个配置类但是要把这么多bean整合到一起，就要使用@Import(其他配置类名.class) 13.代理模式 ","date":"2021-06-01","objectID":"/spring/:24:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.1 代理模式 ​ 为什么学习代理模式？ ​ 因为这是SpringAOP的底层 ","date":"2021-06-01","objectID":"/spring/:25:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.2 静态代理 角色分析： 抽象角色（租房）：一般会使用接口或者抽象类来解决 public interface rent { public void rent(); } 真实角色（房东）：被代理的角色 public void rent(){ System.out.println(\"房东要出租房子\"); }; 代理角色（中介）：代理真实角色，代理真实角色后，一般会做一些附属操作（代理角色自己的方法） public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent(){ host.rent(); hetong(); see(); fee(); } public void hetong(){ System.out.println(\"中介带你签合同\"); } public void see(){ System.out.println(\"中介带你看房\"); } public void fee(){ System.out.println(\"中介带你付费\"); } } 客户（我）：访问代理对象的人 public class Client { public static void main(String[] args) { //房东只租房子 Host host =new Host(); //代理出来租房子还有一些附属操作 Proxy proxy=new Proxy(host); //不用面对房东，直接找中介即可 proxy.rent(); } } 好处： 可以使真实角色操作更纯粹，不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工 公共业务发生拓展时，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率低 ","date":"2021-06-01","objectID":"/spring/:26:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.3 静态代理再理解 抽象角色 public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色，实现增删改查四个方法 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 代理角色：现有客户需要在每次实现什么方法的时候，能够输出实现了什么方法，称为日志功能，这个时候如果去在真实角色的代码里面添加，就违反了”改动原有代码，在公司中是大忌“，所以这时候就需要代理去实现 public class UserServiceProxy { private UserServiceImpl userServiceImpl; public void setUserServiceImpl(UserServiceImpl userServiceImpl) { this.userServiceImpl = userServiceImpl; } public void add(){ log(\"add\"); userServiceImpl.add(); } public void delete(){ log(\"delete\"); userServiceImpl.delete(); } public void update(){ log(\"update\"); userServiceImpl.update(); } public void query(){ log(\"query\"); userServiceImpl.query(); } public void log(String a){ System.out.println(\"实现了\"+a+\"方法\"); } } 客户：只需要跟代理角色接触，让代理角色去调用真实角色的各种方法 public class Client { public static void main(String[] args) { UserServiceImpl userServiceImpl=new UserServiceImpl(); UserServiceProxy userServiceProxy=new UserServiceProxy(); userServiceProxy.setUserServiceImpl(userServiceImpl); userServiceProxy.add(); } } ","date":"2021-06-01","objectID":"/spring/:27:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.4 聊聊AOP AOP实现机制，就是不改变原有代码，增加代理角色，面向切面编程 ","date":"2021-06-01","objectID":"/spring/:28:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.5 动态代理详解 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口：JDK的动态代理 基于类：cglib java字节码实现（现在用的多的）：javassist，javassist是一个开源的分析、编辑和创建java字节码的类库 前提：了解两个类 Proxy类：生成动态代理实例的，提供动态代理类和实例的静态方法 InvocationHandle：调用处理程序并返回一个结果的（调用处理程序实现的接口） 接口： public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色： public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 创建代理对象的类，ProxyInvocationHandle.java： //使用这个类动态生成代理类，这个类本身不是代理类，只是处理代理过程的一个类 public class ProxyInvocationHandle implements InvocationHandler { //设置被代理的接口 //实际上就是设置实现接口的真实角色对象 public Object target; public void setTarget(Object target) { this.target = target; } //生成得到代理类 public Object getProxy(){ //参数1：实现接口的真实类的位置 //参数2：真实类 //参数3：通过什么调用的 return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果，这个invoke方法是通过反射自动调用的，在getProxy时传了一个this，里面调用了invoke。每次当代理对象调用方法时都会经过这个方法，这个方法包含了所有代理对象需要处理的业务 //参数1：动态生成的代理对象的实例 //参数2：接口的方法，和真实角色接口方法一致 //代表调用接口方法对应的Object参数数组 public Object invoke(Object o, Method method, Object[] objects) throws Throwable { //因为method是接口的方法，所以getName就可以得到方法名 log(method.getName()); Object result=method.invoke(target,objects); return result; } //如果想要增加代理类自己的方法，就直接在下面写，下面是一个实现日志功能的方法 public void log(String msg){ System.out.println(\"实现了\"+msg+\"方法\"); } } 客户： public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService=new UserServiceImpl(); //处理和生成代理角色的类 ProxyInvocationHandle pih=new ProxyInvocationHandle(); //设置要代理的对象，实际上就是真实角色对象 pih.setTarget(userService); //生成代理类,要强转成接口类型，因为动态代理的是接口 UserService proxy=(UserService) pih.getProxy(); //现在就可以让代理类处理业务了 proxy.add(); } } 输出： 好处： 静态代理的优点全有 一个动态代理类代理的是一个接口，一般就是对应的一些业务 一个动态代理类可以代理多个类，只要实现了同一个接口就可以 14.AOP ","date":"2021-06-01","objectID":"/spring/:29:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.1 了解 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的技术，在不改变原来代码的基础上实现动态的增强 ","date":"2021-06-01","objectID":"/spring/:30:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2 使用Spring实现Aop 前提：使用AOP织入，需要导入一个依赖包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-06-01","objectID":"/spring/:31:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.1 方法一：使用原生Spring API接口（JDK）默认 UserService接口 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } UserServiceImpl实现类 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); } public void delete(){ System.out.println(\"删\"); } public void update(){ System.out.println(\"改\"); } public void search(){ System.out.println(\"查\"); } } Log类：实现日志功能 public class Log implements MethodBeforeAdvice { @Override //参数method：要执行的目标对象的方法 //参数args：参数 //参数target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"类,实现了\"+method.getName()+\"方法\"); } } AfterLog类：实现方法执行后，得知返回值功能 public class AfterLog implements AfterReturningAdvice { @Override //参数returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); } } bean9.xml配置类 切入点表示要切入到哪里去，即实现接口的类中的方法要在哪里执行 \u003c!-- 注册bean--\u003e \u003cbean id=\"log\" class=\"com.kuang.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/\u003e \u003cbean id=\"userServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"/\u003e \u003c!-- 方法一:使用原生Spring API接口--\u003e \u003c!-- 配置aop：要在上面导入aop约束--\u003e \u003caop:config\u003e \u003c!-- 切入点:expression=\"execution(修饰符，返回值，类名，方法名，参数)\"--\u003e \u003c!-- * 代表任意修饰符返回值--\u003e \u003c!-- com.kuang.service.UserServiceImpl.* 表示这个类下的所有方法--\u003e \u003c!-- com.kuang.service.UserServiceImpl.*(..) 表示所有方法，(..)代表方法的任意参数--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 执行环绕增加:表示把log,afterLog类切入到上面切入点的所有方法中--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:config\u003e 测试类Test9.java public class Test9 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\"bean9.xml\"); // 因为动态代理代理的是接口 UserService userService=(UserService) context.getBean(\"userServiceImpl\"); userService.add(); } } ","date":"2021-06-01","objectID":"/spring/:31:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.2 方法二：使用自定义类（cglib） 切面表示引用哪个类，即哪个类里面有自定义的特定功能的方法，它就是一个类。切面中还要还要定义切入点（切面要引用到哪里去）和通知（是要切入切面类中的哪个方法，且切入到哪里去） 自定义切面类 public class DivPointCut { public void before(){ System.out.println(\"函数执行之前\"); } public void after(){ System.out.println(\"函数执行之后\"); } } bean9.xml \u003c!-- 方法二:使用自定义类--\u003e \u003c!-- 注入自定义切面类--\u003e \u003cbean id=\"divPointCut\" class=\"com.kuang.divPointCut.DivPointCut\"/\u003e \u003caop:config\u003e \u003c!-- 自定义切面,ref要引用的类--\u003e \u003caop:aspect ref=\"divPointCut\"\u003e \u003c!-- 切入点--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 通知:即自定义切面中的方法,且要指定在哪里调用--\u003e \u003caop:before method=\"before\" pointcut-ref=\"pointcut\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e ","date":"2021-06-01","objectID":"/spring/:31:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.3 方法三：注解实现 与方法二原理一模一样，只是将xml换成注解 AnnotationPointCut自定义切面类： 注意选的是上面那个Before注解 //此注解表示这个类是一个切面 @Aspect public class AnnotationPointCut { //此注解表示这个方法是一个通知,切入点就写在@Before内 @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"函数执行前\"); } @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"函数执行后\"); } @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") //这里的joinPoint是指连接点,和切入点类似,但是它可以从切入地方拿东西，是必要的参数 //记得一定要抛出异常 public void around(ProceedingJoinPoint jp) throws Throwable{ System.out.println(\"环绕前\"); //代表执行方法 Object proceed=jp.proceed(); System.out.println(\"环绕后\"); //连接点还可以获得签名(实际上就是执行了哪个方法)等信息 Signature signature=jp.getSignature(); System.out.println(\"签名:\"+signature); } } 配置文件 \u003c!-- 方法三:使用注解--\u003e \u003c!-- 注入自定义切面--\u003e \u003cbean id=\"annotationPointCut\" class=\"com.kuang.divPointCut.AnnotationPointCut\"/\u003e \u003c!-- 注解支持--\u003e \u003caop:aspectj-autoproxy/\u003e 运行： ","date":"2021-06-01","objectID":"/spring/:31:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2.4 小结 后面设置为false，使用JDK支持，这也是默认的 设置为true，使用cglib支持 \u003c!-- 注解支持--\u003e \u003capo:aspectj-autoproxy proxy-target-class=\"false\"/\u003e 15.整合mybatis ","date":"2021-06-01","objectID":"/spring/:31:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"15.1 回顾Mybatis Mybatis过程： 导入相关jar包 junit \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e mysql \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e mybatis \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e spring-webmvc \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e spring-jdbc \u003c!-- spring操作数据库的话,需要一个spring-jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e aspectjweaver：aop必导的包 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e mybatis-spring \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.2\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/nfmall?useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"uchr@123\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 测试 看到视频23的15:00 16.声明式事务 ","date":"2021-06-01","objectID":"/spring/:32:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"16.1 回顾事务 把一组业务当成一个业务来做，要么都成功要么都失败 涉及到数据的一致性问题 确保完整性和一致性 事务ACID原则 原子性：确保事务要么都成功要么都失败 一致性：事务完成后，要么都提交，要么就都不行，资源状态都要保持一致性 隔离性：多个业务操作同一个资源，防止数据损坏 持久性：事务一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化的写到存储器中 ","date":"2021-06-01","objectID":"/spring/:33:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["JavaWeb"],"content":"javaweb","date":"2021-06-01","objectID":"/javaweb/","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、基本概念 ","date":"2021-06-01","objectID":"/javaweb/:0:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.1、静态web 静态web存在的缺点 web页面无法更新 它无法和数据库交互（数据无法持久化，用户无法交互） ","date":"2021-06-01","objectID":"/javaweb/:1:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.2、动态web 页面会动态展示：“web的页面展示的效果因人而异” 动态web存在的缺点： 假如服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布； 动态web的优点： Web页面可以动态更新，所有用户看到的都不是同一个页面 它可以与数据库交互 2、web服务器 ","date":"2021-06-01","objectID":"/javaweb/:2:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.1、技术讲解 PHP： PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大量访问的情况 JSP/Servlet： B/S：浏览器和服务器 C/S：客户端和服务器 sun公司主推的B/S架构 基于Java语言（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响 高可用 高并发 高性能 语法像ASP ","date":"2021-06-01","objectID":"/javaweb/:3:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.2、web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息 IIS 微软的：ASP…….，Windows中自带的 Tomcat 下载tomcat： 解压 or 安装 了解配置文件以及目录结构 这个东西的作用 3、Tomcat ","date":"2021-06-01","objectID":"/javaweb/:4:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.1、安装Tomcat Tomcat官网 ","date":"2021-06-01","objectID":"/javaweb/:5:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.2、Tomcat启动和配置 文件夹的作用 访问测试：Tomcat测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 ","date":"2021-06-01","objectID":"/javaweb/:6:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.3、配置 可以配置启动的端口号 tomcat的默认端口是：8080 \u003cConnector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 可以配置主机的名称 默认主机名为：localhost—\u003e127.0.0.1 默认网站应用存放的位置：webapps \u003cHost name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"\u003e 高难度面试题： 请你谈谈网站是如何进行访问的！ 1. 输入一个域名；回车 2. 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 1. 有：直接返回对应的IP地址，这个地址中，有我们需要访问的web程序，可以直接访问 2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到 ","date":"2021-06-01","objectID":"/javaweb/:7:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.4、发布一个web网站 查看Tomcat自带的一些样例 将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 网站应有的结构 --webapps ：Tomcat服务器的web目录 --ROOT --clover ： 网站的目录名 - WEB-INF - classes ： Java程序 - lib ：web应用所有依赖的jar包 - web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img 4、Http ","date":"2021-06-01","objectID":"/javaweb/:8:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.1、什么是Http HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上 文本：html，字符串 超文本： 图片，音乐，视频，定位，地图。。。。。 默认端口：80 HTTPS：安全的 默认端口：443 ","date":"2021-06-01","objectID":"/javaweb/:9:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.2、两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，就断开连接。 http2.0 HTTP/2.0：客户端可以与web服务器连接后，可以获得多个web资源。 ","date":"2021-06-01","objectID":"/javaweb/:10:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.3、HTTP请求 客户端—发请求–服务器 1. Request URL: https://www.baidu.com/ 请求地址 2. Request Method: GET get方法/post方法 3. Status Code: 200 OK 状态码：200 4. Remote Address: 14.215.177.39:443 远程地址 ","date":"2021-06-01","objectID":"/javaweb/:11:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT get：一次请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效。 post：一次请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 ","date":"2021-06-01","objectID":"/javaweb/:11:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、消息头 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 ","date":"2021-06-01","objectID":"/javaweb/:11:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.4、HTTP响应 服务器—响应—客户端 百度： Cache-Control: private 缓存控制 Connection: keep-alive 连接 Content-Encoding: gzip 编码 Content-Type: ext/html 类型 ","date":"2021-06-01","objectID":"/javaweb/:12:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、响应体 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 Refrush：告诉客户端多久刷新一次 Location： 让网页重新定位 ","date":"2021-06-01","objectID":"/javaweb/:12:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、相应状态码 200：代表请求响应成功 3**：请求重定向 重定向：你重新到我给你的新位置去 4xx：找不到资源 资源不存在 5xx：服务器代码错误 502：网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么！ 5、Maven ","date":"2021-06-01","objectID":"/javaweb/:12:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.1、Maven项目架构管理工具 我们目前用来就是方便导入Jar包的！ Maven的核心思想：约定大于配置 有约束就不要去违反 Maven会规定好你该如何去编写我们的Java代码，必须按照这个规定来 ","date":"2021-06-01","objectID":"/javaweb/:13:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.2、配置环境变量 在系统环境变量中配置如下配置： M2_HOME maven 目录下的bin目录 MAVEN_HOME　maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 测试maven是否安装成功，必须配置完毕 ","date":"2021-06-01","objectID":"/javaweb/:14:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.3、阿里云镜像 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2021-06-01","objectID":"/javaweb/:15:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.4、本地仓库 有本地仓库，就有远程仓库！ 建立一个本地仓库：localRepository \u003clocalRepository\u003eE:\\maven repository\\.m2\\repository\u003c/localRepository\u003e ","date":"2021-06-01","objectID":"/javaweb/:16:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.5、IDEA使用Maven Maven官网：https://mvnrepository.com/ IDEAMaven自动配置问题 在IDEA中标记文件夹功能 ","date":"2021-06-01","objectID":"/javaweb/:17:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.6、配置Tomcat的问题 解决警告问题 必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹的名字 maven由于它的约定大于配置，我们之后可能遇到我们写的配置文件，无法被导出或者生效的问题。 解决方案： \u003c!--在build中配置resources，来防止我们资源导出失败的问题--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e 6、Servlet ","date":"2021-06-01","objectID":"/javaweb/:18:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.1、HelloSevlet Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建议Moudel；这个空的工程就是Maven主工程 关于Maven父子工程的理解： 父项目中会有 \u003cmodules\u003e \u003cmodule\u003eservlet-01\u003c/module\u003e \u003c/modules\u003e 子项目会有 \u003cparent\u003e \u003cartifactId\u003ejavaweb-03-servlet\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e 父项目中的Jar包子项目可以直接使用，而子项目中的jar包父项目不可以使用 Maven环境优化 修改web.xml为最新版本（可以去tomcat中的webapps里面找到） 将Maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.print(\"Hello,Servlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写Servlet映射 为什么需要映射：我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所有我们需要在web服务器中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径； \u003c!--注册Servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!-- Servlet的请求路径--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 配置tomcat 注意：配置项目的发布路径就可以了 启动测试 ","date":"2021-06-01","objectID":"/javaweb/:19:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.2、Servlet原理 Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会有如下操作： ","date":"2021-06-01","objectID":"/javaweb/:20:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.3、Mapping 一个Servlet请求可以指定一个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定多个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello5\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定通用映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\\*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 默认请求路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 指定一些后缀或者前缀等等 \u003c!--可以自定义后缀实现请求映射 注意点：*前面不能加项目映射的路径 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e*.clover\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求了 \u003c!--404--\u003e \u003cservlet\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ErrorServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 注意：在使用IDEA创建多个webapps工程时，在第二个运行可能会出现404找不到资源问题 这里是因为新创建的webapps文件上没有带蓝色点点,需要自己手动去加上，然后运行才会成功。 如若创建新的工程的pom.xml中没有parent那一行，重新创建即可 另外在创建新文件时应当先创建java跟resources两个文件夹，并且要标记，否则无法创建package ","date":"2021-06-01","objectID":"/javaweb/:21:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.4、ServletContext web容器在启动的时候，它会为每个web应用程序都创建一个对应的ServletContext对象，它代 表了当前的web应用； ","date":"2021-06-01","objectID":"/javaweb/:22:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、共享数据 我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数 很少用 // this.getServletConfig() Servlet参数 很少用 // this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = \"韋\"; context.setAttribute(\"username\",username);//将一个数据保存在了ServletContext中，名字为：username，值为：username System.out.println(\"hello\"); } } public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(\"username\"); //设置显示页面不乱码问题 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(\"名字为：\"+username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.GetServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003curl-pattern\u003e/getc\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 测试结果： ","date":"2021-06-01","objectID":"/javaweb/:22:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、获取初始化参数 \u003ccontext-param\u003e \u003cparam-name\u003eurl\u003c/param-name\u003e \u003cparam-value\u003ejdbc:mysql//localhost:3306/mybatis\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo03\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e public class ServletDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //此处获取上下文对象，获取初始化参数对应web.xml中的context-param中的参数，当你访问这个路径的时候，页面进行跳转的时候，就会获取到该路径对应的值 String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2021-06-01","objectID":"/javaweb/:22:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、请求转发 public class ServletDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); System.out.println(\"进入demo4\"); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/sd3\");//转发的请求路径 // requestDispatcher.forward(req,resp);//调用forward实现转发请求 context.getRequestDispatcher(\"/sd3\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo04\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e ","date":"2021-06-01","objectID":"/javaweb/:22:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、读取资源文件 Properties 在Java目录下新建一个properties 在resources目录下新建一个properties 发现：都打包到了同一个路径下：classes；我们俗称这个路径为classpath 思路：需要一个文件流 username=root password=123456 public class ServletDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"username\"); String pwd = properties.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pwd); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 访问测试结果： ","date":"2021-06-01","objectID":"/javaweb/:22:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.5、Request 明日任务 ","date":"2021-06-01","objectID":"/javaweb/:23:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.6、Response 明日任务 ","date":"2021-06-01","objectID":"/javaweb/:24:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["Mysql"],"content":"mysql","date":"2021-05-31","objectID":"/mysql/","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"study ","date":"2021-05-31","objectID":"/mysql/:0:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Linux"],"content":"linux","date":"2021-05-31","objectID":"/linux/","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Linux 基本使用 /bin: bin是Binary的缩写，这个目录存放着最经常使用的命令。 /boot: 这里存放的是启动Linux是使用的一些核心文件，包括一些连接文件以及镜像文件。 (不要动) /dev：dev是Device（设备）的缩写，存放的是Linux的外部设备，在Linux中访问设备的方式和文件的方式是相同的。 ==/etc==：这个目录用来存放所有的系统管理所需要的配置文件和子目录。重要 ==/home==：用户的主目录，在Linux中，每个用户都拥有一个自己的目录，一般该目录是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接库，其与Windows里的DLL文件 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（不要动，存放一些突然关机文件） /media：Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂在到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统，我们看将光驱挂载在/mnt上，然后进入该目录就可以查看光驱里面的内容了。 ==/opt==：这是给主机额外安装软件所摆放的目录。比如你安装有一个Oracle数据库，则就可以用放在这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统的信息。（不用管） /root：该目录为系统管理员，也称作超级权限这的与用户主目录。 /sbin：s就是Super User的isi，这里存放的就是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是Linux2.6内核的有一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。 /tmp：这个目录用来存放一些临时文件的。（用完即丢的文件可以放在这个目录下） ==/usr==：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下。类似与Windows下的progra files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。Super /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统同启动以来的信息。当系统重启时，这个目录下的文件一个被删掉或者清除。 Linux常用的基本命令 ","date":"2021-05-31","objectID":"/linux/:0:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"目录管理 绝对路径、相对路径 绝对路径的全称：F:\\deskBackground\\xxxx cd：切换目录命令 ./：当前目录 cd ..：退回到上一级目录 ls（列出目录） 在Linux中ls可能时最常常被使用的！ -a 参数：all，查看全部的文件，包括隐藏的文件 -l 参数：列出所有的文件，包含文件的属性和权限，没有隐藏文件 所有的Linux可以组合使用。 cd命令 切换目录 cd 目录命令（绝对路径都是以/开头，相对路径，对于当前目录该如何寻找../../） pwd显示当前用户所在的目录 mkdir 创建一个目录 白色代表文件。蓝色代表文件夹 创建一个层级目录， 要加入一个 -p rmdir 删除目录 如果要删除一个层级目录，则也需要加入一个参数 -p rmdir仅仅只能删除空的目录，如果下面存在文件，需要先删除文件，递归删除多个目录加入-p参数即可 如果删除文件夹中的内容，可以采用 rm -f 强制删除 \\-r 向下递归，不管有多少级目录，一并删除。 \\-f 直接强行删除，没有任何提示。 cp （复制文件或者目录） cp 原来的地方 新的地方 如果是重复复制一个文件会产生覆盖现象，它会提示你是否覆盖。 rm （移出文件或者目录） -f 忽略不存在的文件，不会出现警告，强制删除！ -r 递归删除目录！ -i 互动，删除询问是否删除 rm -f / 系统中所有的文件就被删除了，删库跑路就是这么操作的！ mv 移动文件或者目录！ 重命名文件 -f 强制移动 -u 只替换已经更新过的文件 ","date":"2021-05-31","objectID":"/linux/:1:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用\"d\"表示。“d\"在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： ==当为[ d ]则是目录== ==当为[ - ]则是文件；== ==若是[ l ]则表示为链接文档 ( link file )；==如Windows系统中应用的快捷方式 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，\\[ r \\]代表可读(read)、\\[ w \\]代表可写(write)、\\[ x \\]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号\\[ - \\]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用\"r\"字符表示，则有读权限，如果用\"-\"字符表示，则没有读权限； 第2、5、8位表示写权限，如果用\"w\"字符表示，则有写权限，如果用\"-\"字符表示没有写权限； 第3、6、9位表示可执行权限，如果用\"x\"字符表示，则有执行权限，如果用\"-\"字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 属主：表示属于哪一个主人 属组：表示属于哪一个组 chgrp \\[-R\\] 属组名 文件名 \\ -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown \\[–R\\] 属主名 文件名 chown \\[-R\\] 属主名：属组名 文件名 3、chmod：更改文件9个属性 ==（必须掌握）== chmod \\[-R\\] xyz 文件或目 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： - owner = rwx = 4+2+1 = 7 - group = rwx = 4+2+1 = 7 - others= --- = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ ","date":"2021-05-31","objectID":"/linux/:2:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"文件内容查看 Linux系统中使用以下命令来查看文件内容 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出tac 是 cat 的倒着写 nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容==按空格进行下翻页，enter代表像下一行看，:f查看行号== less 与 more 类似，但是比more 更好的是，它可以往前翻页！==按空格进行下翻页，上下键代表翻动页面，退出使用q命令，查找字符串 /要查找的字符串 向下查询；向上查询使用？要查询的字符串 ；n 继续搜寻下一个，N 向上寻找== head 只看头几行 ==它通过-n 参数来控制显示几行 tail 只看尾巴几行 ==也是通过-n参数来控制看那几行 可以使用man[命令]来查看各个命令的使用文档，如：man cp 网络配置目录：cd /etc/sysconfig/network-scripts/ 默认网络配置文件： Linux链接的概念（了解即可） Linux的链接分为两种：硬链接、软连接！ 硬链接：A—B，假设B是A的硬链接，那么他们两个指向了同一个文件！允许一个文件拥有多个路径，用户可通过这种机制建议硬链接到一些重要文件上，防止误删。 软链接：类似Windows下的快捷方式，删除了原文件，快捷方式也访问不了！ 创建链接 ln 命令 touch 命令创建文件 echo 输入字符串 [root@iZ8vb8plggk0dqs0rr5kzfZ /]# cd home [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 ln: failed to access ‘f1’: No such file or directory [root@iZ8vb8plggk0dqs0rr5kzfZ home]# touch f1 # 创建一个f1文件 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 f2 # 创建一个硬链接 f2 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln -s f1 f3 # 创建一个软链接 f3 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ll total 4 -rw-r--r-- 2 root root 0 May 25 20:49 f1 -rw-r--r-- 2 root root 0 May 25 20:49 f2 lrwxrwxrwx 1 root root 2 May 25 20:49 f3 -\u003e f1 drwx------ 3 www www 4096 May 9 17:03 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# echo \"yeziqi hanhan\" \u003e\u003e f1 # 给f1文件中写入一些字符串！ [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f1 # 查看f1 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 # 查看f2 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 # 查看f3 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# 删除f1之后，查看f2和f3的区别 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# rm -rf f1 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 #f2硬链接还在 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 #f3（软链接、符号链接失效）快捷方式失效 cat: f3: No such file or directory ","date":"2021-05-31","objectID":"/linux/:3:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Vim编辑器 vim通过一些插件可以实现和IDE一样的功能！ 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式！ESC！ 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： Vim按键说明 除了上面简易示范的 i ，Esc ， :wq 之外，其实vim还有非常多的按键可以使用 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键==(常用)== [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 ==(常用)== [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 数字\u003c space\u003e 那个 n 表示『数字』，例如 20 。快捷切换光标 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 ==(常用)== $ 或功能键[End] 移动到这一行的最后面字符处==(常用)== H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行==(常用)== nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！==常用)== 数字\u003c Enter\u003e 光标向下移动 n 行==(常用)== 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) ==(常用)== nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行==(常用)== ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 ==(常用)== d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行==(常用)== nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行==(常用)== y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p,P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。==(常用)== J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。==(常用)== [Ctrl]+r 重做上一个动作。==(常用)== 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i,I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。==(常用)== a,A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。==(常用)== o,O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！==(常用)== r,R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；==(常用)== [Esc] 退出编辑模式，回到一般模式中==(常用)== 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中==(常用)== :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi ==(常用)== :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 ==(常用)== ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 以上标绿的是要熟练掌握的，其余的做了解即可！ ","date":"2021-05-31","objectID":"/linux/:4:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"账号管理 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 useradd 命令 添加用户 useradd -选项 用户名 -m：自动创建这个用户的主目录–\u003e /home/用户名 参数说明： 选项 : \\-c comment 指定一段注释性描述。 \\-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 \\-g 用户组 指定用户所属的用户组。 \\-G 用户组，用户组 指定用户所属的附加组。 \\-m　使用者目录如不存在则自动建立。 \\-s Shell文件 指定用户的登录Shell。 \\-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# useradd -m wei [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls wei www 理解一下本质：Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户信息了！/etc/passwd 删除用户 userdel userdel -r wei 删除用户的时候将他的目录页一并删掉！ 修改用户 usermod 修改用户 usermod 对应修改的内容 修改的用户 usermod -d /home/test wei 在进行修改某一个用户时，也要修改其文件的时候，应当先创建要移动到的文件，否则可能当前目录不显示移动后的文件，但是在配置文件中是存在的！ ​ Linux 下如何切换用户 root用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 与用户的密码设置问题 我们一般它通过root创建用户的时候！要配置密码 Linux上输入密码时不会显示的，正常输入即可！ 在公司中，一般拿不到公司服务器的root权限，都是有一些分配的账号！ 锁定账户 root一旦冻结这个账号，这个人就登录不上系统了！ passwd -l wei #锁定之后这个用户也就不能登录了 passwd -d wei #没有密码也不能登录 ","date":"2021-05-31","objectID":"/linux/:5:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"用户组管理 属主（属于那一个主人）、属组 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发、测试、运维、root）。不同Linux 系统对用户 组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。==组的增加、删除和修改实际上就是对/etc/group文件的更新。 创建一个用户组 groupadd wei 创建完用户组后可以得到一个Id，这个Id是可以指定的！-g 520 如果不指定就是自增1 用户如果要切换用户组怎么办呢？ # 登录当前用户 wei $ newgrp root 这样转换的前提是你得需要有这个权限，否则切换不成功！ 删除用户组 groupdel groupdel wei 修改与用户组的权限信息和名字 groupmod -g：修改端口号 -n：修改用户名字 拓展；文件的查看！（了解即可） /etc/passwd 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 这个文件中的灭有一行都代表这一个用户，我们可以用从这里看出这个用户的主目录在哪里，可以看到属于哪一个组！ 登录口令：把真正的加密后的用户口令字存放到/etc/shadow文件中 用户组的所有信息都存放在/etc/group文件中 ","date":"2021-05-31","objectID":"/linux/:6:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"磁盘管理 df （列出文件系统整体的磁盘使用量） du（检查磁盘空间的使用量） df du Mac或者想要使用Linux挂载我们的ixie本地磁盘或者文件！ 挂载：使用mount命令 卸载：unmount -f [挂载位置] 强制卸载 ","date":"2021-05-31","objectID":"/linux/:7:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"进程管理 Linux中一切皆文件 ==(文件: 读、写、执行（查看，创建，删除，移动，复制，编辑），权限（用户，用户组），系统（磁盘，进程））== 什么是进程（基本概念） 在Linux中，每一个进程都是有自己的一个进程，每一个进程都有一个id号 每一个进程，都有一个父进程 进程可以拥有两种方式存在：前台！后台运行 一般的话服务都是后台运行的，基本的程序都是前台运行的！ 命令 ps 查看当前系统中正在执行的各种进程信息 ps -xxx: a 显示当前终端运行的所有进程信息(当前的进程是一个) u 以用户的信息显示进程 x 显示后台运行进程的参数! ps -aux 查看所有的进程 ps -aux |grep mysql # | 在Linux中这个叫做管道符 # grep 查找文件中符合条件的字符串(相当于过滤) 对于我们来说, 这里目前只需要记住一个命令即可 ps -xx|grep 进程名字!过滤进程信息! ps -ef: 可以查看到父进程的信息 ps -ef|grep mysql # 看父进程我们一般可以通过目录树结构来查看！ # 进程树 pstree -pu -p 显示父id -u 显示用户组 结束进程： 杀掉进程，等价与Windows结束任务 kill -9 进程的id kill -9 进程的id 表示强制结束进程 ","date":"2021-05-31","objectID":"/linux/:8:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"环境安装 安装软件有一般有三种方式： rpm（Jdk：在线发布一个SpringBoot项目） 解压缩（tomcat，启动并通过外网访问，也就是发布网站） yum在线安装（docker：直接运行跑起来docker就可以！） ","date":"2021-05-31","objectID":"/linux/:9:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"JDK安装 下载JDK rpm。去Oracle官网下载即可！ 安装Java环境 # 检测当前系统是否存在Java环境！ Java -version # 如果有的话就需要先卸载 # rpm -qa|grep jdk # 检测JDK版本信息 # rpm -e --nodeps jdk所在文件夹 # --nodeps 代表强制删除 # 卸载完毕后即可安装JDK # rpm -ivh rpm包 # 配置环境变量 配置环境变量：etc/profile在文件的最后面增加Java的配置和Windows安装环境变量一样 JAVA_HOME=/usr/java/jdk # Java根路径 CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib # 类路径文件 PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin # 环境变量文件 export PATH CLASSPATH JAVA_HOME 让这个配置文件生效！source /etc/profile 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 ","date":"2021-05-31","objectID":"/linux/:9:1","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Tomcat安装 安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 将文件移动到/usr/tomcat/下，并解压！ root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz /usr [root@kuangshen kuangshen]# cd /usr [root@kuangshen usr]# ls apache-tomcat-9.0.22.tar.gz [root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --\u003e启动tomcat # 执行：shutdown.sh --\u003e关闭tomcat ./startup.sh ./shutdown.sh 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 域名解析完毕后，如果端口是80 -http或者443 -https，可以直接访问，如果是9000 8080，就需要通过Apache或者Nginx做一下反向代理即可，配置文件即可。 ","date":"2021-05-31","objectID":"/linux/:9:2","tags":["Linux"],"title":"Linux","uri":"/linux/"}]