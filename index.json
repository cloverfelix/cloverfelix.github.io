[{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Linux部署"],"content":"Linux部署","date":"2021-07-04","objectID":"/mutinodelinux/","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"部署项目到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:0:0","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"使用的是ruoyi进行试验 ","date":"2021-07-04","objectID":"/mutinodelinux/:1:0","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"第一步 首先将项目后端的数据库以及一些配置文件配置好 数据库配置： 对于这里的数据库必须使用远程的数据库，本地数据库是不起作用的 其次就是需要在服务器上创建对应的数据库，填写相关的信息 如果你有多台服务器的话你也可以架设到不同的服务器上（但我受限只有一台服务器，就在一台服务器上实验了） 修改redis配置 由于我们的项目全部是部署在服务器上的，所以我们所依赖的环境全部是存在于服务器上 由于我们服务器上的redis是没有设置密码的，所以默认为空 修改pom.xml文件中字符集的设置 注意：由于我采用的是ruoyi的项目，不同的项目对应不同的要求，ruoyi这个项目需要你改动一下pom.xml的配置文件 将encoder对应的地方的字符集编码改为UTF-8 4.修改pom.xml文件中的日志文件logs 如果是第一次运行的话是不存在改路径的，就需要改为自己日志文件存放的路径了 如果是以及运行过的，可以忽略不看 将一些环境配置修改好后就可以运行起来了，当你运行成功后，就可以先将前端打包传送到服务器上 使用terminus工具进行上传 注意：不要使用文件夹拖拽的形式，有可能存在一些隐藏的文件夹没有传递过去 传到服务器上的home目录下自己创建的文件夹中，然后在进行文件的解压 上传成功后，就对该文件夹进行解压**（前端）** 这就是解压后的文件 解压成功后，也把后端运行好的项目压缩上传到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:2:0","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"然后开始进行前端的打包操作 安装依赖 由于我们使用的是root权限所以我们在前面加上--unsafe-perm npm install --unsafe-perm --registry=https://registry.npm.taobao.org 注意：如果你没有安装node的话是执行不了的，那你就必须得先去安装node后才可以执行，Linux上安装node的教程可以参考codesheep给的pdf上安装node的教程，只是，他最后配置node环境变量时，那个profile文件夹是存在于/etc下的profile文件夹中进行配置，而不是他pdf上所给的指令，使用pdf上的指令会提示我们没有权限 安装完依赖后就可以使用npm run build:prod打生产环境前端的包就可以了 但是在运行的过程中出现了错误信息提示 于是，我将node_modules模块删除掉了，再次运行npm install时，又有新的错误信息出现了 然后我找到一个博客找寻到了解决方法：https://blog.csdn.net/Jserm/article/details/105997504 原因是因为：For security reasons, if you run npm install as root, npm will set the user to “nobody” when running postinstall scripts, which does not have access to the project directory, thus the error message. 出于安全原因，如果您以 root 身份运行 npm install，npm 将在运行 postinstall 脚本时将用户设置为“nobody”，该脚本无权访问项目目录，因此会出现错误消息。 总结：出现这么多错误的原因是：因为之前我上传到服务器上的代码都是我之前已经运行好了，并且配置好了环境变量，已经依赖的，所以导致我上传至服务器后重复安装依赖出现错误。 所以刚才我是重新下载的一个源码直接上传到服务器上去后就直接打jar包成功了 但是，这也可能只是我的片面看法，有可能是其它的原因，是我目前所没有想到的，我暂且就将这个错误认为是我之前已经运行好的代码中有依赖环境存在，是我反复的运行没有成功，这个错误，我会在后期中再次进行验证 ","date":"2021-07-04","objectID":"/mutinodelinux/:3:0","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"现在对后端进行打jar包 前提：是服务器上装有maven环境 先去下载一个maven安装包，寻找一个3.6.x版本的maven，找到一个历史地址：https://archive.apache.org/dist/maven/maven-3/ 安装完成以后按照codesheep给的安装教程去配置环境变量，注意自己文件夹的命名与codesheep是不一样的 注意：为什么需要打jar包与war包，因为使用jar包是因为SpringBoot内置了Tomcat服务器，就可以不适用服务器上的Tomcat，而使用内置的Tomcat就行；而打war包就是不使用SpringBoot内置的Tomcat，而是使用服务器自己搭配的Tomcat服务器 将前后端打包好后，就可以将前端部署到Nginx 修改nginx配置文件 先将user改为root，以防止出现不必要的权限错误（这里指的是如果你的项目放在root目录下） 然后修改根目录下的代理，改为dist文件夹所在位置 修改配置文件夹后，切记一定要重新加载Nginx，让其重新加载配置文件，否则你就会一直报错 注意：修改完配置文件后，一定要记得将配置文件中的pid注释去掉，否则重新加载配置文件的时候就会报错，找不到pid文件 如果出现了报错就去配置文件中去除该注释，然后再次重新运行Nginx即可 如果不放心，可以使用命令行去查看进程号，出现这个就代表Nginx启动成功了 前端部署起来后就可以开始部署后端了 使用命令nohup java -jar ruoyi.jar \u0026 直接运行jar包使用后台运行的方式 但是现在前后端都运行起来了，但是没有对接起来，出现如图所示情况 所以，我们就得去nginx中的配置文件进行配置请求路径，将它的请求路径转到后端上，与之对应 location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://121.89.242.18:8081/; } 由于我部署的服务器部署到最后的时候前端连接后端一直超时，没有找到解决问题的原因，所以我暂时放置在这一步了 后续想法：搭载两台虚拟机进行再次搭建 ","date":"2021-07-04","objectID":"/mutinodelinux/:4:0","tags":["Linux部署"],"title":"MultiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Thread"],"content":"Thread","date":"2021-07-04","objectID":"/thread/","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程简介 ","date":"2021-07-04","objectID":"/thread/:1:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Process：进程 程序是指令和数据的有效集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。一个进程中可以包含若干个线程，当然一个进程中最少包含一个线程。线程是CPU调度和执行的单位。 ","date":"2021-07-04","objectID":"/thread/:1:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Thread：线程 ","date":"2021-07-04","objectID":"/thread/:1:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"两条线程是同时、交替执行的 注意，线程开启不一定立即执行，由CPU调度执行 ","date":"2021-07-04","objectID":"/thread/:1:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"方法一：继承Thread类，重写run()方法，调用start开启线程 package com.ren.lesson01; //创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由CPU调度执行 public class TestThread01 extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 TestThread01 testThread01 = new TestThread01(); //调用start()方法开启线程 testThread01.start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： 从网络上下载图片，通过一个下载器方法实现 package com.ren.lesson01; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestThread02(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public void run() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestThread02 t2 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestThread02 t3 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //这三个不是按照顺序来执行的，是同时进行，小的先完成 t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } 小结：","date":"2021-07-04","objectID":"/thread/:1:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 package com.ren.lesson01; //创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 public class TestThread03 implements Runnable{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //创建runnable接口的实现类对象 TestThread03 testThread03 = new TestThread03(); //创建线程对象，通过线程对象来开启我们的线程，代理 // Thread thread = new Thread(testThread03); // // thread.start(); new Thread(testThread03).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： package com.ren.lesson01; //多个线程同时操作同一个对象 //买火车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread04 implements Runnable{ //票数 private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums\u003c=0){ break; } //模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //Thread.currentThread().getName()获取当前线程的名称 System.out.println(Thread.currentThread().getName()+\"--\u003e拿到了第\"+ticketNums--+\"票\"); } } public static void main(String[] args) { TestThread04 ticket = new TestThread04(); new Thread(ticket,\"你\").start(); new Thread(ticket,\"我\").start(); new Thread(ticket,\"他\").start(); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程创建方式三：实现Callable接口 package com.ren.lesson02; import com.ren.lesson01.TestThread02; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; //线程创建方式三：实现Callable接口 /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ public class TestCallable implements Callable\u003cBoolean\u003e { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public Boolean call() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行(通过服务来提交我们的线程) Future\u003cBoolean\u003e r1 = ser.submit(t1); Future\u003cBoolean\u003e r2 = ser.submit(t2); Future\u003cBoolean\u003e r3 = ser.submit(t3); //获取结果（获取的结果就是线程调用了call函数所返回的结果） Boolean rs1 = r1.get(); Boolean rs2 = r1.get(); Boolean rs3 = r1.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ 结果图： ","date":"2021-07-04","objectID":"/thread/:1:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"静态代理 使用结婚这个例子来阐述，可以将其与线程进行比较 package com.ren.lesson02; /** * 静态代理模式总结： * 真实对象（目标对象）和代理对象都要实现同一个接口 * 代理对象要代理真实角色 * 好处：代理对象可以做很多真实对象做不了的事情 * 真实对象专注做自己的事情 */ public class StaticProxy { public static void main(String[] args) { You you = new You(); //将其与多线程对比 /** * Thread就相当于WeddingCompany * Thread是一个代理，它代理的是他括号里面的真实对象（Runnable接口） * HappyMarry是来自于它的接口中的（代理对象中的），start是Thread里面去弄的，它们都有一个共同的方法，run方法 */ new Thread(()-\u003e System.out.println(\"我爱你\")).start(); new WeddingCompany(you).HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry() { System.out.println(\"我要结婚了！\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁--\u003e真实目标角色 private Marry target; public WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry();//这就是真实对象 after(); } private void after() { System.out.println(\"结婚之后，收尾款\"); } private void before() { System.out.println(\"结婚之前，布置现场\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lamda表达式 ","date":"2021-07-04","objectID":"/thread/:2:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"函数式接口的定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lamda表达式来创建该接口的对象 一步步的简化过程 package com.ren.lesson02; /** * 推导lamda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda2\"); } } public static void main(String[] args) { ILike like = new Like(); like.lamda(); like = new Like2(); like.lamda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda3\"); } } like = new Like3(); like.lamda(); //5.匿名内部类,没有类的名称，必须借助接口或者父类 like = new ILike() { @Override public void lamda() { System.out.println(\"i like lamda4\"); } }; like.lamda(); //3.用lamda简化 like = ()-\u003e{ System.out.println(\"i like lamda5\"); }; like.lamda(); } } //1.定义一个函数式接口 interface ILike{ void lamda(); } //2.实现类 class Like implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda\"); } } 实例过程 package com.ren.lesson02; public class TestLamda2 { public static void main(String[] args) { //lamda表达式简化 ILove love = (int a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化1.去掉参数类型 love = (a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化2.去掉括号 love = a-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化3.去掉花括号 love = a-\u003e System.out.println(\"i love you--\u003e\"+a); /** * 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 */ love.love(8); } } interface ILove{ void love(int a); } 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 ","date":"2021-07-04","objectID":"/thread/:2:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程五大状态 ","date":"2021-07-04","objectID":"/thread/:3:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程方法 ","date":"2021-07-04","objectID":"/thread/:3:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不涉及到多个线程操作一个对象可以直接继承Thread，涉及道路就采用继承Runnable接口 ","date":"2021-07-04","objectID":"/thread/:4:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程停止 package com.ren.lesson03; /** * 测试stop(停止线程) * 1.建议使用线程正常停止---\u003e利用次数，不建议死循环 * 2.建议使用标志位---\u003e设置一个标志位 * 3.不要使用stop或者destory等过时或者JDK不建议使用的方法 */ public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while(flag){ System.out.println(\"run......Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\"+i); if(i==900){ //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"该线程停止了\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程休眠 package com.ren.lesson03; import java.text.SimpleDateFormat; import java.util.Date; //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取系统当前时间 while(true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if(num\u003c=0){ break; } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程礼让 package com.ren.lesson03; /** * 测试礼让线程 * 礼让不一定成功，看CPU心情 */ public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行！\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行！\"); } } 结果图： 注意：礼让有可能是成功的，也有可能礼让失败！！！ ","date":"2021-07-04","objectID":"/thread/:4:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程强制执行_Join Join合并线程，待此线程执行完成后，再执行其它线程，其它线程阻塞。可以想象成插队。 package com.ren.lesson03; //测试join方法，想象成插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"线程VIP来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); //主线程 for (int i = 0; i \u003c 500; i++) { if(i==200){ thread.start(); thread.join();//插队 } System.out.println(\"main\"+i); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程状态观测 package com.ren.lesson03; //观察测试线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"//////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//New //观察启动后 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//Run //只要线程不终止，就一直输出状态 while(state != Thread.State.TERMINATED){ Thread.sleep(100);//1秒运行十次 state = thread.getState();//线程状态的更新 System.out.println(state); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程优先级 线程优先级越高，所获取的资源越多 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度 package com.ren.lesson03; //测试线程的优先级 public class Testpriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，在启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(5); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); // t5.setPriority(11); // t5.start(); // // t6.setPriority(-1); // t6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"守护线程 package com.ren.lesson03; //测试守护线程 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(); thread.setDaemon(true);//默认是false表示的用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程启动 new Thread(you).start();// 你 用户线程启动 } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\"1111111111111111111111111\"); } } } class You implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 36500; i++) { System.out.println(\"你一生都开心的活着！\"); } System.out.println(\"============goodbye world==============\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程同步机制 ","date":"2021-07-04","objectID":"/thread/:4:8","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"三大不安全案例 ","date":"2021-07-04","objectID":"/thread/:5:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"买票 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //模拟延时 放大问题的发生性 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"取钱 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不安全的集合 package com.ren.lesson04; import java.util.ArrayList; import java.util.List; //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步方法 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); //模拟延时 放大问题的发生性 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } //synchronized 同步方法，锁的是this private synchronized void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } ","date":"2021-07-04","objectID":"/thread/:6:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步块 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(1000,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 //synchronized 默认锁的是this @Override public void run() { //锁的对象就是变化的量，需要增、删、改的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } } ","date":"2021-07-04","objectID":"/thread/:6:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"CopyOnWriteArrayList package com.ren.lesson04; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //打印是在主线程，操作list是在子线程，sleep是保证子线程执行完在执行主线程的打印 System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:7:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁 ","date":"2021-07-04","objectID":"/thread/:8:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁避免方法 package com.ren.lesson05; //死锁：多个线程互相抱着对方需要的资源，形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑凉\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); //选择 int choice; //使用化妆品的人 String girlName; public Makeup(int choice,String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException { if(choice == 0){ /** * 这个地方解决的方法就是不让其一个人抱着两个人的资源，将其写到外面来 */ synchronized (lipstick){//获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } synchronized (mirror){//一秒钟后想获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){//获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } synchronized (lipstick){//两秒钟后想获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:8:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lock ","date":"2021-07-04","objectID":"/thread/:9:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"synchronized与Lock的对比 package com.ren.lesson05; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try{ //加锁 lock.lock(); if(ticketNums\u003e0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { //解锁 lock.unlock(); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:9:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"生产者消费者问题 ","date":"2021-07-04","objectID":"/thread/:10:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"管程法 package com.ren.lesson05; //测试：生产者消费者模型--\u003e利用缓冲区解决：管程法 //生产者， 消费者 ， 产品， 缓冲区 public class TestPC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); } } //生产者 class Productor extends Thread{ SynContainer container; public Productor(SynContainer container){ this.container = container; } //生产 @Override public void run() { for (int i = 0; i \u003c 100; i++) { container.push(new Chicken(i)); System.out.println(\"生产了第\"+i+\"只鸡\"); } } } //消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } //消费 @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(\"消费了第--\u003e\"+container.pop().id+\"只鸡\"); } } } //产品 class Chicken{ //产品编号 int id; public Chicken(int id) { this.id = id; } } //缓冲区 class SynContainer{ //需要一个容器大小 Chicken[] chickens = new Chicken[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Chicken chicken){ //如果容器满了，就需要等待消费者消费产品 if(count==chickens.length){ //通知消费者生产，生产者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果没有满，我们就需要丢入产品 chickens[count] = chicken; count++; //可以通知消费者消费了 this.notifyAll(); } //消费者消费产品 public synchronized Chicken pop(){ //判断能否消费 if(count == 0){ //等待生产者生产，消费者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果可以消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"信号灯法 package com.ren.lesson05; //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--\u003e演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if(i%2==0){ tv.play(\"快乐大本营播放中！\"); }else{ tv.play(\"抖音记录美好生活\"); } } } } //消费者--\u003e观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { tv.watch(); } } } //产品--\u003e节目 class TV{ //演员表演，观众等待 T //观众观看，演员等待 F //表演的节目 String voice; //标志位 boolean flag = true; //演员表演 public synchronized void play(String voice){ if(!flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice = voice; this.flag = !flag; } //观众观看 public synchronized void watch(){ if(flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"观众观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !flag; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"使用线程池 package com.ren.lesson05; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable的实现类 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:11:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了  结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new G","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["SQL常见问题"],"content":"SQL常见问题","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["SQL常见问题"],"content":"SQL常见问题 建立新连接时报错：can’t connect to mysql server on ‘localhost’ 原因：是因为本地服务器没开启 解决：用系统管理员打开命令行，输入net start mysql57启动服务器（这里如果是启动8.0服务器就是net start mysql80） 双数据库情况下，在普通命令行不输入密码直接进到mysql下服务器下 先进入mysql安装目录下的bin目录下 再输入mysql -uroot -P 3306 -p命令 直接回车，不需要输入密码 解决数据库建立新连接时报错access denied for user ‘root’@‘localhost’以及mysql命令行工具闪退问题 解决： 到安装的MySQL的目录下，找my.ini文件，在[mysqld]后添加skip-grant-tables，保存退出 在命令行中进入mysql安装目录下的bin目录 输入mysql -uroot -P 3306 -p命令（这里端口号要对应）（作用：使其登录时跳过权限检查） 直接回车，不用输入密码 输入ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 修改密码 报错： flush privileges; 刷新权限 再修改密码ALTER USER ‘root’@‘localhost’ IDENTIFIED BY ‘123456’; 成功 参考博客：https://blog.csdn.net/weixin_43589074/article/details/107728819 ","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["SQL常见问题"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["Spring"],"content":"Spring","date":"2021-06-26","objectID":"/spring/","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"111111111111111111111111111111111111111111 ","date":"2021-06-26","objectID":"/spring/:0:0","tags":["Spring"],"title":"Spring","uri":"/spring/"}]