[{"categories":["RabbitMQ"],"content":"RabbitMQ","date":"2022-12-18","objectID":"/rabbitmq/","tags":["RabbitMQ"],"title":"RabbitMQ","uri":"/rabbitmq/"},{"categories":["RabbitMQ"],"content":"RabbitMQ ","date":"2022-12-18","objectID":"/rabbitmq/:0:0","tags":["RabbitMQ"],"title":"RabbitMQ","uri":"/rabbitmq/"},{"categories":["JUC"],"content":"JUC","date":"2021-11-25","objectID":"/juc/","tags":["JUC"],"title":"JUC","uri":"/juc/"},{"categories":["JUC"],"content":"1、JUC是什么 java.util.concurrent在并发编程中使用的工具类 由三部分组成 并发包：java.util.concurrent 并发原子包：java.util.concurrent.atomic 并发lock包：java.util.concurrent.lock ","date":"2021-11-25","objectID":"/juc/:1:0","tags":["JUC"],"title":"JUC","uri":"/juc/"},{"categories":["JUC"],"content":"1.1、进程/线程回顾 1.1.1、进程/线程是什么？ 进程：后台运行的一个程序；与操作系统有关 线程：比如你登陆了QQ，这就是一个进程，然后你同时跟多人聊天并查看天气，这就是多个线程在运行 1.1.2、进程/线程例子？ 1.1.3、线程状态？ 1.1.4、wait/sleep的区别？ 1.1.5、什么是并发？什么是并行？ 高并发：同一个时间点，争夺一个资源 并行：泡脚的同时再玩手机 ","date":"2021-11-25","objectID":"/juc/:1:1","tags":["JUC"],"title":"JUC","uri":"/juc/"},{"categories":["SpringBoot"],"content":"SpringBoot2","date":"2021-11-02","objectID":"/springboot2/","tags":["SpringBoot"],"title":"Springboot2","uri":"/springboot2/"},{"categories":["SpringBoot"],"content":"SpringBoot2学习中 ","date":"2021-11-02","objectID":"/springboot2/:0:0","tags":["SpringBoot"],"title":"Springboot2","uri":"/springboot2/"},{"categories":["Spring"],"content":"Spring5","date":"2021-10-29","objectID":"/spring5/","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"1、Spring框架概述 Spring 是轻量级的开源的 JavaEE框架 Spring 可以解决企业应用开发的复杂性 Spring 有两个核心部分：IOC和 Aop IOC：控制反转，把创建对象过程交给 Spring 进行管理 AOP：面向切面，不修改源代码进行功能增强 Spring 特点 方便解耦，简化开发 AOP编程支持 方便程序测试 方便和其它框架进行整合 方便进行事务操作 降低API开发难度 ","date":"2021-10-29","objectID":"/spring5/:1:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"2、入门案例 1、创建一个Java工程 2、导入相关的依赖包 3、创建普通类 package com.clover.spring5; public class User { public void add() { System.out.println(\"Add.............\"); } } 4、创建Spring配置文件，在配置文件中配置创建的对象 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e \u003c!--配置User对象创建--\u003e \u003cbean id=\"user\" class=\"com.clover.spring5.User\" /\u003e \u003c/beans\u003e 5、进行测试代码编写 package com.clover.spring5.Test; import com.clover.spring5.User; import org.junit.Test; import org.springframework.context.support.ClassPathXmlApplicationContext; public class demo { @Test public void testAdd() { //1.加载配置文件 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); //2.获取配置创建的对象 User user = context.getBean(\"user\", User.class); System.out.println(user); user.add(); } } ","date":"2021-10-29","objectID":"/spring5/:2:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"3、IOC(概念和原理) ","date":"2021-10-29","objectID":"/spring5/:3:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"3.1、什么是IOC 控制反转，把对象的创建和对象之间的调用过程，交给Spring进行管理 使用IOC的目的：为了耦合度降低 ","date":"2021-10-29","objectID":"/spring5/:3:1","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"3.2、IOC底层原理 xml解析、工厂模式、反射 反射：通道得到该类的字节码文件，然后可以操作该类中的所有内容 原始方式 工厂模式 IOC模式 ","date":"2021-10-29","objectID":"/spring5/:3:2","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"4、IOC(BeanFactory 接口) IOC思想基于IOC容器完成，IOC容器底层就是对象工厂 Spring提供IOC容器实现的两种方法：（两个接口） BeanFactory：IOC容器的基本实现，是Spring内部的使用接口，不提供给开发人员进行使用 与ApplicationContext的区别：它在加载配置文件的时候不会去创建对象，在获取(使用)对象的时候才去创建对象 ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 与BeanFacotory的区别：它在加载配置文件的时候就会把在配置文件中配置的对象进行创建 上述两种方式那种更好呢？ 有人说：第一种方式好，因为只有在用的时候才去使用，节约内存空间 有人说：第二种方式好，因为不需要在使用的时候=去创建，因为那会耗费很多时间和资源 综上所述：第二种方式更好，我们将这些耗费时间和资源的事情全部交给服务器去做，在启动的时候就全部做完，我们直接使用即可 ApplicationContext接口有实现类 ","date":"2021-10-29","objectID":"/spring5/:4:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5、IOC的操作 ","date":"2021-10-29","objectID":"/spring5/:5:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.1、Bean管理 IOC的操作实质上就是对Bean进行操作，因为IOC容器就是管理着一个个Bean，而Bean有两个操作：1、创建对象，2、注入属性 什么是Bean管理 Bean管理指的是两个操作 Spring创建对象 Spring注入属性 怎样实现Bean管理操作 基于xml配置文件方式实现 基于该方法实现属性注入时有两种方法 set方法注入 有参构造函数注入 基于注解方式实现 ","date":"2021-10-29","objectID":"/spring5/:5:1","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.2、Bean管理操作实现 1、基于xml 方式创建对象 \u003c!--配置User对象创建--\u003e \u003cbean id=\"user\" class=\"com.clover.spring5.User\" /\u003e 在spring配置文件中，使用bean标签，标签里面添加对应的属性，就可以实现对象创建 在bean标签里面有很多属性，介绍常用属性 id属性：类似于对象的一个别名或者标识，并不是代表对象，是通过该别名去获取真实的对象，要有唯一性 class属性：类的全路径，即该对象所对应的类路径 2、基于xml方式注入属性 DI：依赖注入，就是属性注入 面试时问：IOC与DI的区别 DI是IOC中的一种具体实现，它表示属性注入，属性注入是在对象创建好的基础之上去执行的 ３、第一种注入方式：使用set方法进行注入 创建类，定义属性和set方法 package com.clover.spring5; /** * 演示使用set方法进行注入属性 */ public class Book { // 创建属性 private String name; private String author; // 创建属性对应的set方法 public void setName(String name) { this.name = name; } public void setAuthor(String author) { this.author = author; } public void test(){ System.out.println(name+\"::::::\"+author); } } 在spring配置文件中配置对象创建，配置属性注入 \u003c!--set方法注入属性--\u003e \u003cbean id=\"book\" class=\"com.clover.spring5.Book\"\u003e \u003c!-- 使用 property 完成属性注入 name：类里面属性名称 value：向属性注入的值 --\u003e \u003cproperty name=\"name\" value=\"易筋经\"/\u003e \u003cproperty name=\"author\" value=\"达摩老祖\"/\u003e \u003c/bean\u003e 4、第二种注入方式：使用有参构造函数进行注入 创建类，定义属性，创建属性对应有参数构造方法 //有参构造函数 public Book(String name, String author) { this.name = name; this.author = author; } 在 spring 配置文件中进行配置 \u003c!--使用有参构造函数进行注入--\u003e \u003cbean id=\"book\" class=\"com.clover.spring5.Book\"\u003e \u003c!-- 使用 constructor-arg 完成属性注入 name：类里面属性名称 value：向属性注入的值 --\u003e \u003cconstructor-arg name=\"name\" value=\"易筋经\"/\u003e \u003cconstructor-arg name=\"author\" value=\"达摩老祖\"/\u003e \u003c/bean\u003e 5、p名称空间注入（了解） p名称空间注入底层还是使用了Set方法注入 使用p名称空间注入，可以简化基于xml配置方式 第一步 添加p名称空间在配置文件中 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"\u003e 第二步 进行属性注入，在bean标签里面进行操作 \u003c!--p命名空间注入属性--\u003e \u003cbean id=\"book\" class=\"com.clover.spring5.Book\" p:name=\"九阳神功\" p:author=\"无名氏\"/\u003e ","date":"2021-10-29","objectID":"/spring5/:5:2","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.3、IOC 操作 Bean 管理(xml 注入其他类型属性) 5.3.1、字面量 1、空值(NULL值) \u003c!--给属性设null值--\u003e \u003cproperty name=\"address\"\u003e \u003cnull/\u003e \u003c/property\u003e 2、属性值包含特殊符号 \u003c!--属性值包含特殊符号 1、把\u003c\u003e进行转义 \u0026lt;\u0026gt; 代表大于号、小于号 2、把带特殊符号内容写道CDATA中 --\u003e \u003cproperty name=\"address\"\u003e \u003cvalue\u003e\u003c![CDATA[\u003c\u003c赤壁\u003e\u003e]]\u003e\u003c/value\u003e \u003c/property\u003e 5.3.2、注入属性-外部Bean 1、创建两个类service类和dao类 2、在 service 调用 dao 里面的方法 3、在 spring配置文件中进行配置 \u003c!--1 service和dao对象创建--\u003e \u003cbean id=\"userService\" class=\"com.clover.spring5.service.UserService\"\u003e \u003c!--注入UserDao对象，外部Bean name属性：类里面属性名称 ref属性：创建UserDao对象bean标签ID值 --\u003e \u003cproperty name=\"userDao\" ref=\"userDao\"/\u003e \u003c/bean\u003e \u003c!--因为接口不能创建对象，所以class路径指向接口实现类--\u003e \u003cbean id=\"userDao\" class=\"com.clover.spring5.dao.UserDaoImpl\"/\u003e package com.clover.spring5.service; import com.clover.spring5.dao.UserDao; public class UserService { // 创建UserDao类型属性，生成set方法进行属性注入 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\"UserService add .............\"); userDao.update(); } } 5.3.3、注入属性-内部Bean 1、一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多 2、在实体类之间表示一对多关系，员工表示所属部门，使用对象类型进行表示 package com.clover.spring5.bean; //部门类 public class Dept { private String dname; public void setDname(String dname) { this.dname = dname; } @Override public String toString() { return \"Dept{\" + \"dname='\" + dname + '\\'' + '}'; } } package com.clover.spring5.bean; // 员工类 public class Emp { private String ename; private String gender; //员工属于某一个部门，使用对象形式表示 private Dept dept; public void setDept(Dept dept) { this.dept = dept; } public void setEname(String ename) { this.ename = ename; } public void setGender(String gender) { this.gender = gender; } public void test() { System.out.println(ename+\":::\"+gender+\":::\"+dept); } } 3、在spring配置文件中进行配置 \u003c!--内部bean--\u003e \u003cbean id=\"emp\" class=\"com.clover.spring5.bean.Emp\"\u003e \u003c!--设置两个普通属性--\u003e \u003cproperty name=\"ename\" value=\"clover\"/\u003e \u003cproperty name=\"gender\" value=\"男\"/\u003e \u003c!--设置对象类型属性--\u003e \u003cproperty name=\"dept\"\u003e \u003cbean id=\"dept\" class=\"com.clover.spring5.bean.Dept\"\u003e \u003cproperty name=\"dname\" value=\"技术部\"/\u003e \u003c/bean\u003e \u003c/property\u003e \u003c/bean\u003e 5.3.4、注入属性-级联赋值 5.3.4.1、第一种写法 \u003c!--级联赋值--\u003e \u003cbean id=\"emp\" class=\"com.clover.spring5.bean.Emp\"\u003e \u003c!--设置两个普通属性--\u003e \u003cproperty name=\"ename\" value=\"clover\"/\u003e \u003cproperty name=\"gender\" value=\"男\"/\u003e \u003c!--级联赋值--\u003e \u003cproperty name=\"dept\" ref=\"dept\"/\u003e \u003c/bean\u003e \u003cbean id=\"dept\" class=\"com.clover.spring5.bean.Dept\"\u003e \u003cproperty name=\"dname\" value=\"安保部\"/\u003e \u003c/bean\u003e 5.3.4.2、第二种写法 \u003c!--级联赋值--\u003e \u003cbean id=\"emp\" class=\"com.clover.spring5.bean.Emp\"\u003e \u003c!--设置两个普通属性--\u003e \u003cproperty name=\"ename\" value=\"clover\"/\u003e \u003cproperty name=\"gender\" value=\"男\"/\u003e \u003c!--级联赋值--\u003e \u003cproperty name=\"dept\" ref=\"dept\"/\u003e \u003cproperty name=\"dept.dname\" value=\"财务部\"/\u003e \u003c/bean\u003e \u003cbean id=\"dept\" class=\"com.clover.spring5.bean.Dept\"\u003e \u003cproperty name=\"dname\" value=\"安保部\"/\u003e \u003c/bean\u003e 注意：使用级联赋值时，如果你property中的name=对象.属性名，那么你需要在该property对应Bean的实体类中加入get 方法，因为你不先拿到该对象时无法对该对象进行操作的 同时，你在使用第二种方式的同时，第一种方法的写法也得保存下来，要不然会报错，说你对应的属性值为null 自己小总结： IOC的底层就是基于xml、工厂模式和反射 先配置好xml，然后工厂模式对xml进行解析，最后通过反射创建对象 IOC基于容器实现，容器的底层又是工厂模式 工厂模式有两种实现方式： Application BeanFactory 使用set方法进行注入时，是因为工厂模式在解析xml的时候，xml中的property设置的值就会去调用set方法设置对应属性的值，否则会报null错误 (这点为自我总结，还未查阅资料，不知正确与否) 使用构造器进行注入时，与使用set方法注入是一样的作用 ","date":"2021-10-29","objectID":"/spring5/:5:3","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.4、IOC 操作 Bean 管理(xml 注入集合属性) 1、注入数组类型属性 2、注入 List 集合类型属性 3、注入Map集合类型属性 创建类，定义数组、list、map、set类型属性，生成对应 set方法 package com.clover.spring5.collectiontype; import java.util.Arrays; import java.util.List; import java.util.Map; import java.util.Set; public class Stu { //1 数组类型属性 private String[] courses; //2 list集合类型属性 private List\u003cString\u003e lists; //3 map集合类型属性 private Map\u003cString,String\u003e maps; //4 set集合类型属性 private Set\u003cString\u003e sets; public void setCourses(String[] courses) { this.courses = courses; } public void setLists(List\u003cString\u003e lists) { this.lists = lists; } public void setMaps(Map\u003cString, String\u003e maps) { this.maps = maps; } public void setSets(Set\u003cString\u003e sets) { this.sets = sets; } public void test() { System.out.println(Arrays.toString(courses)); System.out.println(lists); System.out.println(maps); System.out.println(sets); } } 在 spring配置文件进行配置 \u003c!--集合类型属性注入--\u003e \u003cbean id=\"stu\" class=\"com.clover.spring5.collectiontype.Stu\"\u003e \u003c!--数组类型属性注入--\u003e \u003cproperty name=\"courses\"\u003e \u003carray\u003e \u003cvalue\u003eJava 课程\u003c/value\u003e \u003cvalue\u003e数据库课程\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!--list类型属性注入--\u003e \u003cproperty name=\"lists\"\u003e \u003clist\u003e \u003cvalue\u003e李四\u003c/value\u003e \u003cvalue\u003e小李子\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--map类型属性注入--\u003e \u003cproperty name=\"maps\"\u003e \u003cmap\u003e \u003centry key=\"JAVA\" value=\"java\"/\u003e \u003centry key=\"PHP\" value=\"php\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!--set类型属性注入--\u003e \u003cproperty name=\"sets\"\u003e \u003cset\u003e \u003cvalue\u003eMysql\u003c/value\u003e \u003cvalue\u003eRedis\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c/bean\u003e 5.4.1、xml注入集合属性两个小细节 1、在集合里面设置对象类型值 \u003c!--注入list集合类型，值是对象--\u003e \u003cproperty name=\"courseList\"\u003e \u003clist\u003e \u003cref bean=\"course1\"/\u003e \u003cref bean=\"course2\"/\u003e \u003c/list\u003e \u003c/property\u003e \u003c!--创建多个course对象--\u003e \u003cbean id=\"course1\" class=\"com.clover.spring5.collectiontype.Courses\"\u003e \u003cproperty name=\"cname\" value=\"spring\"/\u003e \u003c/bean\u003e \u003cbean id=\"course2\" class=\"com.clover.spring5.collectiontype.Courses\"\u003e \u003cproperty name=\"cname\" value=\"mybatis\"/\u003e \u003c/bean\u003e 2、把集合注入部分提取出来 在 spring 配置文件中引入名称空间 util \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd\"\u003e \u003c/beans\u003e 使用 util 标签完成 list 集合注入提取 \u003c!--1 提取list集合类型属性注入--\u003e \u003cutil:list id=\"bookList\"\u003e \u003cvalue\u003e易筋经\u003c/value\u003e \u003cvalue\u003e九阴真经\u003c/value\u003e \u003cvalue\u003e九阳神功\u003c/value\u003e \u003c/util:list\u003e \u003c!--2 提取list集合类型属性注入使用--\u003e \u003cbean id=\"book\" class=\"com.clover.spring5.collectiontype.Book\"\u003e \u003cproperty name=\"list\" ref=\"bookList\"/\u003e \u003c/bean\u003e ","date":"2021-10-29","objectID":"/spring5/:5:4","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.5、IOC 操作 Bean 管理(FactoryBean) 1、Spring有两种类型bean，一种普通bean，另外一种叫工厂bean(FactoryBean) 2、普通 bean：在配置文件中定义的 bean类型就是返回类型 3、工厂bean：在配置文件定义的 bean类型可以和返回类型不一样 第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean 第二步 实现接口里面的方法，在实现的方法中定义返回的bean类型 package com.clover.spring5.factorybean; import com.clover.spring5.collectiontype.Courses; import org.springframework.beans.factory.FactoryBean; // 工厂Bean，可以让返回对象类型和class中定义的不一样 public class MyBean implements FactoryBean\u003cCourses\u003e { //定义返回bean的类型 @Override public Courses getObject() throws Exception { Courses courses = new Courses(); courses.setCname(\"clover\"); return courses; } @Override public Class\u003c?\u003e getObjectType() { return null; } @Override public boolean isSingleton() { return false; } } \u003cbean id=\"myBean\" class=\"com.clover.spring5.factorybean.MyBean\"\u003e\u003c/bean\u003e @Test public void test3() { // 1.加载配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\"); // 2.获取配置文件创建的对象 Courses courses = context.getBean(\"myBean\", Courses.class); System.out.println(courses); } ","date":"2021-10-29","objectID":"/spring5/:5:5","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.6、IOC 操作 Bean 管理(bean 作用域) 在 Spring里面，设置创建 bean实例是单实例还是多实例 在 Spring里面，默认情况下，bean 是单实例对象 如何设置单实例还是多实例 在 spring配置文件 bean标签里面有属性（scope）用于设置单实例还是多实例 scope 属性值 第一个值 默认值，singleton，表示是单实例对象 第二个值 prototype，表示是多实例对象 **singleton 和 prototype 区别 ** 第一 singleton 单实例，prototype 多实例 第二 设置 scope 值是 singleton时候，加载 spring 配置文件时候就会创建单实例对象 设置 scope 值是 prototype 时候，不是在加载 spring 配置文件时候创建 对象，在调用 getBean方法时候创建多实例对象 ","date":"2021-10-29","objectID":"/spring5/:5:6","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.7、IOC 操作 Bean 管理(bean 生命周期) 生命周期 从对象创建到对象销毁的过程 bean 生命周期 通过构造器创建bean实例 (调用无参构造函数) 为bean的属性设置值和对其它bean引用 (调用set方法) 调用bean的初始化方法 (需要进行配置初始化的方法) bean可以使用了 (对象获取到了) 当容器关闭的时候，调用bean的销毁方法 (需要进行配置销毁的方法) 演示 bean 生命周期 package com.clover.spring5.bean; public class Orders { //无参数构造 public Orders(){ System.out.println(\"第一步 执行无参数构造创建 bean 实例\"); } private String oname; public void setOname(String oname) { this.oname = oname; System.out.println(\"第二步 调用 set 方法设置属性值\"); } //创建执行的初始化的方法 public void initMethod() { System.out.println(\"第三步 执行初始化的方法\"); } //创建执行的销毁的方法 public void destroyMethod() { System.out.println(\"第五步 执行销毁的方法\"); } } \u003cbean id=\"orders\" class=\"com.clover.spring5.bean.Orders\" init-method=\"initMethod\" destroy-method=\"destroyMethod\"\u003e \u003cproperty name=\"oname\" value=\"adas\"/\u003e \u003c/bean\u003e @Test public void test4() { // 1.加载配置文件 ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\"); // 2.获取配置文件创建的对象 Orders orders = context.getBean(\"orders\", Orders.class); System.out.println(\"第四步 获取创建 bean 实例对象\"); System.out.println(orders); //手动让bean实例销毁 context.close(); } bean的后置处理器，bean生命周期有七步 通过构造器创建bean实例 (调用无参构造函数) 为bean的属性设置值和对其它bean引用 (调用set方法) 把 bean 实例传递 bean 后置处理器的方法 postProcessBeforeInitialization 调用bean的初始化方法 (需要进行配置初始化的方法) 把 bean 实例传递 bean 后置处理器的方法 postProcessAfterInitialization bean可以使用了 (对象获取到了) 当容器关闭的时候，调用bean的销毁方法 (需要进行配置销毁的方法) 演示添加后置处理器效果 创建类，实现接口 BeanPostProcessor，创建后置处理器 package com.clover.spring5.bean; import org.springframework.beans.BeansException; import org.springframework.beans.factory.config.BeanPostProcessor; import org.springframework.lang.Nullable; public class MyBeanPost implements BeanPostProcessor { @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"在初始化之前执行的方法\"); return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"在初始化之后执行的方法\"); return bean; } } \u003c!--配置后置处理器--\u003e \u003cbean id=\"myPostBean\" class=\"com.clover.spring5.bean.MyBeanPost\"/\u003e 问题、疑惑： 自己的一个问题，但还没有查找资料解决 创建bean实例通过调用无参构造函数来指向，但是当你使用了有参构造函数进行属性注入时，无参构造函数没有了，bean 实例如何创建的 ","date":"2021-10-29","objectID":"/spring5/:5:7","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.8、IOC 操作 Bean 管理(xml 自动装配) 什么是自动装配 根据指定装配规则（属性名称或者属性类型），Spring自动将匹配的属性值进行注入 演示自动装配过程 根据属性名称自动注入 \u003c!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName根据属性名称注入 ，注入值bean的id值和类属性名称一样 byType根据属性类型注入 ，但是只能每次同一个对象只能有一个，多个就不知道该调用哪一个了 --\u003e \u003cbean id=\"emp\" class=\"com.clover.spring5.autowire.Emp\" autowire=\"byName\"\u003e \u003c!-- \u003cproperty name=\"dept\" ref=\"dept\"/\u003e--\u003e \u003c/bean\u003e \u003cbean id=\"dept\" class=\"com.clover.spring5.autowire.Dept\"/\u003e 根据属性类型自动注入 \u003c!--实现自动装配 bean标签属性autowire，配置自动装配 autowire属性常用两个值： byName根据属性名称注入 ，注入值bean的id值和类属性名称一样 byType根据属性类型注入 ，但是只能每次同一个对象只能有一个，多个就不知道该调用哪一个了 --\u003e \u003cbean id=\"emp\" class=\"com.clover.spring5.autowire.Emp\" autowire=\"byType\"\u003e \u003c!-- \u003cproperty name=\"dept\" ref=\"dept\"/\u003e--\u003e \u003c/bean\u003e \u003cbean id=\"dept\" class=\"com.clover.spring5.autowire.Dept\"/\u003e ","date":"2021-10-29","objectID":"/spring5/:5:8","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.9、IOC 操作 Bean 管理(外部属性文件) 直接配置数据库信息 配置Druid连接池 引入Druid连接池依赖 jar包 \u003c!--直接配置连接池--\u003e \u003cbean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3306/userDb\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"root\"/\u003e \u003c/bean\u003e 引入外部属性文件配置数据库连接池 创建外部属性文件，properties格式文件，写数据库信息 prop.driverClass= com.mysql.jdbc.Driver prop.url= jdbc:mysql://localhost:3306/userDb prop.userName=root prop.password=root| 把外部 properties 属性文件引入到 spring 配置文件中：引入 context 名称空间 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xmlns:util=\"http://www.springframework.org/schema/util\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"\u003e \u003c/beans\u003e 在spring 配置文件使用标签引入外部属性文件 \u003c!--引入外部属性文件--\u003e \u003ccontext:property-placeholder location=\"classpath:jdbc.properties\"/\u003e \u003c!--配置连接池--\u003e \u003cbean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\u003e \u003cproperty name=\"driverClassName\" value=\"${prop.driverClass}\"/\u003e \u003cproperty name=\"url\" value=\"${prop.url}\"/\u003e \u003cproperty name=\"username\" value=\"${prop.userName}\"/\u003e \u003cproperty name=\"password\" value=\"${prop.password}\"/\u003e \u003c/bean\u003e ","date":"2021-10-29","objectID":"/spring5/:5:9","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.10、IOC 操作 Bean 管理(基于注解方式) 什么是注解 注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..) 使用注解，注解作用在类上面，方法上面，属性上面 使用注解目的：简化 xml配置 Spring 针对 Bean 管理中创建对象提供注解 @Component @Service @Controller @Repository 上面四个注解功能是一样的，都可以用来创建bean实例 基于注解方式实现对象创建 第一步 引入AOP依赖 第二步 开启组件扫描 \u003c!--开启组件扫描 1 如果扫描多个包，多个包使用逗号隔开 2 扫描包上层目录 --\u003e \u003ccontext:component-scan base-package=\"com.clover\"/\u003e 第三步 创建类，在类上面添加创建对象注解 package com.clover.spring5.bean; import org.springframework.stereotype.Service; //在注解里面value属性值可以省略不写， //默认值是类名称，首字母小写 @Service // 该注解就等价于\u003cbean id=\"userService\" class=\"...\"/\u003e public class UserService { public void add() { System.out.println(\"service add.......\"); } } 开启组件扫描细节配置 \u003c!--示例1 use-default-filters=\"false\" 表示现在不使用默认filter，自己配置filter context:include-filter ，设置扫描哪些内容 --\u003e \u003ccontext:component-scan base-package=\"com.clover\" use-default-filters=\"false\"\u003e \u003ccontext:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e \u003c!--示例2 下面配置扫描包所有内容 context:exclude-filter： 设置哪些内容不进行扫描 --\u003e \u003ccontext:component-scan base-package=\"com.clover\"\u003e \u003ccontext:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/\u003e \u003c/context:component-scan\u003e 基于注解方式实现属性注入 @Autowired：根据属性类型进行自动装配 第一步 把 service 和 dao 对象创建，在 service 和 dao 类添加创建对象注解 第二步 在 service 注入 dao 对象，在 service 类添加 dao类型属性，在属性上面使用注解 //在注解里面value属性值可以省略不写， //默认值是类名称，首字母小写 @Service // 该注解就等价于\u003cbean id=\"userService\" class=\"...\"/\u003e public class UserService { //定义dao类型属性 //不需要添加set方法 //添加注入属性注解 @Autowired //根据类型进行注入 @Qualifier(value = \"userDaoImpl1\") //根据名称进行注入 private UserDao userDao; public void add() { System.out.println(\"service add.......\"); userDao.add(); } } @Qualifier：根据名称进行注入;这个@Qualifier 注解的使用，和上面@Autowired 一起使用 //定义dao类型属性 //不需要添加set方法 //添加注入属性注解 @Autowired //根据类型进行注入 @Qualifier(value = \"userDaoImpl1\") //根据名称进行注入 private UserDao userDao; @Resource：可以根据类型注入，也可以根据名称注入 @Resource //根据类型进行注入 // @Resource(name = \"userDaoImpl1\") //根据名称进行注入 private UserDao userDao; @Value：注入普通类型属性 @Value(value = \"abc\") private String name; 注意：前面三个注解是针对对象类型注入，而不是普通属性注入 使用了注解不用写set方法，因为注解里面帮我们封装好了 ","date":"2021-10-29","objectID":"/spring5/:5:10","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"5.11、完全注解开发 1、创建配置类，替代xml配置文件 package com.clover.spring5.config; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; @Configuration @ComponentScan(basePackages = {\"com.clover\"}) public class SpringConfig { } 2、编写测试类 @Test public void test2() { //加载配置类 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class); UserService userService = context.getBean(\"userService\", UserService.class); System.out.println(userService); userService.add(); } ","date":"2021-10-29","objectID":"/spring5/:5:11","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6、AOP（概念） ","date":"2021-10-29","objectID":"/spring5/:6:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.1、什么是AOP 面向切面（方面）编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率 通俗描述：不通过修改源代码方式，在主干功能里面添加新功能 使用登录例子说明AOP ","date":"2021-10-29","objectID":"/spring5/:6:1","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.2、AOP(底层原理) 动态代理 传入的目标对象 利用反射机制返回一个代理对象 通过代理对象调用目标对象方法触发事情处理器方法 AOP底层使用动态代理 有两种情况动态代理 第一种 有接口情况，使用JDK动态代理 创建接口实现类代理对象，增强类的方法 第二种 没有接口情况，使用CGLIB动态代理 创建子类的代理对象，增强类的方法 ","date":"2021-10-29","objectID":"/spring5/:6:2","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.3、AOP(JDK 动态代理) 想对哪个类方法进行加强，就传入哪个类对象，创建目标对象可以用接口变量形式接收 利用反射机制返回一个代理对象 需要准备3个参数 当前目标对象使用的类加载器 目标对象实现的接口类型 创建代理对象 通过代理对象调用方法后，就会实现功能增强；调用目标对象方法后，会触发事情处理器方法，会把当前执行的目标对象方法作为参数传入 package com.clover.spring5; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; public class JDKProxy { public static void main(String[] args) { //创建目标对象实现的接口类型 Class[] interfaces = {UserDao.class}; //创建目标对象 UserDao target = new UserDaoImpl(); //给目标对象创建代理对象 //返回指定接口的代理类的实例，该接口将方法调用分派给指定的调用处理程序 /** * ClassLoader loader: 指定当前目标对象使用的类加载器，获取加载器的方法固定 * Class\u003c?\u003e[] interfaces: 目标对象实现的接口类型，使用泛型方式确认 * InvocationHandler h: 事情处理，执行目标对象的方法，会触发事情处理器方法，会把当前执行的目标对象方法作为参数传入 */ UserDao dao = (UserDao) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(target)); //System.out.println((Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserDaoProxy(userDao))) instanceof UserDao); int result = dao.add(1, 2); System.out.println(\"result:\"+result); } } // 创建代理对象 class UserDaoProxy implements InvocationHandler{ //1 把创建的是谁的代理对象，就把谁传递过来 //有参数构造传递 private Object obj; public UserDaoProxy(Object obj) { this.obj = obj; } //增强功能的逻辑 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //方法之前 System.out.println(\"方法之前执行....\"+method.getName()+\" :传递的参数...\"+ Arrays.toString(args)); //被增强的方法执行 //通过反射机制调用目标对象的方法 Object res = method.invoke(obj, args); //System.out.println(res); //方法之后 System.out.println(\"方法之后执行....\"+obj); return res; } } package com.clover.spring5; public class UserDaoImpl implements UserDao { @Override public int add(int a, int b) { System.out.println(\"1111\"); return a+b; } @Override public String update(String id) { return id; } } package com.clover.spring5; public interface UserDao { public int add(int a,int b); public String update(String id); } ","date":"2021-10-29","objectID":"/spring5/:6:3","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.4、AOP术语 1、连接点 类里面哪些方法可以被增强 2、切入点 实际被真正增强的方法，称为切入点 3、通知(增强) 实际增强的逻辑部分称为通知(增加) 通知有多种类型 前置通知：在某一个方法之前执行 后置通知：在某一方法之后执行 环绕通知：在某一方法之前之后都执行 异常通知：在某一方法出现异常时执行 最终通知：类似于finally，不管怎么样最后都会执行 4、切面 是动作，把通知应用到切入点的过程 ","date":"2021-10-29","objectID":"/spring5/:6:4","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.5、AOP操作(准备工作) Spring 框架一般都是基于 AspectJ 实现 AOP 操作 AspectJ 不是 Spring 组成部分，是独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行AOP操作 基于 AspectJ 实现 AOP 操作 基于xml配置文件实现 基于注解方式实现（使用） 在项目工程里面引入AOP相关依赖 切入点表达式 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构： execution([权限修饰符] [返回类型] [类全路径] 方法名称) 使用两个..代表参数列表 举例 1：对 com.atguigu.dao.BookDao 类里面的 add 进行增强 execution(* com.atguigu.dao.BookDao.add(..)) 举例 2：对 com.atguigu.dao.BookDao 类里面的所有的方法进行增强 execution(* com.atguigu.dao.BookDao.* (..)) 举例 3：对 com.atguigu.dao包里面所有类，类里面所有方法进行增强 execution(* com.atguigu.dao.*.* (..)) ","date":"2021-10-29","objectID":"/spring5/:6:5","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.6、AOP 操作(AspectJ 注解) 1、创建类，在类里面定义方法 @Component public class User { public void add() { System.out.println(\"add.................\"); } } 2、创建增强类（编写增强逻辑） //增强的类 @Component @Aspect//生成代理对象 public class UserProxy { public void before() {//前置通知 System.out.println(\"before......\"); } } 3、进行通知的配置 在 spring配置文件中，开启注解扫描 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"\u003e \u003c!-- 开启注解扫描 --\u003e \u003ccontext:component-scan base-package=\"com.clover.spring5.aopannotation\"/\u003e \u003c!-- 开启Aspect生成代理对象--\u003e \u003caop:aspectj-autoproxy/\u003e \u003c/beans\u003e 使用注解创建 User 和 UserProxy 对象 在增强类上面添加注解 @Aspect 在 spring配置文件中开启生成代理对象 4、配置不同类型的通知 在增强类的里面，在作为通知方法上面添加通知类型注解，使用切入点表达式配置 //增强的类 @Component @Aspect//生成代理对象 public class UserProxy { @Before(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void before() {//前置通知 System.out.println(\"before......\"); } //后置通知（返回通知）(方法有异常时不会执行) @AfterReturning(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void afterReturning() { System.out.println(\"afterReturning.........\"); } //最终通知(方法有异常时也会执行) @After(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void after() { System.out.println(\"after.........\"); } //异常通知 @AfterThrowing(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void afterThrowing() { System.out.println(\"afterThrowing.........\"); } //环绕通知 @Around(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { System.out.println(\"环绕之前.........\"); //被增强的方法执行 proceedingJoinPoint.proceed(); System.out.println(\"环绕之后.........\"); } } 5、相同的切入点抽取 //相同切入点抽取 @Pointcut(value = \"execution(* com.clover.spring5.aopannotation.User.add(..))\") public void pointcut() { } @Before(value = \"pointcut()\") public void before() {//前置通知 System.out.println(\"before......\"); } 6、有多个增强类多同一个方法进行增强，设置增强类优先级 在增强类上面添加注解 @Order(数字类型值)，数字类型值越小优先级越高 @Component @Aspect @Order(1) public class PersonProxy 7、完全使用注解开发 创建配置类，不需要创建xml配置文件 @Configuration @ComponentScan(basePackages = {\"com.clover\"})// 开启注解扫描 @EnableAspectJAutoProxy(proxyTargetClass = true)// 开启Aspect生成代理对象 public class configAop { } ","date":"2021-10-29","objectID":"/spring5/:6:6","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"6.7、AOP 操作（AspectJ 配置文件） 1、创建两个类，增强类和被增强类，创建方法 2、在 spring配置文件中创建两个类对象 \u003c!--创建对象--\u003e \u003cbean id=\"book\" class=\"com.clover.spring5.aopxml.Book\"/\u003e \u003cbean id=\"bookProxy\" class=\"com.clover.spring5.aopxml.BookProxy\"/\u003e 3、在 spring 配置文件中配置切入点 \u003c!--配置aop增强--\u003e \u003caop:config\u003e \u003c!--配置切入点--\u003e \u003caop:pointcut id=\"p\" expression=\"execution(* com.clover.spring5.aopxml.Book.buy(..))\"/\u003e \u003c!--配置切面--\u003e \u003caop:aspect ref=\"bookProxy\"\u003e \u003c!--增强作用在具体的方法上--\u003e \u003caop:before method=\"before\" pointcut-ref=\"p\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e ","date":"2021-10-29","objectID":"/spring5/:6:7","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7、JdbcTemplate(概念和准备) 1、什么是 JdbcTemplate Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 2、准备工作 引入相关 jar包 在 spring配置文件配置数据库连接池 \u003c!-- 数据库连接池 --\u003e \u003cbean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\" destroy-method=\"close\"\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql:///user_db\" /\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003cproperty name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\" /\u003e \u003c/bean\u003e 配置 JdbcTemplate 对象，注入 DataSource \u003c!-- JdbcTemplate对象 --\u003e \u003cbean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"\u003e \u003c!--注入dataSource--\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c/bean\u003e \u003c!-- 组件扫描 --\u003e \u003ccontext:component-scan base-package=\"com.clover\"/\u003e 创建 service 类，创建 dao 类，在 dao 注入 jdbcTemplate 对象 @Service public class BookService { //注入dao @Autowired private BookDao bookDao; } @Repository public class BookDaoImpl implements BookDao { //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; } ","date":"2021-10-29","objectID":"/spring5/:7:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.1、JdbcTemplate 操作数据库（添加） 1、对应数据库创建实体类 public class Book { private int userId; private String username; private String userStatus; public int getUserId() { return userId; } public void setUserId(int userId) { this.userId = userId; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getUserStatus() { return userStatus; } public void setUserStatus(String userStatus) { this.userStatus = userStatus; } } 2、编写 service 和 dao 在dao进行数据库添加操作 调用 JdbcTemplate 对象里面 update 方法实现添加操作 有两个参数 第一个参数：sql 语句 第二个参数：可变参数，设置sql语句值 @Repository public class BookDaoImpl implements BookDao { //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; //添加的方法 @Override public void add(Book book) { //1 创建sql语句 String sql = \"insert into t_book values(?,?,?)\"; //2 调用方法实现 Object[] args = {book.getUserId(), book.getUsername(), book.getUserStatus()}; int update = jdbcTemplate.update(sql,args); System.out.println(update); } } 3、测试类 @Test public void testJdbcTemplate() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); BookService bookService = context.getBean(\"bookService\", BookService.class); Book book = new Book(); book.setUserId(\"1\"); book.setUsername(\"java\"); book.setUstatus(\"a\"); bookService.addBook(book); } ","date":"2021-10-29","objectID":"/spring5/:7:1","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.2、JdbcTemplate 操作数据库（修改和删除） //修改 @Override public void update(Book book) { String sql = \"update t_book set username=?,ustatus=? where user_id=?\"; Object[] args = {book.getUsername(), book.getUserStatus(),book.getUserId()}; int update = jdbcTemplate.update(sql, args); System.out.println(update); } //删除 @Override public void deleteBook(String id) { String sql = \"delete from t_book where user_id=?\"; int update = jdbcTemplate.update(sql, id); System.out.println(update); } ","date":"2021-10-29","objectID":"/spring5/:7:2","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.3、JdbcTemplate 操作数据库（查询返回某个值） 1、查询表里面有多少条记录，返回是某个值 2、使用 JdbcTemplate 实现查询返回某个值代码 有两个参数 第一个参数：sql 语句 第二个参数：返回类型 Class //查询表记录数 @Override public int selectCount() { String sql = \"select count(*) from t_book\"; Integer count = jdbcTemplate.queryForObject(sql, Integer.class); return count; } ","date":"2021-10-29","objectID":"/spring5/:7:3","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.4、JdbcTemplate 操作数据库（查询返回对象） 1、场景：查询图书详情 2、JdbcTemplate 实现查询返回对象 有三个参数 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成数据封装 第三个参数：sql 语句值 //查询返回对象 @Override public Book findBookInfo(String id) { String sql = \"select * from t_book where user_id=?\"; //调用方法 Book book = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper\u003cBook\u003e(Book.class), id); return book; } ","date":"2021-10-29","objectID":"/spring5/:7:4","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.5、JdbcTemplate 操作数据库（查询返回集合） 1、场景：查询图书详情 2、JdbcTemplate 实现查询返回对象 有三个参数 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口里面实现类完成 数据封装 第三个参数：sql 语句值 //查询返回集合 @Override public List\u003cBook\u003e findAllBook() { String sql = \"select * from t_book\"; //调用方法 List\u003cBook\u003e bookList = jdbcTemplate.query(sql, new BeanPropertyRowMapper\u003cBook\u003e(Book.class)); return bookList; } ","date":"2021-10-29","objectID":"/spring5/:7:5","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"7.6、JdbcTemplate 操作数据库（批量操作） 1、批量操作：操作表里面多条记录 2、JdbcTemplate 实现批量添加操作 有两个参数 第一个参数：sql 语句 第二个参数：List集合，添加多条记录数据 //批量添加 @Override public void batchAddBook(List\u003cObject[]\u003e batchArgs) { String sql = \"insert into t_book values(?,?,?)\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量添加测试 List\u003cObject[]\u003e batchArgs = new ArrayList\u003c\u003e(); Object[] o1 = {\"3\",\"java\",\"a\"}; Object[] o2 = {\"4\",\"c++\",\"b\"}; Object[] o3 = {\"5\",\"MySQL\",\"c\"}; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); //调用批量添加 bookService.batchAdd(batchArgs); 3、JdbcTemplate 实现批量修改操作 //批量修改 @Override public void batchUpdateBook(List\u003cObject[]\u003e batchArgs) { String sql = \"update t_book set username=?,ustatus=? where user_id=?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量修改 List\u003cObject[]\u003e batchArgs = new ArrayList\u003c\u003e(); Object[] o1 = {\"java0909\",\"a3\",\"3\"}; Object[] o2 = {\"c++1010\",\"b4\",\"4\"}; Object[] o3 = {\"MySQL1111\",\"c5\",\"5\"}; batchArgs.add(o1); batchArgs.add(o2); batchArgs.add(o3); //调用方法实现批量修改 bookService.batchUpdate(batchArgs); 4、JdbcTemplate 实现批量删除操作 //批量删除 @Override public void batchDeleteBook(List\u003cObject[]\u003e batchArgs) { String sql = \"delete from t_book where user_id=?\"; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); System.out.println(Arrays.toString(ints)); } //批量删除 List\u003cObject[]\u003e batchArgs = new ArrayList\u003c\u003e(); Object[] o1 = {\"3\"}; Object[] o2 = {\"4\"}; batchArgs.add(o1); batchArgs.add(o2); //调用方法实现批量删除 bookService.batchDelete(batchArgs); ","date":"2021-10-29","objectID":"/spring5/:7:6","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8、事务概念 1、什么事务 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 典型场景：银行转账 lucy 转账 100 元 给 mary lucy 少 100，mary 多 100 2、事务四个特性（ACID） 原子性：要么都成功，要么都失败 一致性：操作前后总量是一致的 隔离性：多事务之间的操作无影响，比如两个人操作同一记录，过程间是不会产生影响的 持久性：数据操作完成后表中数据是真正改变了 ","date":"2021-10-29","objectID":"/spring5/:8:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.1、事务操作（搭建事务操作环境） 1、创建数据库表，添加记录 2、创建 service，搭建 dao，完成对象创建和注入关系 service 注入 dao，在 dao 注入 JdbcTemplate，在 JdbcTemplate 注入 DataSource @Service public class UserService { //注入dao @Autowired private UserDao userDao; } @Repository public class UserDaoImpl implements UserDao { @Autowired private JdbcTemplate jdbcTemplate; } 3、在 dao创建两个方法：多钱和少钱的方法，在 service创建方法（转账的方法） package com.clover.spring5.dao; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.jdbc.core.JdbcTemplate; import org.springframework.stereotype.Repository; @Repository public class UserDaoImpl implements UserDao{ @Autowired private JdbcTemplate jdbcTemplate; //lucy转账100给mary // 少钱 @Override public void reduceMoney() { String sql = \"update t_money set money=money-? where username=?\"; jdbcTemplate.update(sql,100,\"lucy\"); } //多钱 @Override public void addMoney() { String sql = \"update t_money set money=money+? where username=?\"; jdbcTemplate.update(sql,100,\"mary\"); } } @Service public class UserService { @Autowired private UserDao userDao; //转账的方法 public void accountMoney() { //lucy少100 userDao.reduceMoney(); //mary多100 userDao.addMoney(); } } 4、上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常，有问题 上面问题如何解决呢？ 使用事务进行解决 事务操作过程 ","date":"2021-10-29","objectID":"/spring5/:8:1","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.2、事务操作（Spring 事务管理介绍） 1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 2、在 Spring 进行事务管理操作 有两种方式 编程式事务管理 声明式事务管理（常用） 3、声明式事务管理 基于注解方式（常用） 基于xml配置文件方式 4、在 Spring进行声明式事务管理，底层使用 AOP原理 5、Spring 事务管理 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 ","date":"2021-10-29","objectID":"/spring5/:8:2","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.3、事务操作（注解声明式事务管理） 1、在 spring配置文件配置事务管理器 \u003c!--创建事务管理器--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003c!--注入数据源--\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c/bean\u003e 2、在 spring 配置文件，开启事务注解 在 spring配置文件引入名称空间 tx \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/aop/spring-tx.xsd\"\u003e 开启事务注解 \u003c!--开启事务注解--\u003e \u003ctx:annotation-driven transaction-manager=\"transactionManager\"/\u003e 3、在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional，这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 ","date":"2021-10-29","objectID":"/spring5/:8:3","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.4、事务操作（声明式事务管理参数配置） 1、在 service 类上面添加注解@Transactional，在这个注解里面可以配置事务相关参数 2、propagation：事务传播行为 多事务方法之间进行调用，这个过程中事务是如何进行管理的 3、ioslation：事务隔离级别 事务有特性成为隔离性，多事务操作之间不会产生影响。不考虑隔离性产生很多问题 有三个读问题：脏读、不可重复读、虚（幻）读 脏读：一个未提交事务读取到另一个未提交事务的数据 不可重复读：一个未提交事务读取到另一提交事务修改数据 虚读：一个未提交事务读取到另一提交事务添加数据 解决：通过设置事务隔离级别，解决读问题 4、timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 5、readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，也可以添加修改删除操作 设置 readOnly 值是 true，设置成 true 之后，只能查询 6、rollbackFor：回滚 设置出现哪些异常进行事务回滚 7、noRollbackFor：不回滚 设置出现哪些异常不进行事务回滚 ","date":"2021-10-29","objectID":"/spring5/:8:4","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.5、事务操作（XML声明式事务管理） 1、在 spring 配置文件中进行配置 第一步 配置事务管理器 第二步 配置通知 第三步 配置切入点和切面 \u003c!--1 创建事务管理器--\u003e \u003cbean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"\u003e \u003c!--注入数据源--\u003e \u003cproperty name=\"dataSource\" ref=\"dataSource\"/\u003e \u003c/bean\u003e \u003c!--2 配置通知--\u003e \u003ctx:advice id=\"txadvice\"\u003e \u003c!--配置事务参数--\u003e \u003ctx:attributes\u003e \u003c!--指定哪种规则在方法上面添加事务--\u003e \u003ctx:method name=\"accountMoney\"/\u003e \u003c/tx:attributes\u003e \u003c/tx:advice\u003e \u003c!--3 配置切入点和切面--\u003e \u003caop:config\u003e \u003c!--配置切入点--\u003e \u003caop:pointcut id=\"pt\" expression=\"execution(* com.clover.spring5.service.UserService.*(..))\"/\u003e \u003c!--配置切面--\u003e \u003caop:advisor advice-ref=\"txadvice\" pointcut-ref=\"pt\"/\u003e \u003c/aop:config\u003e ","date":"2021-10-29","objectID":"/spring5/:8:5","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"8.6、事务操作（完全注解声明式事务管理） 1、创建配置类，使用配置类替代xml配置文件 @Configuration//配置类 @ComponentScan(basePackages = \"com.clover\")//组件扫描 @EnableTransactionManagement //开启事务 public class TxConfig { //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() { DruidDataSource dataSource = new DruidDataSource(); dataSource.setUrl(\"jdbc:mysql:///user_db\"); dataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); dataSource.setUsername(\"root\"); dataSource.setPassword(\"xn123456\"); return dataSource; } //创建JdbcTemplate对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) { //到ioc容器中根据类型找到dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; } //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) { DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; } } ","date":"2021-10-29","objectID":"/spring5/:8:6","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"9、Spring5 框架新功能 1、整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方 法在代码库中删除 2、Spring 5.0 框架自带了通用的日志封装 Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 Spring5 框架整合 Log4j2 第一步 引入jar包 第二步 创建 log4j2.xml 配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!--日志级别以及优先级排序: OFF \u003e FATAL \u003e ERROR \u003e WARN \u003e INFO \u003e DEBUG \u003e TRACE \u003e ALL --\u003e \u003c!--Configuration后面的status用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，可以看到log4j2内部各种详细输出--\u003e \u003cconfiguration status=\"INFO\"\u003e \u003c!--先定义所有的appender--\u003e \u003cappenders\u003e \u003c!--输出日志信息到控制台--\u003e \u003cconsole name=\"Console\" target=\"SYSTEM_OUT\"\u003e \u003c!--控制日志输出的格式--\u003e \u003cPatternLayout pattern=\"%d{yyyy-MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/\u003e \u003c/console\u003e \u003c/appenders\u003e \u003c!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--\u003e \u003c!--root：用于指定项目的根日志，如果没有单独指定Logger，则会使用root作为默认的日志输出--\u003e \u003cloggers\u003e \u003croot level=\"info\"\u003e \u003cappender-ref ref=\"Console\"/\u003e \u003c/root\u003e \u003c/loggers\u003e \u003c/configuration\u003e 3、Spring5 框架核心容器支持@Nullable 注解 @Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空 注解用在方法上面，方法返回值可以为空 注解使用在方法参数里面，方法参数可以为空 注解使用在属性上面，属性值可以为空 4、Spring5 核心容器支持函数式风格 GenericApplicationContext //函数式风格创建对象，交给spring进行管理 @Test public void testGenericApplicationContext() { //1 创建GenericApplicationContext对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用context的方法对象注册 context.refresh(); context.registerBean(\"user1\",User.class,() -\u003e new User()); //3 获取在spring注册的对象 // User user = (User)context.getBean(\"com.clover.spring5.Test.User\"); User user = (User)context.getBean(\"user1\"); System.out.println(user); } 5、Spring5 支持整合 JUnit5 整合 JUnit4 第一步 引入 Spring相关针对测试依赖 第二步 创建测试类，使用注解方式完成 unWith(SpringJUnit4ClassRunner.class)//指定单元测试框架 ontextConfiguration(\"classpath:bean1.xml\") //加载配置文件 blic class JTest4 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } Spring5 整合 JUnit5 第一步 引入 JUnit5 的 jar 包 第二步 创建测试类，使用注解完成 import com.clover.spring5.service.UserService; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.test.context.ContextConfiguration; import org.springframework.test.context.junit.jupiter.SpringExtension; @ExtendWith(SpringExtension.class) @ContextConfiguration(\"classpath:bean1.xml\") public class JTest5 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } } 使用一个复合注解替代上面两个注解完成整合 @SpringJUnitConfig(locations = \"classpath:bean1.xml\") public class JTest5 { @Autowired private UserService userService; @Test public void test1() { userService.accountMoney(); } } ","date":"2021-10-29","objectID":"/spring5/:9:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["Spring"],"content":"10、Spring5 框架新功能（Webflux） 1、SpringWebflux 介绍 是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流行响应式编程出现的框架 使用传统 web 框架，比如 SpringMVC，这些基于 Servlet 容器，Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的 解释什么是异步非阻塞 异步和同步；非阻塞和阻塞 上面都是针对对象不一样 异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不等着对方回应就去做其他事情就是异步 阻塞和非阻塞针对被调用者，被调用者收到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞 Webflux 特点 第一 异步非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以Reactor为基础实现响应式编程 第二 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8函数式编程方式实现路由请求 比较 SpringMVC 第一 两个框架都可以使用注解方式，都运行在Tomcat等容器中 第二 SpringMVC采用命令式编程，Webflux采用异步响应式编程 2、响应式编程（Java 实现） 什么是响应式编程 响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播 电子表格程序就是响应式编程的一个例子。单元格可以包含字面值或类似\"=B1+C1\"的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化 Java8及其之前版本 提供的观察者模式两个类 Observer 和 Observable public class ObserverDemo extends Observable { public static void main(String[] args) { ObserverDemo observerDemo = new ObserverDemo(); //添加观察者 observerDemo.addObserver((o,arg)-\u003e{ System.out.println(\"发生变化\"); }); observerDemo.addObserver((o,arg)-\u003e{ System.out.println(\"手动被观察者通知，准备改变\"); }); observerDemo.setChanged(); //监控数据变化 observerDemo.notifyObservers(); //通知 } } 3、响应式编程（Reactor 实现） 响应式编程操作中，Reactor 是满足 Reactive 规范框架 Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富操作符。Flux对象实现发布者，返回 N个元素；Mono实现发布者，返回 0或者1个元素 Flux和 Mono都是数据流的发布者，使用 Flux和 Mono 都可以发出三种数据信号： 元素值，错误信号，完成信号，错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者 代码演示 Flux 和 Mono ","date":"2021-10-29","objectID":"/spring5/:10:0","tags":["Spring"],"title":"Spring5","uri":"/spring5/"},{"categories":["SpringCloud"],"content":"SpringCloud","date":"2021-10-14","objectID":"/springcloud/","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"1、从2.2.x和H版本开始说起 ","date":"2021-10-14","objectID":"/springcloud/:1:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"1.1、SpringBoot版本选择 GitHub源码地址 SpringBoot2.0新特性 通过上面官网发现，Boot官方强烈建议你升级到2.X以上版本 ","date":"2021-10-14","objectID":"/springcloud/:1:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"1.2、SpringCloud版本选择 GitHub源码地址 官网 1.2.1、Cloud命名规则 Spring Cloud 采用了英国伦敦地铁站的名称来命名，并由地铁站名称字母A-Z依次类推的形式来发布迭代 版本SpringCloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。为了管理SpringCloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个SpringCloud版本对应的子项目版本。为了避免SpringCloud版本号与子项目版本号混淆，SpringCloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序。例如Angel是第一个版本, Brixton是第二个版本。 当SpringCloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个\"service releases\"版本，简称SRX版本，比如Greenwich.SR2就是SpringCloud发布的Greenwich版本的第2个SRX版本。 ","date":"2021-10-14","objectID":"/springcloud/:1:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"1.3、SpringCloud和SpringBoot之间的依赖关系如何看 官网说明 1.3.1、依赖 Finchley 是基于 Spring Boot 2.0.x 构建的不再 Boot 1.5.x Dalston 和 Edgware 是基于 Spring Boot 1.5.x 构建的，不支持 Spring Boot 2.0.x Camden 构建于 Spring Boot 1.4.x，但依然能支持 Spring Boot 1.5.x 更详细的版本对应查看方法 ","date":"2021-10-14","objectID":"/springcloud/:1:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"1.4、目前使用版本 1.4.1、题外话 boot版本以及到2.2.4为最新(截止2020.2.15)，为什么选2.2.2 只用boot，直接用最新 同时用boot和cloud，需要照顾cloud，由cloud决定boot版本 SpringCloud和SpringBoot版本对应关系 X版本常用的组件pom \u003cdependencies\u003e \u003c!--spring boot 2.2.2--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud Hoxton.SR1--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud alibaba 2.1.0.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-10-14","objectID":"/springcloud/:1:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"2、关于Cloud各种组件的停更/升级/替换 以前学习 现在 SpringCloud官方文档 SpringCloud中文文档 SpringBoot官方文档 ","date":"2021-10-14","objectID":"/springcloud/:2:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3、微服务架构编码构建 约定 \u003e 配置 \u003e 编码 ","date":"2021-10-14","objectID":"/springcloud/:3:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3.1、IDEA新建project工作空间 创建maven项目 设置字符编码为utf-8 设置注解生效激活 Java编译版本选择8 File Type过滤 (可选) ","date":"2021-10-14","objectID":"/springcloud/:3:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3.2、父工程POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003cpackaging\u003epom\u003c/packaging\u003e \u003c!-- 统一管理jar包版本 --\u003e \u003cproperties\u003e \u003cproject.build.sourceEncoding\u003eUTF-8\u003c/project.build.sourceEncoding\u003e \u003cmaven.compiler.source\u003e1.8\u003c/maven.compiler.source\u003e \u003cmaven.compiler.target\u003e1.8\u003c/maven.compiler.target\u003e \u003cjunit.version\u003e4.12\u003c/junit.version\u003e \u003clog4j.version\u003e1.2.17\u003c/log4j.version\u003e \u003clombok.version\u003e1.16.18\u003c/lombok.version\u003e \u003cmysql.version\u003e5.1.47\u003c/mysql.version\u003e \u003cdruid.version\u003e1.1.16\u003c/druid.version\u003e \u003cmybatis.spring.boot.version\u003e1.3.0\u003c/mybatis.spring.boot.version\u003e \u003c/properties\u003e \u003c!-- 子模块继承之后，提供作用：锁定版本+子modlue不用写groupId和version --\u003e \u003cdependencyManagement\u003e \u003cdependencies\u003e \u003c!--spring boot 2.2.2--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.2.2.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud Hoxton.SR1--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-dependencies\u003c/artifactId\u003e \u003cversion\u003eHoxton.SR1\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003c!--spring cloud alibaba 2.1.0.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e${mysql.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid\u003c/artifactId\u003e \u003cversion\u003e${druid.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e${mybatis.spring.boot.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e${junit.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e${log4j.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e${lombok.version}\u003c/version\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/dependencyManagement\u003e \u003cbuild\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-maven-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cfork\u003etrue\u003c/fork\u003e \u003caddResources\u003etrue\u003c/addResources\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e \u003c/project\u003e ","date":"2021-10-14","objectID":"/springcloud/:3:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3.3、Maven工程落地细节复习 3.3.1、Maven中的DependencyManagement和Dependencies Maven 使用 dependencyManagement 元素来提供了一种管理依赖版本号的方式。 通常会在一个组织或者项目的最顶层的父POM 中看到 dependencyManagement 元素。 使用 pom.xml 中的 dependencyManagement 元素能让所有在子项目中引用一个依赖而不用显式的列出版本号。 Maven 会沿着父子层次向上走，直到找到一个拥有 dependencyManagement 元素的项目，然后它就会使用这个 dependencyManagement 元素中指定的版本号。 这样做的好处就是： 如果有多个子项目都引用同一样依赖，则可以避免在每个使用的子项目里都声明一个版本号，这样当想升级或切换到另一 个版本时，只需要在顶层父容器里更新，而不需要一个一个子项目的修改;另外如果某个子项目需要另外的一个版本，只需 要声明version就可。 dependencyManagement 里只是声明依赖，并不实现引入，因此子项目需要显示的声明需要用的依赖。 如果不在子项目中声明依赖，是不会从父项目中继承下来的；只有在子项目中写了该依赖项，并且没有指定具体版本，才会从父项目中继承该项，并且version和scope都读取自父pom; 如果子项目中指定了版本号，那么会使用子项目中指定的jar版本。 3.3.2、Maven中跳过单元测试 配置 \u003cbuild\u003e\u003c!-- maven中跳过单元测试 --\u003e \u003cplugins\u003e \u003cplugin\u003e \u003cgroupId\u003eorg.apache.maven.plugins\u003c/groupId\u003e \u003cartifactId\u003emaven-surefire-plugin\u003c/artifactId\u003e \u003cconfiguration\u003e \u003cskip\u003etrue\u003c/skip\u003e \u003c/configuration\u003e \u003c/plugin\u003e \u003c/plugins\u003e \u003c/build\u003e IDEA工具支持 (推荐) ","date":"2021-10-14","objectID":"/springcloud/:3:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3.4、Rest微服务工程构建 3.4.1、提供者模块构建 cloud-provider-payment8001微服务提供者支付Module模块 新建 cloud-provider-payment8001 修改POM文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-provider-payment8001\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003c!--mysql-connector-java--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-jdbc\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 编写YML server: port: 8001 spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springcloud?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false username: root password: xn123456 mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.clover.springcloud.entities # 所有Entity别名类所在包 建立主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } 业务类 测试 3.4.2、小知识点补充 1、为什么DAO层传入参数时为什么使用@Param注解 因为java没有保存行参的记录，java在运行的时候会把List queryAll(int offset,int limit);中的参数变成这样: queryAll(int arg0,int arg1),这样我们就没有办法去传递多个参数。所以需要使用@Param注解给方法参数命名，然后在xml 文件的该dao层方法对应的sql语句中就可以正常使用@Param注解的参数名。 还可以传入多个参数 参考博客 2、Controller层使用GetMapping时为什么使用PathVariable注解 1.因为PathVariable注解用于处理动态URL 2.在GetMapping定义的URL路径中存在变量传递，使用PathVariable注解可获取该变量的值 3.默认情况下，Spring会对PathVariable注解的变量进行自动赋值，当然你也可以指定PathVariable注解使用哪一个URL中的变量 4.你也可以定义多个URL变量，但是你在函数的形参中使用该注解时，必须显示的表名具体是哪个URL变量值 参考博客 3、POST请求时为什么要使用RequestBody注解 RequestBody注解可以将请求体中的JSON字符串绑定到相应的bean上，也可以将其绑定到对应的字符串上 参考博客1 参考博客2 主实体Payment package com.clover.springcloud.entities; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import java.io.Serializable; @Data @AllArgsConstructor @NoArgsConstructor public class Payment implements Serializable { private Long id; private String serial; } Json封装体CommonResult package com.clover.springcloud.entities; import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; /* * 返回给前端人员的数据，实体类是供给我们后端人员使用的 * 给前端人员只需要将状态与数据返回过去给其就行 */ @Data @AllArgsConstructor @NoArgsConstructor public class CommonResult\u003cT\u003e { private Integer code; private String message; private T data; public CommonResult(Integer code,String message) { this(code,message,null); } } 接口PaymentDao package com.clover.springcloud.dao; import com.clover.springcloud.","date":"2021-10-14","objectID":"/springcloud/:3:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"3.5、工程重构 发现问题：项目中有重复部分，重构 新建 cloud-api-commons 模块 修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003e5.1.0\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 将entities复制过来 执行maven的 clean 和 install 命令 改造订单80和支付8001 删除原有的entities文件夹 各自粘贴POM内容 \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-10-14","objectID":"/springcloud/:3:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4、Eureka服务注册与发现 ","date":"2021-10-14","objectID":"/springcloud/:4:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.1、Eureka基础知识 4.1.1、什么是服务治理 SpringCloud 封装了 Netflix 公司开发的 Eureka 模块来实现服务治理 在传统的rpc远程调用框架中，管理每个服务与服务之间依赖关系比较复杂，管理比较复杂，所以需要使用服务治理，管理服务与服务之间依赖关系，可以实现服务调用、负载均衡、容错等，实现服务发现与注册。 4.1.2、什么是服务注册 Eureka 采用了CS的设计架构，Eureka Server 作为服务注册功能的服务器，它是服务注册中心。而系统中的其他微服务，使用 Eureka 的客户端连接到 Eureka Server 并维持心跳连接。这样系统的维护人员就可以通过 Eureka Server 来监控系统中各个微服务是否正常运行。 在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息,比如 服务地址、通讯地址等以别名方式注册到注册中心上。另一方（消费者|服务提供者），以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用RPC远程框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系(服务治理概念)。在任何RPC远程框架中，都会有一个注册中心(存放服务地址相关信息(接口地址)) 4.1.3、Eureka两组件 Eureka Server提供服务注册服务 各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。 EurekaClient通过注册中心进行访问 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后，将会向Eureka Server发送心跳(默认周期为30秒)。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒） ","date":"2021-10-14","objectID":"/springcloud/:4:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.2、单机Eureka构建步骤 4.2.1、IDEA生成eurekaServer端服务注册中心类似物业公司 新建 springcloud-eureka-server7001 模块 修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003espringcloud-eureka-server7001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--eureka-server--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--boot web actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 编写YML server: port: 7001 eureka: instance: hostname: localhost #eureka服务端的实例名称 client: #false表示不向注册中心注册自己。 register-with-eureka: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 fetch-registry: false service-url: #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址。 defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 新建主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaMain7001 { public static void main(String[] args) { SpringApplication.run(EurekaMain7001.class,args); } } 4.2.2、EurekaClient端cloud-provider-payment8001 将其注册进 EurekaServer 成为服务提供者provider，类似尚硅谷学校对外提供授课服务 改写POM \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 改写YML eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 改变主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } 测试： 1、先要启动EurekaServer 2、访问 http://localhost:7001 3、微服务注册名配置说明 自我保护机制 4.2.3、EurekaClient端cloud-consumer-order80 将其注册进 EurekaServer 成为服务消费者consumer，类似来尚硅谷上课消费的各位同学 修改POM \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 修改YML spring: application: name: cloud-order-service eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka 修改主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootA","date":"2021-10-14","objectID":"/springcloud/:4:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.3、集群Eureka构建步骤 4.3.1、Eureka集群原理说明 EurekaServer 集群是互相注册，相互守望 问题：微服务RPC远程服务调用最核心的是什么 高可用，试想你的注册中心只有一个only one， 它出故障了那就呵呵(￣▽￣)\"了，会导致整个为服务环境不可用，所以 解决办法：搭建Eureka注册中心集群 ，实现负载均衡+故障容错 4.3.2、EurekaServer集群环境构建步骤 1、参考 springcloud-eureka-server7001 新建 springcloud-eureka-server7002 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003espringcloud-eureka-server7002\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--eureka-server--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--boot web actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、修改映射配置 找到C:\\Windows\\System32\\drivers\\etc路径下的hosts文件 修改映射配置添加进hosts文件 127.0.0.1 eureka7001.com 127.0.0.1 eureka7002.com 如果你的用户无法编辑host文件：参考博客 4、改写以前的YML (以前单机) 5、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer; @SpringBootApplication @EnableEurekaServer public class EurekaMain7002 { public static void main(String[] args) { SpringApplication.run(EurekaMain7002.class,args); } } 4.3.3、将支付服务8001微服务发布到上面2台Eureka集群配置中 server: port: 8001 spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springcloud?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false username: root password: xn123456 eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: #defaultZone: http://localhost:7001/eureka # 单机版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.clover.springcloud.entities # 所有Entity别名类所在包 4.3.4、将订单服务80微服务发布到上面2台Eureka集群配置中 server: port: 80 spring: application: name: cloud-order-service eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: #defaultZone: http://localhost:7001/eureka # 单机版 defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 测试 1、先要启动EurekaServer，7001/7002服务 2、再要启动服务提供者provider，8001 3、再要启动消费者，80 4、最后用查询验证是否正确：http://localhost/consumer/payment/get/1 4.3.5、支付服务提供者8001集群环境构建 1、参考 cloud-provider-payment8001 新建 cloud-provider-payment8002 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cart","date":"2021-10-14","objectID":"/springcloud/:4:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.4、actuator微服务信息完善 4.4.1、主机名称:服务名称修改 当前问题 修改cloud-provider-payment8001/8002 server: port: 8001 spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/db2019?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false username: root password: 123456 eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 #defaultZone: http://localhost:7001/eureka # 单机版 instance: instance-id: payment8001 mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entities # 所有Entity别名类所在包 修改之后 4.4.2、访问信息有IP信息提示 当前问题：没有IP提示 修改cloud-provider-payment8001/8002 server: port: 8001 spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 url: jdbc:mysql://localhost:3306/db2019?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false username: root password: 123456 eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 #defaultZone: http://localhost:7001/eureka # 单机版 instance: instance-id: payment8001 prefer-ip-address: true #访问路径可以显示IP地址 mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.atguigu.springcloud.entities # 所有Entity别名类所在包 修改之后 ","date":"2021-10-14","objectID":"/springcloud/:4:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.5、服务发现Discovery 对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息 1、修改 cloud-provider-payment8001 的Controller package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @Slf4j public class PaymentController { @Resource public PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @Resource private DiscoveryClient discoveryClient; @PostMapping(value = \"/payment/create\") public CommonResult create(@RequestBody Payment payment) { int result = paymentService.create(payment); log.info(\"********插入操作结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入数据成功，serverPort：\" + serverPort,result); }else { return new CommonResult(404,\"插入数据失败\",null); } } @GetMapping(value = \"/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { Payment payment = paymentService.getPaymentById(id); log.info(\"********查询结果：\"+ payment); if (payment !=null){ return new CommonResult(200,\"查询成功，serverPort：\" + serverPort,payment); }else { return new CommonResult(404,\"查询失败\",null); } } @GetMapping(value = \"/payment/discovery\") public Object discovery() { // 用于查询Eureka上有几个服务 List\u003cString\u003e services = discoveryClient.getServices(); for (String element: services) { log.info(\"***************element:\" + element); } // 用于查询某一个名称下的实例 List\u003cServiceInstance\u003e instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\"); for (ServiceInstance element: instances) { log.info(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); } return this.discoveryClient; } } 2、在8001主启动类上加上@EnableDiscoveryClient注解 3、测试 先启动EurekaServer 再启动8001主启动类 最后用查询验证是否正确：http://localhost:8001/payment/discovery ","date":"2021-10-14","objectID":"/springcloud/:4:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"4.6、Eureka自我保护机制 4.6.1、故障现象 4.6.1.1、概述 保护模式主要用于一组客户端和Eureka Server之间存在网络分区场景下的保护。一旦进入保护模式， Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。 如果在Eureka Server的首页看到以下这段提示，则说明Eureka进入了保护模式： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE 4.6.2、导致原因 4.6.2.1、为什么会产生Eureka自我保护机制？ 为了防止EurekaClient可以正常运行，但是与 EurekaServer 网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除 4.6.2.2、什么是自我保护模式 默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生(延时、卡顿、拥挤)时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险了——因为微服务本身其实是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障），那么这个节点就会进入自我保护模式。 在自我保护模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例。 它的设计哲学就是宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。一句话讲解：好死不如赖活着 综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务（健康的微服务和不健康的微服务都会保留）也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。 一句话：某时刻某一个微服务不可用了，Eureka不会立刻清理，依旧会对该微服务的信息进行保存 4.6.3、怎么禁止自我保护 4.6.3.1、修改注册中心eureakeServer端7001 1、出厂默认，自我保护机制是开启的eureka.server.enable-self-preservation=true 2、使用eureka.server.enable-self-preservation = false 可以禁用自我保护模式 server: port: 7001 eureka: instance: hostname: eureka7001.com #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己。 fetch-registry: false #false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务 service-url: #defaultZone: http://eureka7002.com:7002/eureka/ defaultZone: http://eureka7001.com:7001/eureka server: #关闭自我保护机制，保证不可用服务被及时踢除 enable-self-preservation: false eviction-interval-timer-in-ms: 2000 3、关闭效果 4.6.3.2、修改生产者客户端eureakeClient端8001 1、默认设置 eureka.instance.lease-renewal-interval-in-seconds=30单位为秒(默认是30秒) eureka.instance.lease-expiration-duration-in-seconds=90单位为秒(默认是90秒) 2、配置 server: port: 8001 spring: application: name: cloud-payment-service datasource: type: com.alibaba.druid.pool.DruidDataSource # 当前数据源操作类型 driver-class-name: org.gjt.mm.mysql.Driver # mysql驱动包 com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/springcloud?useUnicode=true\u0026characterEncoding=utf-8\u0026useSSL=false username: root password: xn123456 eureka: client: #表示是否将自己注册进EurekaServer默认为true。 register-with-eureka: true #是否从EurekaServer抓取已有的注册信息，默认为true。单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡 fetchRegistry: true service-url: defaultZone: http://localhost:7001/eureka # 单机版 #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka # 集群版 #心跳检测与续约时间 #开发时设置小些，保证服务关闭后注册中心能及时剔除服务 instance: instance-id: payment8001 prefer-ip-address: true #访问路径可以显示IP地址 #Eureka客户端向服务端发送心跳的时间间隔，单位为秒(默认是30秒) lease-renewal-interval-in-seconds: 1 #Eureka服务端在收到最后一次心跳后等待时间上限，单位为秒(默认是90秒)，超时将剔除服务 lease-expiration-duration-in-seconds: 2 mybatis: mapperLocations: classpath:mapper/*.xml type-aliases-package: com.clover.springcloud.entities # 所有Entity别名类所在包 3、测试 7001和8001都配置完成 先启动7001再启动8001 先关闭8001，马上就被删除了 ","date":"2021-10-14","objectID":"/springcloud/:4:6","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"5、Zookeeper服务注册与发现 ","date":"2021-10-14","objectID":"/springcloud/:5:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"5.1、SpringCloud整合Zookeeper代替Eureka 5.1.1、注册中心Zookeeper zookeeper是一个分布式协调工具，可以实现注册中心功能 关闭Linux服务器防火墙后启动zookeeper服务器 zookeeper服务器取代Eureka服务器，zk作为服务注册中心 5.1.2、服务提供者 1、新建cloud-provider-payment8004 2、修改POM \u003cdependencies\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合zookeeper客户端 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zookeeper-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-devtools\u003c/artifactId\u003e \u003cscope\u003eruntime\u003c/scope\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML #8004表示注册到zookeeper服务器的支付服务提供者端口号 server: port: 8004 #服务别名----注册zookeeper到注册中心名称 spring: application: name: cloud-provider-payment cloud: zookeeper: connect-string: 192.168.167.48:2181 4、创建主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务 public class PaymentMain8004 { public static void main(String[] args) { SpringApplication.run(PaymentMain8004.class,args); } } 5、编写Controller package com.clover.springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.UUID; @RestController @Slf4j public class PaymentController { @Value(\"${server.port}\") private String serverPort; @GetMapping(value = \"/payment/zk\") public String paymentzk() { return \"springcloud with zookeeper:\" + serverPort + \"\\t\" + UUID.randomUUID().toString(); } } 6、启动8004注册进zookeeper 启动后问题 成功关闭了Linux防火墙时出现的问题 如果你没有关闭防火墙就运行，会出现该报错 7、why？ 解决zookeeper版本jar包冲突问题 排除zk冲突后的新POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-provider-payment8004\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合zookeeper客户端 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zookeeper-discovery\u003c/artifactId\u003e \u003c!--先排除自带的zookeeper3.5.3--\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cgroupId\u003eorg.apache.zookeeper\u003c/groupId\u003e \u003cartifactId\u003ezookeeper\u003c/artifactId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003c!--添加zookeeper3.4.9版本--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.apache.zookeeper\u003c/groupId\u003e \u003cartifactId\u003ezookeeper\u003c/artifactId\u003e \u003cversion\u003e3.4.9\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-te","date":"2021-10-14","objectID":"/springcloud/:5:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6、Consul服务注册与发现 ","date":"2021-10-14","objectID":"/springcloud/:6:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6.1、Consul简介 Consul是什么？ 官网 Consul能干嘛？ 服务发现：提供HTTP和DNS两种发现方式。 健康监测：支持多种方式，HTTP、TCP、Docker、Shell脚本定制化监控 KV存储：Key、Value的存储方式 多数据中心：Consul支持多数据中心 可视化Web界面 Consul去哪下？ 下载地址 Consul怎么玩？ Consul中文文档 ","date":"2021-10-14","objectID":"/springcloud/:6:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6.2、安装并运行Consul 官网安装说明 下载完成后只有一个consul.exe文件，硬盘路径下双击运行，查看版本号信息 使用开发模式启动 consul agent -dev 通过以下地址可以访问Consul的首页：http://localhost:8500 结果页面 ] ","date":"2021-10-14","objectID":"/springcloud/:6:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6.3、服务提供者 1、新建 cloud-providerconsul-payment8006 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-providerconsul-payment8006\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud consul-server --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-consul-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML ###consul服务端口号 server: port: 8006 spring: application: name: consul-provider-payment ####consul注册中心地址 cloud: consul: host: localhost port: 8500 discovery: #hostname: 127.0.0.1 service-name: ${spring.application.name} 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class PaymentMain8006 { public static void main(String[] args) { SpringApplication.run(PaymentMain8006.class,args); } } 5、编写Controller package com.clover.springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import java.util.UUID; @RestController @Slf4j public class PaymentController { @Value(\"${server.port}\") private String serverPort; @GetMapping(\"/payment/consul\") public String paymentInfo() { return \"springcloud with consul: \"+serverPort+\"\\t\\t\"+ UUID.randomUUID().toString(); } } 6、验证测试：http://localhost:8006/payment/consul ","date":"2021-10-14","objectID":"/springcloud/:6:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6.4、服务消费者 1、新建 cloud-consumerconsul-order80 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumerconsul-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud consul-server --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-consul-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML ###consul服务端口号 server: port: 80 spring: application: name: consul-consumer-order ####consul注册中心地址 cloud: consul: host: localhost port: 8500 discovery: #hostname: 127.0.0.1 service-name: ${spring.application.name} 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient //该注解用于向使用consul或者zookeeper作为注册中心时注册服务 public class OrderConsulMain80 { public static void main(String[] args) { SpringApplication.run(OrderConsulMain80.class,args); } } 5、配置Bean package com.clover.springcloud.config; import org.springframework.cloud.client.loadbalancer.LoadBalanced; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.web.client.RestTemplate; @Configuration public class ApplicationContextConfig { @Bean @LoadBalanced public RestTemplate getRestTemplate() { return new RestTemplate(); } } 6、编写Controller package com.clover.springcloud.controller; import lombok.extern.slf4j.Slf4j; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import org.springframework.web.client.RestTemplate; import javax.annotation.Resource; @RestController @Slf4j public class OrderConsulController { private static final String INVOKE_URL = \"http://consul-provider-payment\"; @Resource private RestTemplate restTemplate; @GetMapping(value = \"/consumer/payment/consul\") public String paymentInfo() { String result = restTemplate.getForObject(INVOKE_URL + \"/payment/consul\", String.class); log.info(\"消费者调用支付服务(consul)---\u003eresult:\" + result); return result; } } 7、验证测试 8、访问测试地址：http://localhost/consumer/payment/consul ","date":"2021-10-14","objectID":"/springcloud/:6:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"6.5、三个注册中心异同点 １、CAP C:Consistency（强一致性） A:Availability（可用性） P:Partition tolerance（分区容错性） CAP理论关注粒度是数据，而不是整体系统设计的策略 ２、经典CAP图 最多只能同时较好的满足两个。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求， 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则 三大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍必的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 AP(Eureka) AP架构 当网络分区出现后，为了保证可用性，系统B可以返回旧值，保证系统的可用性。 结论：违背了一致性C的要求，只满足可用性和分区容错，即AP CP(Zookeeper/Consul) CP架构 当网络分区出现后，为了保证一致性，就必须拒接请求，否则无法保证一致性 结论：违背了可用性A的要求，只满足一致性和分区容错，即CP ","date":"2021-10-14","objectID":"/springcloud/:6:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"7、Ribbon负载均衡服务调用 ","date":"2021-10-14","objectID":"/springcloud/:7:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"7.1、概述 Ribbon是什么？ SpringCloud Ribbon是基于Netflix Ribbon实现的一套客户端 负载均衡的工具。 简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法和服务调用。Ribbon客户端组件提供一系列完善的配置项如连接超时，重试等。简单的说，就是在配置文件中列出LoadBalancer（简称LB）后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随机连接等）去连接这些机器。我们很容易使用Ribbon实现自定义的负载均衡算法 官网资料 官方资料 Ribbon目前也进入维护模式 未来替换方案 能干吗？ LB(负载均衡) 集中式LB 即在服务的消费方和提供方之间使用独立的LB设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把访问请求通过某种策略转发至服务的提供方 进程内LB 将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器 Ribbon就属于进程内LB，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址 前面我们讲解过了80通过轮询负载访问8001/8002 一句话：负载均衡+RestTemplate调用 LB负载均衡(Load Balance)是什么 简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用）。 常见的负载均衡有软件Nginx，LVS，硬件 F5等。 Ribbon本地负载均衡客户端 VS Nginx服务端负载均衡区别 Nginx是服务器负载均衡，客户端所有请求都会交给nginx，然后由nginx实现转发请求。即负载均衡是由服务端实现的。 Ribbon本地负载均衡，在调用微服务接口时候，会在注册中心上获取注册信息服务列表之后缓存到JVM本地，从而在本地实现RPC远程服务调用技术。 ","date":"2021-10-14","objectID":"/springcloud/:7:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"7.2、Ribbon负载均衡演示 7.2.1、架构说明 Ribbon在工作时分成两步 第一步先选择 EurekaServer ,它优先选择在同一个区域内负载较少的server. 第二步再根据用户指定的策略，在从server取到的服务注册列表中选择一个地址。 其中Ribbon提供了多种策略：比如轮询、随机和根据响应时间加权。 总结：Ribbon其实就是一个软负载均衡的客户端组件，他可以和其他所需请求的客户端结合使用，和 eureka结合只是其中的一个实例。 7.2.2、POM 之前写cloud-consumer-order80样例时候没有引入spring-cloud-starter-ribbon也可以使用ribbon \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-ribbon\u003c/artifactId\u003e \u003c/dependency\u003e 猜测spring-cloud-starter-netflix-eureka-client自带了spring-cloud-starter-ribbon引用， 证明如下： 可以看到spring-cloud-starter-netflix-eureka-client 确实引入了Ribbon 7.2.3、二说RestTemplate的使用 官网 7.2.3.1、getForObject方法/getForEntity方法 返回对象为响应体中数据转化成的对象，基本上可以理解为Json 返回对象为ResponseEntity对象，包含了响应中的一些重要信息，比如响应头，状态码、响应体等 7.2.3.2、postForObject/postForEntity方法 ","date":"2021-10-14","objectID":"/springcloud/:7:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"7.3、Ribbon核心组件IRule 7.3.1、IRule：根据特定算法中从服务列表中选取一个要访问的服务 com.netflix.loadbalancer.RoundRobinRule：轮询 com.netflix.loadbalancer.RandomRule：随机 com.netflix.loadbalancer.RetryRule：先按照RoundRobinRule的策略获取服务，如果获取服务失败则在指定时间内会进行重试，获取可用的服务 WeightedResponseTimeRule：对RoundRobinRule的扩展，响应速度越快的实例选择权重越大，越容易被选择 BestAvailableRule：会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务 AvailabilityFilteringRule：先过滤掉故障实例，再选择并发较小的实例 ZoneAvoidanceRule：默认规则,复合判断server所在区域的性能和server的可用性选择服务器 7.3.2、如何替换 1、修改cloud-consumer-order80 2、注意配置细节 官方文档明确给出了警告： 这个自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下， 否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，达不到特殊化定制的目的了。 3、新建package ：com.clover.myrule 4、上面包下新建MySelfRule规则类 package com.clover.myrule; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.RandomRule; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class MySelfRule { @Bean public IRule myRule() { return new RandomRule();//定义为随机 } } 5、主启动类添加@RibbonClient package com.clover.springcloud; import com.clover.myrule.MySelfRule; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; import org.springframework.cloud.netflix.ribbon.RibbonClient; @SpringBootApplication @EnableEurekaClient @EnableDiscoveryClient @RibbonClient(name = \"CLOUD-PAYMENT-SERVICE\",configuration= MySelfRule.class) public class PaymentMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentMain8001.class,args); } } 6、测试：http://localhost/consumer/payment/get/1 ","date":"2021-10-14","objectID":"/springcloud/:7:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"7.4、Ribbon负载均衡算法 7.4.1、原理 负载均衡算法： rest接口第几次请求数 % 服务器集群总数量 = 实际调用服务器位置下标 ，每次服务重启动后rest接口计数从1开始。 List\u003c\u003e instances = discoveryClient.getInstances(“CLOUD-PAYMENT-SERVICE”); 如： List [0] instances = 127.0.0.1:8002 List [1] instances = 127.0.0.1:8001 8001+ 8002 组合成为集群，它们共计2台机器，集群总数为2， 按照轮询算法原理： 当总请求数为1时： 1 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001 当总请求数位2时： 2 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002 当总请求数位3时： 3 % 2 =1 对应下标位置为1 ，则获得服务地址为127.0.0.1:8001 当总请求数位4时： 4 % 2 =0 对应下标位置为0 ，则获得服务地址为127.0.0.1:8002 如此类推…… 7.4.2、手写一个本地负载均衡器 1、先启动7001/7002集群 2、8001/8002微服务改造 package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; @RestController @Slf4j public class PaymentController { @Resource public PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @Resource private DiscoveryClient discoveryClient; @PostMapping(value = \"/payment/create\") public CommonResult create(@RequestBody Payment payment) { int result = paymentService.create(payment); log.info(\"********插入操作结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入数据成功，serverPort：\" + serverPort,result); }else { return new CommonResult(404,\"插入数据失败\",null); } } @GetMapping(value = \"/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { Payment payment = paymentService.getPaymentById(id); log.info(\"********查询结果：\"+ payment); if (payment !=null){ return new CommonResult(200,\"查询成功，serverPort：\" + serverPort,payment); }else { return new CommonResult(404,\"查询失败\",null); } } @GetMapping(value = \"/payment/discovery\") public Object discovery() { // 用于查询Eureka上有几个服务 List\u003cString\u003e services = discoveryClient.getServices(); for (String element: services) { log.info(\"***************element:\" + element); } // 用于查询某一个名称下的实例 List\u003cServiceInstance\u003e instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\"); for (ServiceInstance element: instances) { log.info(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); } return this.discoveryClient; } @GetMapping(value = \"/payment/lb\") public String getPaymentLB() { return serverPort; } } package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; @RestController @Slf4j public class PaymentController { @Resource public PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @PostMapping(value = \"/payment/create\") public CommonResult create(@RequestBody Payment payment) { int result = paymentService.create(payment); log.info(\"********插入操作结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入数据成功，serverPort：\" + serverPort,result); }else { return new CommonResult(404,\"插入数据失败\",null); } } @GetMapping(value = \"/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { Payment payment = paymentService.getPaymentById(id); log.info(\"********查询结果：\"+ payment); if (payment !=null){ return new CommonResult(200,\"查询成功，serverPort：\" + serverPort,payment); }else { return new CommonResult(404,\"查询失败\",null); } } @GetMapping(value = \"/payment/lb\") public String getPaymentLB() { return serverPort; } } 3、80订单微服务改造 ApplicationContextBean 去掉注解@LoadBalanced 编写 LoadBalancer 接口 package com.clover.springcloud.lb; import org.springframework","date":"2021-10-14","objectID":"/springcloud/:7:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"8、OpenFeign服务接口调用 ","date":"2021-10-14","objectID":"/springcloud/:8:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"8.1、概述 8.1.1、OpenFeign是什么？ Feign是一个声明式的Web服务客户端，让编写Web服务客户端变得非常容易，只需创建一个接口并在接口上添加注解即可 源码地址 官网解释 Feign是一个声明式WebService客户端。使用Feign能让编写WebService客户端更加简单。 它的使用方法是定义一个服务接口然后在上面添加注解。Feign也支持可拔插式的编码器和解码器。SpringCloud对Feign进行了封装，使其支持了Spring MVC标准注解和HttpMessageConverters。Feign可以与Eureka和Ribbon组合使用以支持负载均衡 8.1.2、能干嘛？ Feign旨在使编写Java Http客户端变得更容易。 前面在使用Ribbon+RestTemplate时，利用 RestTemplate 对http请求的封装处理，形成了一套模版化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步封装，由他来帮助我们定义和实现依赖服务接口的定义。在Feign的实现下，我们只需创建一个接口并使用注解的方式来配置它(以前是Dao接口上面标注Mapper注解,现在是一个微服务接口上面标注一个Feign注解即可)，即可完成对服务提供方的接口绑定，简化了Spring cloud 使用Ribbon时，自动封装服务调用客户端的开发量。 Feign集成了Ribbon 利用Ribbon维护了Payment的服务列表信息，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用 8.1.3、Feign和OpenFeign两者区别 ","date":"2021-10-14","objectID":"/springcloud/:8:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"8.2、OpenFeign使用步骤 1、接口 + 注解：微服务调用接口+@FeignClient 2、新建 cloud-consumer-feign-order80 Feign在消费端使用 3、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-feign-order80\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--web--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.openfeign.EnableFeignClients; @SpringBootApplication @EnableFeignClients // 开启FeignClients注解的使用 public class OrderFeignMain80 { public static void main(String[] args) { SpringApplication.run(OrderFeignMain80.class,args); } } 5、业务类 业务逻辑接口+@FeignClient配置调用provider服务 新建PaymentFeignService接口并新增注解@FeignClient package com.clover.springcloud.service; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \"CLOUD-PAYMENT-SERVICE\") public interface PaymentFeignService { @GetMapping(value = \"/payment/get/{id}\") CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id); } 控制层Controller package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentFeignService; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController public class OrderFeignController { @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = \"/consumer/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { return paymentFeignService.getPaymentById(id); } } 6、测试 先启动2个eureka集群7001/7002 再启动2个微服务8001/8002 启动OpenFeign http://localhost/consumer/payment/get/1 Feign自带负载均衡配置项 7、总结 ","date":"2021-10-14","objectID":"/springcloud/:8:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"8.3、OpenFeign超时控制 8.3.1、超时设置，故意设置超时演示出错情况 服务提供方8001故意写暂停程序 package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; import java.util.concurrent.TimeUnit; @RestController @Slf4j public class PaymentController { @Resource public PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @Resource private DiscoveryClient discoveryClient; @PostMapping(value = \"/payment/create\") public CommonResult create(@RequestBody Payment payment) { int result = paymentService.create(payment); log.info(\"********插入操作结果：\"+ result); if (result \u003e 0){ return new CommonResult(200,\"插入数据成功，serverPort：\" + serverPort,result); }else { return new CommonResult(404,\"插入数据失败\",null); } } @GetMapping(value = \"/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { Payment payment = paymentService.getPaymentById(id); log.info(\"********查询结果：\"+ payment); if (payment !=null){ return new CommonResult(200,\"查询成功，serverPort：\" + serverPort,payment); }else { return new CommonResult(404,\"查询失败\",null); } } @GetMapping(value = \"/payment/discovery\") public Object discovery() { // 用于查询Eureka上有几个服务 List\u003cString\u003e services = discoveryClient.getServices(); for (String element: services) { log.info(\"***************element:\" + element); } // 用于查询某一个名称下的实例 List\u003cServiceInstance\u003e instances = discoveryClient.getInstances(\"CLOUD-PAYMENT-SERVICE\"); for (ServiceInstance element: instances) { log.info(element.getServiceId() + \"\\t\" + element.getHost() + \"\\t\" + element.getPort() + \"\\t\" + element.getUri()); } return this.discoveryClient; } @GetMapping(value = \"/payment/lb\") public String getPaymentLB() { return serverPort; } @GetMapping(value = \"/payment/feign/timeout\") public String paymentFeignTimeOut() { System.out.println(\"*****paymentFeignTimeOut from port: \"+serverPort); //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); } return serverPort; } } 服务消费方80添加超时方法 PaymentFeignService package com.clover.springcloud.service; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import org.springframework.cloud.openfeign.FeignClient; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; @FeignClient(value = \"CLOUD-PAYMENT-SERVICE\") public interface PaymentFeignService { @GetMapping(value = \"/payment/get/{id}\") CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id); @GetMapping(value = \"/payment/feign/timeout\") String paymentFeignTimeOut(); } 服务消费方80添加超时方法OrderFeignController package com.clover.springcloud.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import com.clover.springcloud.service.PaymentFeignService; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController public class OrderFeignController { @Resource private PaymentFeignService paymentFeignService; @GetMapping(value = \"/consumer/payment/get/{id}\") public CommonResult\u003cPayment\u003e getPaymentById(@PathVariable(\"id\") Long id) { return paymentFeignService.getPaymentById(id); } @GetMapping(value = \"/payment/feign/timeout\") public String paymentFeignTimeOut() { return paymentFeignService.paymentFeignTimeOut(); } } 测试 http://localhost/consumer/payment/feign/timeout 错误页面 8.3.2、OpenFeign默认等待1秒钟，超过后报错 8.3.3、是什么？ Feign客户端默认只等待一秒","date":"2021-10-14","objectID":"/springcloud/:8:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"8.4、OpenFeign日志打印功能 8.4.1、是什么？ Feign 提供了日志打印功能，我们可以通过配置来调整日志级别，从而了解 Feign 中 Http 请求的细节。 说白了就是对Feign接口的调用情况进行监控和输出 8.4.2、日志级别 NONE：默认的，不显示任何日志； BASIC：仅记录请求方法、URL、响应状态码及执行时间； HEADERS：除了 BASIC 中定义的信息之外，还有请求和响应的头信息； FULL：除了 HEADERS 中定义的信息之外，还有请求和响应的正文及元数据。 8.4.3、配置日志bean package com.clover.springcloud.config; import feign.Logger; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class FeignConfig { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; } } 8.4.5、YML文件里需要开启日志的Feign客户端 server: port: 80 eureka: client: register-with-eureka: false service-url: defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ #设置feign客户端超时时间(OpenFeign默认支持ribbon) ribbon: #指的是建立连接所用的时间，适用于网络状况正常的情况下,两端连接所用的时间 ReadTimeout: 5000 #指的是建立连接后从服务器读取到可用资源所用的时间 ConnectTimeout: 5000 logging: level: # feign日志以什么级别监控哪个接口 com.clover.springcloud.service.PaymentFeignService: debug 8.4.6、后台日志查看 ","date":"2021-10-14","objectID":"/springcloud/:8:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9、Hystrix断路器 ","date":"2021-10-14","objectID":"/springcloud/:9:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9.1、概述 9.1.1、分布式系统面临的问题 复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免地失败 服务雪崩 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，这就是所谓的扇出。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”. 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。 所以，通常当你发现一个模块下的某个实例失败后，这时候这个模块依然还会接收流量，然后这个有问题的模块还调用了其他的模块，这样就会发生级联故障，或者叫雪崩。 9.1.2、Hystrix是什么？ Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。 “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的、可处理的备选响应（FallBack），而不是长时间的等待或者抛出调用方无法处理的异常，这样就保证了服务调用方的线程不会被长时间、不必要地占用，从而避免了故障在分布式系统中的蔓延，乃至雪崩。 9.1.3、Hystrix能干嘛？ 服务降级 服务熔断 接近实时的监控 9.1.4、官网资料 官方资料 ","date":"2021-10-14","objectID":"/springcloud/:9:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9.2、Hystrix重要概念 9.2.1、服务降级 服务器忙，请稍后再试，不让客户端等待并立刻返回一个友好提示，fallback 哪些情况会触发降级 程序运行异常 超时 服务熔断触发降级 线程池/信号量打满也会导致服务降级 9.2.2、服务熔断 类比保险丝达到最大服务访问后，直接拒绝访问，拉闸限电，然后调用服务降级的方法并返回友好提示 就是保险丝 服务的降级-\u003e进而熔断-\u003e恢复调用链路 9.2.3、服务限流 服务限流 秒杀高并发等操作，严禁一窝蜂的过来拥挤，大家排队，一秒钟N个，有序进行 ","date":"2021-10-14","objectID":"/springcloud/:9:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9.3、hystrix案例 9.3.1、构建 1、新建 cloud-provider-hystrix-payment8001 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-provider-hystrix-payment8001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--hystrix--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--web--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 8001 spring: application: name: cloud-provider-hystrix-payment eureka: client: register-with-eureka: true fetch-registry: true service-url: #defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka defaultZone: http://eureka7001.com:7001/eureka 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient//本服务启动后会自动注册进eureka服务中 public class PaymentHystrixMain8001 { public static void main(String[] args) { SpringApplication.run(PaymentHystrixMain8001.class,args); } } 5、编写业务类 service package com.clover.springcloud.service; import org.springframework.stereotype.Service; import java.util.concurrent.TimeUnit; @Service public class PaymentService { /** * 正常访问，一切OK */ public String paymentInfo_OK(Integer id) { return \"线程池：\" + Thread.currentThread().getName() + \"paymentInfo_OK,id:\" + id; } /* * 超时访问，演示降级 */ public String paymentInfo_Timeout(Integer id) { int timeoutNumber = 3; //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(timeoutNumber); } catch (InterruptedException e) { e.printStackTrace(); } return \"线程池：\" + Thread.currentThread().getName() + \"paymentInfo_Timeout,id:\" + id + \"耗费时间：\" + timeoutNumber + \"秒\"; } } controller package com.clover.springcloud.controller; import com.clover.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController @Slf4j public class PaymentController { @Resource private PaymentService paymentService; @Value(\"${server.port}\") private String serverPort; @GetMapping(value = \"/payment/hystrix/ok/{id}\") public String paymentInfo_OK(@PathVariable(\"id\") Integer id) { String result = paymentService.paymentInfo_OK(id); log.info(\"*********result:\" + result); return result; } @GetMapping(value = \"/payment/hystrix/timeout/{id}\") public String paymentInfo_Timeout(@PathVariable(\"id\") Integer id) { String result = paymentService.paymentInfo_Timeout(id); log.info(\"*********result:\" + result); return result; } }","date":"2021-10-14","objectID":"/springcloud/:9:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9.4、hystrix工作流程 工作流程 Hystrix工作流程 官网图例 步骤说明 ","date":"2021-10-14","objectID":"/springcloud/:9:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"9.5、服务监控hystrixDashboard 9.5.1、概述 除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard），Hystrix会持续地记录所有通过Hystrix发起的请求的执行信息，并以统计报表和图形的形式展示给用户，包括每秒执行多少请求多少成功，多少失败等。Netflix通过hystrix-metrics-event-stream项目实现了对以上指标的监控。Spring Cloud也提供了Hystrix Dashboard的整合，对监控内容转化成可视化界面。 9.5.2、仪表盘9001 1、新建cloud-consumer-hystrix-dashboard9001 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-consumer-hystrix-dashboard9001\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-hystrix-dashboard\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 9001 4、新建启动类 HystrixDashboardMain9001+新注解@EnableHystrixDashboard package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard; @SpringBootApplication @EnableHystrixDashboard public class HystrixDashboardMain9001 { public static void main(String[] args) { SpringApplication.run(HystrixDashboardMain9001.class,args); } } 5、所有Provider微服务提供类(8001/8002/8003)都需要监控依赖配置 \u003c!-- actuator监控信息完善 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e 6、启动cloud-consumer-hystrix-dashboard9001该微服务后续将监控微服务8001：http://localhost:9001/hystrix 9.5.3、断路器演示(服务监控hystrixDashboard) 1、修改cloud-provider-hystrix-payment8001 注意:新版本Hystrix需要在主启动类MainAppHystrix8001中指定监控路径，否则会报错 /** *此配置是为了服务监控而配置，与服务容错本身无关，springcloud升级后的坑 *ServletRegistrationBean因为springboot的默认路径不是\"/hystrix.stream\"， *只要在自己的项目里配置上下面的servlet就可以了 */ @Bean public ServletRegistrationBean getServlet() { HystrixMetricsStreamServlet streamServlet = new HystrixMetricsStreamServlet(); ServletRegistrationBean registrationBean = new ServletRegistrationBean(streamServlet); registrationBean.setLoadOnStartup(1); registrationBean.addUrlMappings(\"/hystrix.stream\"); registrationBean.setName(\"HystrixMetricsStreamServlet\"); return registrationBean; } 2、监控测试 启动1个eureka或者3个eureka集群均可 观察监控窗口 9001监控8001：填写监控地址：http://localhost:8001/hystrix.stream 测试地址 http://localhost:8001/payment/circuit/1 http://localhost:8001/payment/circuit/-1 先访问正确地址，再访问错误地址，再正确地址，会发现图示断路器都是慢慢放开的 监控结果，成功 监控结果，失败 3、如何看懂该图 一圈 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，它的健康度从绿色\u003c黄色\u003c橙色\u003c红色递减 该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，就可以在大量的实例中快速的发现故障实例和高压力实例 一线 曲线：用来记录2分钟内流量的相对变化，可以通过它来观察到流量的上升和下降趋势 整图说明1 整图说明2 ","date":"2021-10-14","objectID":"/springcloud/:9:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10、Gateway新一代网关 ","date":"2021-10-14","objectID":"/springcloud/:10:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.1、概述 上一代zuul 1.X官网 当前Gateway官网 10.1.1、Gateway是什么？ 概述 Gateway是在Spring生态系统之上构建的API网关服务，基于Spring 5，Spring Boot 2和 Project Reactor等技术。 Gateway旨在提供一种简单而有效的方式来对API进行路由，以及提供一些强大的过滤器功能， 例如：熔断、限流、重试等 SpringCloud Gateway 是 SpringCloud 的一个全新项目，基于Spring 5.0+Spring Boot 2.0 和 Project Reactor等技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。 SpringCloud Gateway 作为 Spring Cloud 生态系统中的网关，目标是替代 Zuul，在Spring Cloud 2.0以上版本中，没有对新版本的Zuul 2.0以上最新高性能版本进行集成，仍然还是使用的Zuul 1.x非Reactor模式的老版本。而为了提升网关的性能，SpringCloud Gateway是基于WebFlux框架实现的，而WebFlux框架底层则使用了高性能的Reactor模式通信框架Netty。 SpringCloud Gateway的目标提供统一的路由方式且基于 Filter 链的方式提供了网关基本的功能，例如：安全，监控/指标，和限流。 一句话 SpringCloud Gateway 使用的Webflux中的reactor-netty响应式编程组件，底层使用了Netty通讯框架 源码架构 10.1.2、能干嘛？ 反向代理 鉴权 流量控制 熔断 日志监控 10.1.3、微服务架构中网关在哪里 10.1.4、有Zuul了怎么又出来了gateway 10.1.4.1、我们为什么选择Gateway？ neflix不太靠谱，zuul2.0一直跳票，迟迟不发布 一方面因为Zuul1.0已经进入了维护阶段，而且Gateway是SpringCloud团队研发的，是亲儿子产品，值得信赖。而且很多功能Zuul都没有用起来也非常的简单便捷。 Gateway是基于异步非阻塞模型上进行开发的，性能方面不需要担心。虽然Netflix早就发布了最新的 Zuul 2.x，但 Spring Cloud 貌似没有整合计划。而且Netflix相关组件都宣布进入维护期；不知前景如何？ 多方面综合考虑Gateway是很理想的网关选择。 SpringCloud Gateway具有如下特性 基于Spring Framework 5, Project Reactor 和 Spring Boot 2.0 进行构建 动态路由：能够匹配任何请求属性 可以对路由指定 Predicate（断言）和 Filter（过滤器） 集成Hystrix的断路器功能 集成 Spring Cloud 服务发现功能 易于编写的 Predicate（断言）和 Filter（过滤器） 请求限流功能 支持路径重写 SpringCloud Gateway 与 Zuul的区别 在SpringCloud Finchley 正式版之前，SpringCloud 推荐的网关是 Netflix 提供的Zuul Zuul 1.x，是一个基于阻塞 I/ O的 API Gateway Zuul 1.x 基于Servlet 2. 5使用阻塞架构它不支持任何长连接(如 WebSocket) Zuul 的设计模式和Nginx较像，每次 I/ O 操作都是从工作线程中选择一个执行，请求线程被阻塞到工作线程完成，但是差别是Nginx 用C++ 实现，Zuul 用 Java 实现，而 JVM 本身会有第一次加载较慢的情况，使得Zuul 的性能相对较差 Zuul 2.x理念更先进，想基于Netty非阻塞和支持长连接，但SpringCloud目前还没有整合。 Zuul 2.x的性能较 Zuul 1.x 有较大提升。在性能方面，根据官方提供的基准测试， Spring Cloud Gateway 的 RPS（每秒请求数）是Zuul 的 1. 6 倍。 SpringCloud Gateway 建立 在 Spring Framework 5、 Project Reactor 和 Spring Boot 2 之上， 使用非阻塞 API SpringCloud Gateway 还 支持 WebSocket， 并且与Spring紧密集成拥有更好的开发体验 10.1.4.2、Zuul1.x模型 Springcloud中所集成的Zuul版本，采用的是Tomcat容器，使用的是传统的Servlet IO处理模型 学过尚硅谷web中期课程都知道一个题目，Servlet的生命周期? servlet由servlet container进行生命周期管理。 container启动时构造servlet对象并调用servlet init()进行初始化； container运行时接受请求，并为每个请求分配一个线程（一般从线程池中获取空闲线程）然后调用service()。 container关闭时调用servlet destory()销毁servlet； 上述模式的缺点 servlet是一个简单的网络IO模型，当请求进入servlet container时，servlet container就会为其绑定一个线程，在并发不高的场景下这种模型是适用的。但是一旦高并发(比如抽风用jemeter压)，线程数量就会上涨，而线程资源代价是昂贵的（上线文切换，内存消耗大）严重影响请求的处理时间。在一些简单业务场景下，不希望为每个request分配一个线程，只需要1个或几个线程就能应对极大并发的请求，这种业务场景下servlet模型没有优势 所以Zuul 1.X是基于servlet之上的一个阻塞式处理模型，即spring实现了处理所有request请求的一个servlet（DispatcherServlet）并由该servlet阻塞式处理处理。所以Springcloud Zuul无法摆脱servlet模型的弊端 10.1.4.3、GateWay模型 WebFlux是什么?官网说明 说明 传统的Web框架，比如说：struts2，springmvc等都是基于Servlet API与Servlet容器基础之上运行的 但是在Servlet3.1之后有了异步非阻塞的支持。而WebFlux是一个典型非阻塞异步的框架，它的核心是基于Reactor的相关API实现的。相对于传统的web框架来说，它可以运行在诸如Netty，Undertow及支持Servlet3.1的容器上。非阻塞式+函数式编程（Spring5必须让你使用java8） Spring WebFlux 是 Spring 5.0 引入的新的响应式框架，区别于 Spring MVC，它不需要依赖Servlet API，它是完全异步非阻塞的，并且基于 Reactor 来实现响应式流规范 ","date":"2021-10-14","objectID":"/springcloud/:10:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.2、三大核心概念 Route(路由) 路由是构建网关的基本模块，它由ID，目标URI，一系列的断言和过滤器组成，如果断言为true则匹配该路由 Predicate(断言) 参考的是Java8的java.util.function.Predicate,开发人员可以匹配HTTP请求中的所有内容(例如请求头或请求参数)，如果请求与断言相匹配则进行路由 Filter(过滤) 指的是Spring框架中GatewayFilter的实例，使用过滤器，可以在请求被路由前或者之后对请求进行修改。 总体 web请求，通过一些匹配条件，定位到真正的服务节点。并在这个转发过程的前后，进行一些精细化控制 predicate就是我们的匹配条件 而filter，就可以理解为一个无所不能的拦截器。有了这两个元素，再加上目标uri，就可以实现一个具体的路由了 ","date":"2021-10-14","objectID":"/springcloud/:10:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.3、Gateway工作流程 官网总结 客户端向 SpringCloud Gateway 发出请求。然后在 Gateway Handler Mapping 中找到与请求相匹配的路由，将其发送到 Gateway Web Handler Handler 再通过指定的过滤器链来将请求发送到我们实际的服务执行业务逻辑，然后返回 过滤器之间用虚线分开是因为过滤器可能会在发送代理请求之前(“pre”) 或之后(“post”) 执行业务逻辑 Filter在pre类型的过滤器可以做参数校验、权限校验、流量监控、日志输出、协议转换等 在post类型的过滤器中可以做响应内容、响应头的修改，日志的输出，流量监控等有着非常重要的作用 核心逻辑 路由转发+执行过滤器链 ","date":"2021-10-14","objectID":"/springcloud/:10:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.4、入门配置 1、新建 cloud-gateway-gateway9527 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-gateway-gateway9527\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--gateway--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-gateway\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--eureka-client--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!--一般基础配置类--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 9527 spring: application: name: cloud-gateway eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class GateWayMain9527 { public static void main(String[] args) { SpringApplication.run(GateWayMain9527.class,args); } } 5、9527网关如何做路由映射那？？？ cloud-provider-payment8001看看controller的访问地址 get lb 我们目前不想暴露8001端口，希望在8001外面套一层9527 6、YML新增网关配置 server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: http://localhost:8001 #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 7、测试 启动7001 启动cloud-provider-payment8001 启动9527网关 访问说明 添加网关前：http://localhost:8001/payment/get/1 添加网关后：http://localhost:9527/payment/get/1 8、YML配置说明 Gateway网关路由有两种配置方式 在配置文件yml中配置 代码中注入RouteLocator的Bean 自己写一个 业务需求：通过9527网关访问到外网的百度新闻网址 编码 业务实现：config package com.clover.springcloud.config; import org.springframework.cloud.gateway.route.RouteLocator; import org.springframework.cloud.gateway.route.builder.RouteLocatorBuilder; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class GateWayConfig { /** * 配置了一个id为route-name的路由规则， * 当访问地址 http://localhost:9527/guonei时会自动转发到地址：http://news.baidu.com/guonei * @param routeLocatorBuilder * @return */ @Bean public RouteLocator custom(RouteLocatorBuilder routeLocatorBuilder) { RouteLocatorBuilder.Builder routes = routeLocatorBuilder.routes(); routes.route(\"path_route_clover\",r -\u003e r.path(\"/guonei\").uri(\"http://news.baidu.com/guonei\")).build(); return routes.build(); } } ","date":"2021-10-14","objectID":"/springcloud/:10:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.5、通过微服务名实现动态路由 默认情况下Gateway会根据注册中心注册的服务列表，以注册中心上微服务名为路径创建动态路由进行转发，从而实现动态路由的功能 启动：一个eureka7001 + 两个服务提供者8001/8002 修改POM \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e 修改YML 需要注意的是uri的协议为lb，表示启用Gateway的负载均衡功能 lb://serviceName是spring cloud gateway在微服务中自动为我们创建的负载均衡uri server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能，利用微服务名进行路由 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 测试: http://localhost:9527/payment/lb 8001/8002两个端口切换 ","date":"2021-10-14","objectID":"/springcloud/:10:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.6、Predicate的使用 10.6.1、Predicate是什么？ 启动我们的gateway9527 10.6.2、Route Predicate Factories这个是什么东东? Spring Cloud Gateway将路由匹配作为Spring WebFlux HandlerMapping基础架构的一部分。 Spring Cloud Gateway包括许多内置的Route Predicate工厂。所有这些Predicate都与HTTP请求的不同属性匹配。多个Route Predicate工厂可以进行组合 Spring Cloud Gateway 创建 Route 对象时， 使用 RoutePredicateFactory 创建 Predicate 对象，Predicate 对象可以赋值给 Route。 Spring Cloud Gateway 包含许多内置的Route Predicate Factories。 所有这些谓词都匹配HTTP请求的不同属性。多种谓词工厂可以组合，并通过逻辑and。 10.6.3、常用的Route Predicate 1、After Route Predicate server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 - After=2021-10-21T13:37:41.094+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 2、Before Route Predicate server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 - After=2021-10-21T13:37:41.094+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 - Before=2021-10-21T13:37:41.094+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 3、Between Route Predicate - Between=2019-12-02T17:45:06.206+08:00[Asia/Shanghai],2019-12-02T18:59:06.206+08:00[Asia/Shanghai] server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的进行路由 #- After=2021-10-21T13:37:41.094+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 #- Before=2021-10-21T13:37:41.094+08:00[Asia/Shanghai] # 断言，路径相匹配的进行路由 - Between=2021-10-21T13:37:41.094+08:00[Asia/Shanghai],2021-10-21T14:37:41.094+08:00[Asia/Shanghai] eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka #id：我们自定义的路由 ID，保持唯一 ##uri：目标服务地址 ##predicates：路由条件，Predicate接受一个输入参数返回一个布尔值。 ## 该属性包含多种默认方法来将Predicate组合成其他复杂的逻辑(比如：与，或，非) 4、Cookie Route Predicate server: port: 9527 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/get/** # 断言，路径相匹配的进行路由 - id: payment_routh2 #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 # uri: http://localhost:8001 #匹配后提供服务的路由地址 uri: lb://cloud-payment-service #匹配后提供服务的路由地址 predicates: - Path=/payment/lb/** # 断言，路径相匹配的","date":"2021-10-14","objectID":"/springcloud/:10:6","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"10.7、Filter的使用 是什么？ Spring Cloud Gateway的Filter 生命周期，Only Two pre post 种类，Only Two GatewayFilter 官网地址 GlobalFilter 常用的GatewayFilter AddRequestParameter server: port: 9588 spring: application: name: cloud-gateway cloud: gateway: discovery: locator: enabled: true #开启从注册中心动态创建路由的功能 lower-case-service-id: true #使用小写服务名，默认是大写 routes: - id: payment_routh #payment_route #路由的ID，没有固定规则但要求唯一，建议配合服务名 uri: lb://cloud-provider-payment #匹配后的目标服务地址，供服务的路由地址 #uri: http://localhost:8001 #匹配后提供服务的路由地址 filters: - AddRequestParameter=X-Request-Id,1024 #过滤器工厂会在匹配的请求头加上一对请求头，名称为X-Request-Id值为1024 predicates: - Path=/paymentInfo/** # 断言，路径相匹配的进行路由 - Method=GET,POST eureka: instance: hostname: cloud-gateway-service client: #服务提供者provider注册进eureka服务列表内 service-url: register-with-eureka: true fetch-registry: true defaultZone: http://eureka7001.com:7001/eureka 自定义过滤器 自定义全局GlobalFilter 两个主要接口介绍：GlobalFilter,Ordered 能干嘛 全局日志记录 统一网关鉴权 案例代码 package com.clover.springcloud.filter; import lombok.extern.slf4j.Slf4j; import org.springframework.cloud.gateway.filter.GatewayFilterChain; import org.springframework.cloud.gateway.filter.GlobalFilter; import org.springframework.core.Ordered; import org.springframework.http.HttpStatus; import org.springframework.stereotype.Component; import org.springframework.web.server.ServerWebExchange; import reactor.core.publisher.Mono; import java.util.Date; @Component @Slf4j public class MyLogGateWayFilter implements GlobalFilter, Ordered { @Override public Mono\u003cVoid\u003e filter(ServerWebExchange exchange, GatewayFilterChain chain) { log.info(\"time:\"+new Date()+\"\\t 执行了自定义的全局过滤器: \"+\"MyLogGateWayFilter\"+\"hello\"); String uname = exchange.getRequest().getQueryParams().getFirst(\"uname\"); if(uname == null) { log.info(\"****用户名为null，无法登录\"); exchange.getResponse().setStatusCode(HttpStatus.NOT_ACCEPTABLE); return exchange.getResponse().setComplete(); } return chain.filter(exchange); } // 加载过滤器的顺序，一般数字越小，优先级越高 @Override public int getOrder() { return 0; } } 测试 正确：http://localhost:9527/payment/lb?uname=clover 错误 没有参数uname http://localhost:9527/payment/lb：无法正常使用转发 ","date":"2021-10-14","objectID":"/springcloud/:10:7","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"11、SpringCloud Config分布式配置中心 ","date":"2021-10-14","objectID":"/springcloud/:11:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"11.1、概述 分布式系统面临的—配置问题 微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务。由于每个服务都需要必要的配置信息才能运行，所以一套集中式的、动态的配置管理设施是必不可少的。 SpringCloud提供了ConfigServer来解决这个问题，我们每一个微服务自己带着一个application.yml，上百个配置文件的管理.. 是什么 SpringCloud Config为微服务架构中的微服务提供集中化的外部配置支持，配置服务器为各个不同微服务应用的所有环境提供了一个中心化的外部配置 SpringCloud Config分为服务端和客户端两部分 服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密/解密信息等访问接口 客户端则是通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容 能干嘛 集中管理配置文件 不同环境不同配置，动态化的配置更新，分环境部署比如dev/test/prod/beta/release 运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息 当配置发生变动时，服务不需要重启即可感知到配置的变化并应用新的配置 将配置信息以REST接口的形式暴露 与GitHub整合配置 由于SpringCloud Config默认使用Git来存储配置文件(也有其它方式,比如支持SVN和本地文件)，但最推荐的还是Git，而且使用的是http/https访问的形式 ","date":"2021-10-14","objectID":"/springcloud/:11:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"11.2、Config服务端配置与测试 1、用你自己的账号在GitHub上新建一个名为springcloud-config的新Repository 2、由上一步获得刚新建的git地址：https://github.com/cloverfelix/springcloud-config.git 3、新建Module模块 cloud-config-center-3344 它即为Cloud的配置中心模块cloudConfig Center 4、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-center-3344\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-config-server\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 5、编写YML server: port: 3344 spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://gitee.com/ren_zuo_wei/springcloud-config.git #Gitee上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: master #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka 6、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; @SpringBootApplication @EnableConfigServer public class ConfigCenterMain3344 { public static void main(String[] args) { SpringApplication.run(ConfigCenterMain3344.class,args); } } 7、测试通过Config微服务是否可以从GitHub上获取配置内容 http://localhost:3344/master/config-dev.yml 大坑！！！！！！ 现在在GitHub中创建一个新的仓库的时候，默认分支为main分支，需要你自己手动创建一个master分支，并且，访问uri使用HTTP，不使用SSL，使用SSL会报身份验证问题 参考博客 配置读取规则 官网 /{label}/{application}-{profile}.yml master分支 http://localhost:3344/master/config-dev.yml http://localhost:3344/master/config-test.yml http://localhost:3344/master/config-prod.yml dev分支 http://localhost:3344/dev/config-dev.yml /{application}-{profile}.yml http://localhost:3344/config-dev.yml /{application}/{profile}[/{label}] http://localhost:3344/config/dev/master 重要配置细节总结 /{name}-{profiles}.yml /{label}-{name}-{profiles}.yml label：分支(branch) name ：服务名 profiles：环境(dev/test/prod) ","date":"2021-10-14","objectID":"/springcloud/:11:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"11.3、Config客户端配置与测试 1、新建cloud-config-client-3355 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-client-3355\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、新建bootstrap.yml bootstrap.yml是什么？ applicaiton.yml是用户级的资源配置项 bootstrap.yml是系统级的，优先级更加高 SpringCloud会创建一个“Bootstrap Context”，作为Spring应用的Application Context的父上下文。初始化的时候，Bootstrap Context负责从外部源加载配置属性并解析配置。这两个上下文共享一个从外部获取的Environment Bootstrap属性有高优先级，默认情况下，它们不会被本地配置覆盖。 Bootstrap context和Application Context有着不同的约定，所以新增了一个bootstrap.yml文件，保证Bootstrap Context和Application Context配置的分离 要将Client模块下的application.yml文件改为bootstrap.yml,这是很关键的，因为bootstrap.yml是比application.yml先加载的。bootstrap.yml优先级高于application.yml server: port: 3355 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址k #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class ConfigClientMain3355 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3355.class,args); } } 5、编写业务类 package com.clover.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class ConfigClientController { @Value(\"${config.info}\") private String configInfo; @GetMapping(\"/configInfo\") public String getConfigInfo() { return configInfo; } } 6、测试 启动Config配置中心3344微服务并自测：http://localhost:3344/master/config-dev.yml 启动3355作为Client准备访问：http://localhost:3355/configInfo 成功实现了客户端3355访问SpringCloud Config3344通过GitHub获取配置信息 问题随时而来，分布式配置的动态刷新问题 Linux运维修改GitHub上的配置文件内容做调整 刷新3344，发现ConfigServer配置中心立刻响应 刷新3355，发现ConfigClient客户端没有任何响应 3355没有变化除非自己重启或者重新加载 难到每次运维修改配置文件，客户端都需要重启？？噩梦 ","date":"2021-10-14","objectID":"/springcloud/:11:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"11.4、Config客户端之动态刷新 1、动态刷新 修改3355模块 POM引入actuator监控 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e 修改YML，暴露监控端口 # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" 业务类Controller上加 @RefreshScope注解 此时修改GitHub–\u003e访问3344–\u003e访问3355 但是，此时3355并没有改变 这就需要运维人员在每次修改完毕后发送POST请求刷新3355 必须是POST请求 curl -X POST “http://localhost:3355/actuator/refresh” 再次访问，成功实现了客户端3355刷新到最新配置内容，避免了服务重启 ２、想想还有什么问题？ 假如有多个微服务客户端3355/3366/3377。。。。。。 每个微服务都要执行一次post请求，手动刷新？ 可否广播，一次通知，处处生效？ 我们想大范围的自动刷新，求方法 ","date":"2021-10-14","objectID":"/springcloud/:11:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"12、SpringCloud Bus消息总线 ","date":"2021-10-14","objectID":"/springcloud/:12:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"12.1、概述 对Config的加深和扩充 SpringCloud Bus 配合 SpringCloud Config 使用可以实现配置的动态刷新 Bus是什么？ Bus支持两种消息代理：RabbitMQ 和 Kafka Spring Cloud Bus是用来将分布式系统的节点与轻量级消息系统链接起来的框架，它整合了Java的事件处理机制和消息中间件的功能。 Bus能干嘛？ SpringCloud Bus能管理和传播分布式系统间的消息，就像一个分布式执行器，可用于广播状态更改、事件推送等，也可以当作微服务间的通信通道。 为何被称为总线 什么是总线 在微服务架构的系统中，通常会使用轻量级的消息代理来构建一个共用的消息主题，并让系统中所有微服务实例都连接上来。由于该主题中产生的消息会被所有实例监听和消费，所以称它为消息总线。在总线上的各个实例，都可以方便地广播一些需要让其他连接在该主题上的实例都知道的消息。 基本原理 ConfigClient实例都监听MQ中同一个topic(默认是springCloudBus)。当一个服务刷新数据的时候，它会把这个信息放入到Topic中，这样其它监听同一Topic的服务就能得到通知，然后去更新自身的配置。 ","date":"2021-10-14","objectID":"/springcloud/:12:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"12.2、SpringCloud Bus动态刷新全局广播 1、必须先具备良好的Rabbit MQ环境先 2、新建 cloud-config-client-3366 3、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-config-client-3366\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 4、编写YML server: port: 3366 spring: application: name: config-client cloud: #Config客户端配置 config: label: master #分支名称 name: config #配置文件名称 profile: dev #读取后缀名称 上述3个综合：master分支上config-dev.yml的配置文件被读取http://config-3344.com:3344/master/config-dev.yml uri: http://localhost:3344 #配置中心地址 #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka # 暴露监控端点 management: endpoints: web: exposure: include: \"*\" 5、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.netflix.eureka.EnableEurekaClient; @SpringBootApplication @EnableEurekaClient public class ConfigClientMain3366 { public static void main(String[] args) { SpringApplication.run(ConfigClientMain3366.class,args); } } 6、编写 controller package com.clover.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RefreshScope public class ConfigClientController { @Value(\"${server.port}\") private String serverPort; @Value(\"${config.info}\") private String configInfo; @GetMapping(\"/configInfo\") public String getConfigInfo() { return \"serverPort: \" + serverPort + \"\\t\\n\\n configInfo：\" + configInfo; } } 7、设计思想 利用消息总线触发一个客户端/bus/refresh,而刷新所有客户端的配置 利用消息总线触发一个服务端ConfigServer的/bus/refresh端点，而刷新所有客户端的配置 图二的架构显然更加适合，图一不适合的原因如下 打破了微服务的职责单一性，因为微服务本身是业务模块，它本不应该承担配置刷新的职责。 破坏了微服务各节点的对等性。 有一定的局限性。例如，微服务在迁移时，它的网络地址常常会发生变化，此时如果想要做到自动刷新，那就会增加更多的修改 8、给cloud-config-center-3344配置中心服务端添加消息总线支持 \u003c!--添加消息总线RabbitMQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-bus-amqp\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e server: port: 3344 spring: application: name: cloud-config-center #注册进Eureka服务器的微服务名 cloud: config: server: git: uri: https://gitee.com/ren_zuo_wei/springcloud-config.git #Gitee上面的git仓库名字 ####搜索目录 search-paths: - springcloud-config ####读取分支 label: master #rabbitmq相关配置 rabbitmq: host: localhost port: 5672 username: guest password: guest #服务注册到eureka地址 eureka: client: service-url: defaultZone: http://localhost:7001/eureka ##rabbitmq相关配置,暴露bus刷新配置的端点 management: endpoints: #暴露bus刷新配置的端点 web: exposure: include: 'bus-refresh' 9、给cloud-config-client-3355客户端添加消息总线支持 \u003c!--添加消息总线RabbitMQ支持--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springfram","date":"2021-10-14","objectID":"/springcloud/:12:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"12.3、SpringCloud Bus动态刷新定点通知 不想全部通知，只想定点通知 只通知3355 不通知3366 简单一句话 指定具体某一个实例生效而不是全部 公式：http://localhost:配置中心的端口号/actuator/bus-refresh/{destination} /bus/refresh请求不再发送到具体的服务实例上，而是发给config server并通过destination参数类指定需要更新配置的服务或实例 案例 我们这里以刷新运行在3355端口上的config-client为例 只通知3355 不通知3366 curl -X POST “http://localhost:3344/actuator/bus-refresh/config-client:3355” destination—\u003e在eureka上的微服务名:端口号 通知总结All ","date":"2021-10-14","objectID":"/springcloud/:12:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13、SpringCloud Stream ","date":"2021-10-14","objectID":"/springcloud/:13:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13.1、消息驱动概述 13.1.1、Stream是什么？ 一句话：屏蔽底层消息中间件的差异,降低切换成本，统一消息的编程模型 13.1.2、什么是SpringCloudStream 官方定义 SpringCloud Stream 是一个构建消息驱动微服务的框架。 应用程序通过 inputs 或者 outputs 来与 SpringCloud Stream中binder对象交互。 通过我们配置来binding(绑定) ，而 Spring Cloud Stream 的 binder对象负责与消息中间件交互。 所以，我们只需要搞清楚如何与 Spring Cloud Stream 交互就可以方便使用消息驱动的方式。 通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。 Spring Cloud Stream 为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引用了发布-订阅、消费组、分区的三个核心概念。 目前仅支持RabbitMQ、Kafka SpringCloud Stream概述 SpringCloud Stream大纲 SpringCloud Stream中文指导手册 13.1.3、设计思想 13.1.3.1、标准MQ 生产者/消费者之间靠消息媒介传递信息内容 Message 消息必须走特定的通道 消息通道MessageChannel 消息通道里的消息如何被消费呢，谁负责收发处理 消息通道MessageChannel的子接口SubscribableChannel，由MessageHandler消息处理器所订阅 13.1.3.2、为什么用Cloud Stream 比方说我们用到了RabbitMQ和Kafka，由于这两个消息中间件的架构上的不同，像RabbitMQ有exchange，kafka有Topic和Partitions分区 这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰，我们如果用了两个消息队列的其中一种，后面的业务需求，我想往另外一种消息队列进行迁移，这时候无疑就是一个灾难性的，一大堆东西都要重新推倒重新做，因为它跟我们的系统耦合了，这时候springcloud Stream给我们提供了一种解耦合的方式 13.1.3.3、stream凭什么可以统一底层差异 在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候 由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性 通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离 通过向应用程序暴露统一的Channel通道，使得应用程序不需要再考虑各种不同的消息中间件实现 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离 13.1.3.4、Binder 在没有绑定器这个概念的情况下，我们的SpringBoot应用要直接与消息中间件进行信息交互的时候，由于各消息中间件构建的初衷不同，它们的实现细节上会有较大的差异性，通过定义绑定器作为中间层，完美地实现了应用程序与消息中间件细节之间的隔离。Stream对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至于动态的切换中间件(rabbitmq切换为kafka)，使得微服务开发的高度解耦，服务可以关注更多自己的业务流程 通过定义绑定器Binder作为中间层，实现了应用程序与消息中间件细节之间的隔离 Binder可以生成Binding，Binding用来绑定消息容器的生产者和消费者，它有两种类型，INPUT和OUTPUT，INPUT对应于消费者，OUTPUT对应于生产者 13.1.3.5、Stream中的消息通信方式遵循了发布-订阅模式 Topic主题进行广播 在RabbitMQ就是Exchange 在Kakfa中就是Topic 13.1.4、Spring Cloud Stream标准流程套路 Binder 很方便的连接中间件，屏蔽差异 Channel 通道，是队列Queue的一种抽象，在消息通讯系统中就是实现存储和转发的媒介，通过Channel对队列进行配置 Source和Sink 简单的可理解为参照对象是Spring Cloud Stream自身，从Stream发布消息就是输出，接受消息就是输入 13.1.5、编码API和常用注解 ","date":"2021-10-14","objectID":"/springcloud/:13:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13.2、案例说明 RabbitMQ环境已经OK 工程中新建三个子模块 cloud-stream-rabbitmq-provider8801， 作为生产者进行发消息模块 cloud-stream-rabbitmq-consumer8802，作为消息接收模块 cloud-stream-rabbitmq-consumer8803，作为消息接收模块 ","date":"2021-10-14","objectID":"/springcloud/:13:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13.3、消息驱动之生产者 1、新建 cloud-stream-rabbitmq-provider8801 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-stream-rabbitmq-provider8801\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 8801 spring: application: name: cloud-stream-provider cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 output: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为json，文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: send-8801.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class StreamMQMain8801 { public static void main(String[] args) { SpringApplication.run(StreamMQMain8801.class,args); } } 5、编写业务类 发送消息接口 package com.clover.springcloud.service; public interface MyMessageProvider { public String send(); } 发送消息接口实现类 package com.clover.springcloud.service.Impl; import com.clover.springcloud.service.MyMessageProvider; import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.messaging.Source; import org.springframework.integration.support.MessageBuilder; import org.springframework.messaging.MessageChannel; import javax.annotation.Resource; import java.util.UUID; @EnableBinding(Source.class) // 可以理解为是一个消息的发送管道的定义 public class MyMessageProviderImpl implements MyMessageProvider { @Resource private MessageChannel output;// 消息的发送管道 @Override public String send() { String serial = UUID.randomUUID().toString(); this.output.send(MessageBuilder.withPayload(serial).build()); System.out.println(\"*********sreial：\" + serial); return serial; } } Controller package com.clover.springcloud.controller; import com.clover.springcloud.service.MyMessageProvider; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; import javax.annotation.Resource; @RestController public class SendMessageController { @Resource private MyMessageProvider myMessageProvider; @GetMapping(value = \"/sendMessage\") public String send() { return myMessageProvider.send(); } } 6、测试 启动7001eureka 启动rabbitmq 启动8801 访问：http://localhost:8801/sendMessage ","date":"2021-10-14","objectID":"/springcloud/:13:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13.4、消息驱动之消费者 1、新建 cloud-stream-rabbitmq-provider8802 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-stream-rabbitmq-consumer8802\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 8802 spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class StreamMQMain8802 { public static void main(String[] args) { SpringApplication.run(StreamMQMain8802.class,args); } } 5、编写业务类 package com.clover.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.annotation.StreamListener; import org.springframework.cloud.stream.messaging.Sink; import org.springframework.messaging.Message; import org.springframework.stereotype.Component; @Component @EnableBinding(Sink.class) public class ReceiveMessageListener { @Value(\"${server.port}\") private String serverPort; // 监听队列，用于消费者的队列的消息接收 @StreamListener(Sink.INPUT) public void input(Message\u003cString\u003e message) { System.out.println(\"消费者1号，------------\u003e接收到的消息：\" + message.getPayload() + \"\\t port:\" + serverPort); } } ","date":"2021-10-14","objectID":"/springcloud/:13:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"13.5、分组消费与持久化 13.5.1、消费 1、新建 cloud-stream-rabbitmq-provider8803 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-stream-rabbitmq-consumer8803\u003c/artifactId\u003e \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-netflix-eureka-client\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-stream-rabbit\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 8803 spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称 destination: studyExchange # 表示要使用的Exchange名称定义 content-type: application/json # 设置消息类型，本次为对象json，如果是文本则设置“text/plain” binder: defaultRabbit # 设置要绑定的消息服务的具体设置 eureka: client: # 客户端进行Eureka注册的配置 service-url: defaultZone: http://localhost:7001/eureka instance: lease-renewal-interval-in-seconds: 2 # 设置心跳的时间间隔（默认是30秒） lease-expiration-duration-in-seconds: 5 # 如果现在超过了5秒的间隔（默认是90秒） instance-id: receive-8802.com # 在信息列表时显示主机名称 prefer-ip-address: true # 访问的路径变为IP地址 4、编写主启动类 package com.clover.springcloud; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; @SpringBootApplication public class StreamMQMain8803 { public static void main(String[] args) { SpringApplication.run(StreamMQMain8803.class,args); } } 5、编写业务类 package com.clover.springcloud.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.stream.annotation.EnableBinding; import org.springframework.cloud.stream.annotation.StreamListener; import org.springframework.cloud.stream.messaging.Sink; import org.springframework.messaging.Message; import org.springframework.stereotype.Component; @Component @EnableBinding(Sink.class) public class ReceiveMessageListener { @Value(\"${server.port}\") private String serverPort; // 监听队列，用于消费者的队列的消息接收 @StreamListener(Sink.INPUT) public void input(Message\u003cString\u003e message) { System.out.println(\"消费者2号，------------\u003e接收到的消息：\" + message.getPayload() + \"\\t port:\" + serverPort); } } 6、运行后有两个问题 有重复消费问题 消息持久化问题 7、消费 目前是8802/8803同时都收到了，存在重复消费问题 如何解决？ 分组和持久化属性group 生产实际案例 比如在如下场景中，订单系统我们做集群部署，都会从RabbitMQ中获取订单信息，那如果一个订单同时被两个服务获取到，那么就会造成数据错误，我们得避免这种情况。这时我们就可以使用Stream中的消息分组来解决 注意在Stream中处于同一个group中的多个消费者是竞争关系，就能够保证消息只会被其中一个应用消费一次 不同组是可以全面消费的(重复消费) 同一组内会发生竞争关系，只有其中一个可以消费 13.5.2、分组 原理 微服务应用放置于同一个group中，就能够保证消息只会被其中一个应用消费一次 不同的组是可以消费的，同一个组内会发生竞争关系，只有其中一个可以消费 8802/8803都变成不同组，group两个不同 group: cloverA、cloverB 8802修改YML server: port: 8802 spring: application: name: cloud-stream-consumer cloud: stream: binders: # 在此处配置要绑定的rabbitmq的服务信息； defaultRabbit: # 表示定义的名称，用于于binding整合 type: rabbit # 消息组件类型 environment: # 设置rabbitmq的相关的环境配置 spring: rabbitmq: host: localhost port: 5672 username: guest password: guest bindings: # 服务的整合处理 input: # 这个名字是一个通道的名称，在分析具体源代码的时候会进行说明 destination: studyExcha","date":"2021-10-14","objectID":"/springcloud/:13:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"14、SpringCloud Sleuth分布式请求链路跟踪 ","date":"2021-10-14","objectID":"/springcloud/:14:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"14.1、概述 14.1.1、为什么会出现这个技术？需要解决哪些问题？ 在微服务框架中，一个由客户端发起的请求在后端系统中会经过多个不同的的服务节点调用来协同产生最后的请求结果，每一个前端请求都会形成一条复杂的分布式服务调用链路，链路中的任何一环出现高延时或错误都会引起整个请求最后的失败 14.1.2、是什么？ 官网说明 SpringCloud Sleuth提供了一套完整的服务跟踪的解决方案 在分布式系统中提供追踪解决方案并且兼容支持了zipkin ","date":"2021-10-14","objectID":"/springcloud/:14:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"14.2、搭建链路监控步骤 zipkin 下载：下载地址 SpringCloud从F版起已不需要自己构建Zipkin Server了，只需调用jar包即可 运行jar：java -jar zipkin-server-2.12.9-exec.jar 运行控制台 http://localhost:9411/zipkin/ 术语 完整的调用链路 上图精简 名词解释 Trace:类似于树结构的Span集合，表示一条调用链路，存在唯一标识 span:表示调用链路来源，通俗的理解span就是一次请求信息 服务提供者：cloud-provider-payment8001 \u003c!--包含了sleuth+zipkin--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e spring: application: name: cloud-payment-service zipkin: base-url: http://localhost:9411 sleuth: sampler: #采样率值介于 0 到 1 之间，1 则表示全部采集 probability: 1 服务消费者(调用方)：cloud-consumer-order80 \u003c!--包含了sleuth+zipkin--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-zipkin\u003c/artifactId\u003e \u003c/dependency\u003e spring: application: name: cloud-order-service zipkin: base-url: http://localhost:9411 sleuth: sampler: probability: 1 依次启动eureka7001/8001/80 80调用8001几次测试下 打开浏览器访问：http://localhost:9411 会出现以下界面 查看依赖关系 ","date":"2021-10-14","objectID":"/springcloud/:14:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"15、SpringCloud Alibaba入门简介 ","date":"2021-10-14","objectID":"/springcloud/:15:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"15.1、SpringCloud alibaba带来了什么 15.1.2、是什么？ 官网 诞生： 2018.10.31，SpringCloud Alibaba 正式入驻了 Spring Cloud 官方孵化器，并在 Maven 中央库发布了第一个版本。 15.1.3、能干嘛？ 服务限流降级：默认支持 Servlet、Feign、RestTemplate、Dubbo 和 RocketMQ 限流降级功能的接入，可以在运行时通过控制台实时修改限流降级规则，还支持查看限流降级 Metrics 监控 服务注册与发现：适配 SpringCloud 服务注册与发现标准，默认集成了 Ribbon 的支持 分布式配置管理：支持分布式系统中的外部化配置，配置更改时自动刷新 消息驱动能力：基于 SpringCloud Stream 为微服务应用构建消息驱动能力 阿里云对象存储：阿里云提供的海量、安全、低成本、高可靠的云存储服务。支持在任何应用、任何时间、任何地点存储和访问任意类型的数据 分布式任务调度：提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。同时提供分布式的任务执行模型，如网格任务。网格任务支持海量子任务均匀分配到所有 Worker（schedulerx-client）上执行 15.1.4、怎么玩？ ","date":"2021-10-14","objectID":"/springcloud/:15:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"15.2、SpringCloud alibaba学习资料获取 SpringCloud Alibaba官网 Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案。此项目包含开发分布式应用微服务的必需组件，方便开发者通过 SpringCloud 编程模型轻松使用这些组件来开发分布式应用服务。 依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统 SpringCloud Alibaba参考文档 ","date":"2021-10-14","objectID":"/springcloud/:15:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16、SpringCloud Alibaba Nacos服务注册和配置中心 ","date":"2021-10-14","objectID":"/springcloud/:16:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16.1、Nacos简介 16.1.1、为什么叫Nacos 前四个字母分别为Naming和Configuration的前两个字母，最后的s为Service。 16.1.2、Nacos是什么？ 一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台 Nacos: Dynamic Naming and Configuration Service Nacos就是注册中心 + 配置中心的组合 \u003c===\u003e Nacos = Eureka+Config +Bus 16.1.3、Nacos能干嘛？ 替代Eureka做服务注册中心 替代Config做服务配置中心 16.1.4、去哪下？ Nacos Github地址 官网文档 16.1.5、各种注册中心比较 ","date":"2021-10-14","objectID":"/springcloud/:16:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16.2、安装并运行Nacos 本地Java8+Maven环境已经OK 先从官网下载Nacos 解压安装包，直接运行bin目录下的startup.cmd 命令运行成功后直接访问：http://localhost:8848/nacos，默认账号密码都是nacos 结果页面 大坑！！！！ 注意：运行Nacos必备Java环境，如果运行报错：Please set the JAVA_HOME variable in your environment, We need java(x64)! jdk8，那么你需要在你本机的环境变量中去新建一个JAVA_HOME变量环境 ","date":"2021-10-14","objectID":"/springcloud/:16:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16.3、Nacos作为服务注册中心演示 16.3.1、官网文档 官网文档 16.3.2、基于Nacos的服务提供者 1、新建 cloud-alibaba-provider-payment9001 2、修改POM 父POM \u003c!--spring cloud alibaba 2.1.0.RELEASE--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-alibaba-dependencies\u003c/artifactId\u003e \u003cversion\u003e2.1.0.RELEASE\u003c/version\u003e \u003ctype\u003epom\u003c/type\u003e \u003cscope\u003eimport\u003c/scope\u003e \u003c/dependency\u003e 本模块POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-provider-payment9001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML server: port: 9001 spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 management: endpoints: web: exposure: include: '*' 4、编写主启动类 package com.clover.springcloud.alibaba; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class PaymentMain9001 { public static void main(String[] args) { SpringApplication.run(PaymentMain9001.class,args); } } 5、编写业务类 package com.clover.springcloud.alibaba.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class PaymentController { @Value(\"${server.port}\") private String serverPort; @GetMapping(value = \"/payment/nacos/{id}\") public String getPayment(@PathVariable(\"id\") Integer id) { return \"nacos registry, serverPort: \"+ serverPort+\"\\t id\"+id; } } 6、测试 http://localhost:9001/payment/nacos/1 nacos控制台 7、为下面演示nacos的负载均衡，参照9001建立9002 16.3.3、基于Nacos的服务消费者 1、新建 cloud-alibaba-consumer-nacos-order83 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-consumer-nacos-order83\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-star","date":"2021-10-14","objectID":"/springcloud/:16:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16.4、Nacos作为服务配置中心演示 16.4.1、Nacos作为配置中心-基础配置 1、新建 cloud-alibaba-config-nacos-client3377 2、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-config-nacos-client3377\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--nacos-config--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-config\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--nacos-discovery--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--web + actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--一般基础配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 3、编写YML 为什么要配置两个yml？ Nacos同springcloud-config一样，在项目初始化时，要保证先从配置中心进行配置拉取，拉取配置之后，才能保证项目的正常启动 springboot中配置文件的加载是存在优先级顺序的，bootstrap优先级高于application # nacos配置 server: port: 3377 spring: application: name: nacos-config-client cloud: nacos: discovery: server-addr: localhost:8848 #Nacos服务注册中心地址 config: server-addr: localhost:8848 #Nacos作为配置中心地址 file-extension: yaml #指定yaml格式的配置 # ${spring.application.name}-${spring.profile.active}.${spring.cloud.nacos.config.file-extension} spring: profiles: active: dev # 表示开发环境 4、编写主启动类 package com.clover.spingcloud.alibaba; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class NacosConfigClientMain3377 { public static void main(String[] args) { SpringApplication.run(NacosConfigClientMain3377.class,args); } } 5、编写业务类 package com.clover.spingcloud.alibaba.controller; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.context.config.annotation.RefreshScope; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RefreshScope //在控制器类加入@RefreshScope注解使当前类下的配置支持Nacos的动态刷新功能 public class ConfigClientController { @Value(\"${config.info}\") private String configInfo; @GetMapping(\"/config/info\") public String getConfigInfo() { return configInfo; } } 6、在Nacos中添加配置信息 Nacos中的匹配规则 理论 Nacos中的dataId的组成格式及与SpringBoot配置文件中的匹配规则 官网说明 最后公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension} 实操 新增配置 Nacos界面配置对应 设置DataId 公式：${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension} prefix:默认为 spring.application.name 的值 spring.profile.active： 即为当前环境对应的 profile，可以通过配置项 spring.profile.active 来配置。 file-exetension ：为配置内容的数据格式，可以通过配置项spring.cloud.nacos.config.file-extension 来配置 小总结说明 7、测试 启动前需要在nacos客户端-配置管理-配置管理栏目下有对应的yaml配置文件 运行cloud-config-nacos-client3377的主启动类 调用接口查看配置信息：http://localhost:3377/config/info 8、自带动态刷新 修改下Nacos中的yaml配置文件，再次调用查看配置的接口，就会发现配置已经刷新 16.4.2、Nacos作为配置中心-分类配置 16.4.2.1、问题 多环境多项目管理 问题1： 实际开发中，通常一个系统会准备，dev开发环境、test测试环境、prod生产环境。 如何保证指定环境启动时服务能正确读取到Nacos上相应环境的配置文件呢？ 问题2： 一个大型分布式微服务系统会有很多微服务子项目，每个微服务项目又都会有相应的开发环境、测试环境、预发环境、正式环境…… 那怎么对这些微服务配置进行管理呢？ 16.4.2.2、Nacos的图形化管理界面 配置管理 命名空间 16.4.2.3、Namespace+Group+Data ID三者关系？为什么这么设计？ 是什么 类似Java里面的package名和类名 最外层的namespace是可以用于区分部署环境的，Gro","date":"2021-10-14","objectID":"/springcloud/:16:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"16.5、Nacos集群和持久化配置（重要） 16.5.1、官网说明 Nacos集群化部署说明 官网架构图 老版架构图 现在版(2021.10) 对上图官网翻译，真实情况 说明： 默认Nacos使用嵌入式数据库实现数据的存储。所以，如果启动多个默认配置下的Nacos节点，数据存储是存在一致性问题的 为了解决这个问题，Nacos采用了集中式存储的方式来支持集群化部署，目前只支持MySQL的存储 重点说明： 16.5.2、Nacos持久化配置解释 Nacos默认自带的是嵌入式数据库derby 去Github源码的pom文件中查看 derby到mysql切换配置步骤 nacos-server-1.1.4\\nacos\\conf目录下找到sql脚本 nacos-mysql.sql CREATE DATABASE nacos_config; USE nacos_config; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info */ /******************************************/ CREATE TABLE `config_info` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` VARCHAR(255) NOT NULL COMMENT 'data_id', `group_id` VARCHAR(255) DEFAULT NULL, `content` LONGTEXT NOT NULL COMMENT 'content', `md5` VARCHAR(32) DEFAULT NULL COMMENT 'md5', `gmt_create` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', `src_user` TEXT COMMENT 'source user', `src_ip` VARCHAR(20) DEFAULT NULL COMMENT 'source ip', `app_name` VARCHAR(128) DEFAULT NULL, `tenant_id` VARCHAR(128) DEFAULT '' COMMENT '租户字段', `c_desc` VARCHAR(256) DEFAULT NULL, `c_use` VARCHAR(64) DEFAULT NULL, `effect` VARCHAR(64) DEFAULT NULL, `type` VARCHAR(64) DEFAULT NULL, `c_schema` TEXT, PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_aggr */ /******************************************/ CREATE TABLE `config_info_aggr` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` VARCHAR(255) NOT NULL COMMENT 'data_id', `group_id` VARCHAR(255) NOT NULL COMMENT 'group_id', `datum_id` VARCHAR(255) NOT NULL COMMENT 'datum_id', `content` LONGTEXT NOT NULL COMMENT '内容', `gmt_modified` DATETIME NOT NULL COMMENT '修改时间', `app_name` VARCHAR(128) DEFAULT NULL, `tenant_id` VARCHAR(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='增加租户字段'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_beta */ /******************************************/ CREATE TABLE `config_info_beta` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` VARCHAR(255) NOT NULL COMMENT 'data_id', `group_id` VARCHAR(128) NOT NULL COMMENT 'group_id', `app_name` VARCHAR(128) DEFAULT NULL COMMENT 'app_name', `content` LONGTEXT NOT NULL COMMENT 'content', `beta_ips` VARCHAR(1024) DEFAULT NULL COMMENT 'betaIps', `md5` VARCHAR(32) DEFAULT NULL COMMENT 'md5', `gmt_create` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改时间', `src_user` TEXT COMMENT 'source user', `src_ip` VARCHAR(20) DEFAULT NULL COMMENT 'source ip', `tenant_id` VARCHAR(128) DEFAULT '' COMMENT '租户字段', PRIMARY KEY (`id`), UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='config_info_beta'; /******************************************/ /* 数据库全名 = nacos_config */ /* 表名称 = config_info_tag */ /******************************************/ CREATE TABLE `config_info_tag` ( `id` BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT 'id', `data_id` VARCHAR(255) NOT NULL COMMENT 'data_id', `group_id` VARCHAR(128) NOT NULL COMMENT 'group_id', `tenant_id` VARCHAR(128) DEFAULT '' COMMENT 'tenant_id', `tag_id` VARCHAR(128) NOT NULL COMMENT 'tag_id', `app_name` VARCHAR(128) DEFAULT NULL COMMENT 'app_name', `content` LONGTEXT NOT NULL COMMENT 'content', `md5` VARCHAR(32) DEFAULT NULL COMMENT 'md5', `gmt_create` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '创建时间', `gmt_modified` DATETIME NOT NULL DEFAULT '2010-05-05 00:00:00' COMMENT '修改","date":"2021-10-14","objectID":"/springcloud/:16:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17、SpringCloud Alibaba Sentinel实现熔断与限流 ","date":"2021-10-14","objectID":"/springcloud/:17:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.1、Sentinel 官网 Sentinel是什么？ 一句话解释，之前我们讲解过的Hystrix 去哪下？下载地址 能干嘛？ 怎么玩？官方指导文档 服务使用中的各种问题 服务雪崩 服务降级 服务熔断 服务限流 ","date":"2021-10-14","objectID":"/springcloud/:17:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.2、安装Sentinel控制台 sentinel组件由2部分构成： 安装步骤: 运行命令：java -jar sentinel-dashboard-1.7.0.jar 前提 Java8环境可以用 8080端口不能被占用 访问sentinel管理界面 http://localhost:8080 登录账号密码均为sentinel ","date":"2021-10-14","objectID":"/springcloud/:17:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.3、初始化演示工程 1、启动Nacos8848成功 2、新建 cloud-alibaba-sentinel-service8401 3、修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-sentinel-service8401\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba sentinel-datasource-nacos 后续做持久化用到--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-datasource-nacos\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--SpringCloud ailibaba sentinel --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-sentinel\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--openfeign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件+actuator --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003ecn.hutool\u003c/groupId\u003e \u003cartifactId\u003ehutool-all\u003c/artifactId\u003e \u003cversion\u003e4.6.3\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 4、编写YML server: port: 8401 spring: application: name: cloud-alibaba-sentinel-service cloud: nacos: discovery: #Nacos服务注册中心地址 server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719 management: endpoints: web: exposure: include: '*' 5、编写主启动类 package com.clover.springcloud.alibaba; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class MainApp8401 { public static void main(String[] args) { SpringApplication.run(MainApp8401.class,args); } } 6、编写业务类 package com.clover.springcloud.alibaba.controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class FlowLimitController { @GetMapping(\"/testA\") public String testA() { return \"------testA\"; } @GetMapping(\"/testB\") public String testB() { return \"------testB\"; } } 7、启动Sentinel8080：java -jar sentinel-dashboard-1.7.0.jar 8、启动微服务8401 9、启动8401微服务后查看sentinel控制台 空空如也 Sentinel采用懒加载说明 执行一次访问即可 http://localhost:8401/testA http://localhost:8401/testB 效果 结论：sentinel8080正在监控微服务8401 ","date":"2021-10-14","objectID":"/springcloud/:17:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.4、流控规则 17.4.1、基本介绍 进一步解释： 17.4.2、流控模式 17.4.2.1、直接(默认) 直接-\u003e快速失败(系统默认) 配置及说明 表示1秒钟内查询1次就是OK，若超过次数1，就直接-快速失败，报默认错误 测试 快速点击访问http://localhost:8401/testA 结果：Blocked by Sentinel (flow limiting) 思考 直接调用默认报错信息，技术方面OK，但是是否应该有我们自己的后续处理? 类似有个fallback的兜底方法？ 17.4.2.2、关联 关联是什么？ 当关联的资源达到阈值时，就限流自己 当与A关联的资源B达到阀值后，就限流A自己 B惹事，A挂了 配置A 设置效果：当关联资源/testB的QPS阀值超过1时，就限流/testA的Rest访问地址，当关联资源到阈值后限制配置好的资源名 postman模拟并发密集访问testB 运行后发现testA挂了 点击访问：http://localhost:8401/testA 结果：Blocked by Sentinel (flow limiting) 17.4.2.3、链路 17.4.3、流控效果 17.4.3.1、直接-\u003e快速失败(默认的流控处理) 直接失败，抛出异常 Blocked by Sentinel (flow limiting) 源码 com.alibaba.csp.sentinel.slots.block.flow.controller.DefaultController 17.4.3.2、预热 说明：公式：阈值除以coldFactor(默认值为3),经过预热时长后才会达到阈值 官网 默认coldFactor为3，即请求 QPS 从 threshold / 3 开始，经预热时长逐渐升至设定的 QPS 阈值。 限流 冷启动官网说明 源码 com.alibaba.csp.sentinel.slots.block.flow.controller.WarmUpController WarmUp配置 默认 coldFactor 为 3，即请求QPS从(threshold / 3) 开始，经多少预热时长才逐渐升至设定的 QPS 阈值 案例，阀值为10+预热时长设置5秒 系统初始化的阀值为10 / 3 约等于3,即阀值刚开始为3；然后过了5秒后阀值才慢慢升高恢复到10 多次点击：http://localhost:8401/testB；刚开始不行，后续慢慢OK 应用场景 如：秒杀系统在开启的瞬间，会有很多流量上来，很有可能把系统打死，预热方式就是把为了保护系统，可慢慢的把流量放进来，慢慢的把阀值增长到设置的阀值 17.4.3.3、排队等待 匀速排队，让请求以均匀的速度通过，阀值类型必须设成QPS，否则无效 设置含义：/testA每秒1次请求，超过的话就排队等待，等待的超时时间为20000毫秒 官网：流量控制指导文档 源码：com.alibaba.csp.sentinel.slots.block.flow.controller.RateLimiterController ","date":"2021-10-14","objectID":"/springcloud/:17:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.5、降级规则 官网 17.5.1、基本介绍 RT（平均响应时间，秒级） 平均响应时间 超出阈值 且 在时间窗口内通过的请求\u003e=5，两个条件同时满足后触发降级 窗口期过后关闭断路器 RT最大4900（更大的需要通过-Dcsp.sentinel.statistic.max.rt=XXXX才能生效） 异常比列（秒级） QPS \u003e= 5 且异常比例（秒级统计）超过阈值时，触发降级；时间窗口结束后，关闭降级 异常数（分钟级） 异常数（分钟统计）超过阈值时，触发降级；时间窗口结束后，关闭降级 进一步说明 Sentinel 熔断降级会在调用链路中某个资源出现不稳定状态时（例如调用超时或异常比例升高），对这个资源的调用进行限制，让请求快速失败，避免影响到其它的资源而导致级联错误 当资源被降级后，在接下来的降级时间窗口之内，对该资源的调用都自动熔断（默认行为是抛出 DegradeException） Sentinel的断路器是没有半开状态的 半开的状态系统自动去检测是否请求有异常，没有异常就关闭断路器恢复使用，有异常则继续打开断路器不可用。具体可以参考Hystrix 17.5.2、降级策略实战 17.5.2.1、RT是什么？ 17.5.2.2、测试 代码 @GetMapping(\"/testD\") public String testD() { //暂停几秒钟线程 try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"testD 测试RT\"); return \"------testD\"; } 配置 jmeter压测 结论 按照上述配置 永远一秒钟打进来10个线程（大于5个了）调用testD，我们希望200毫秒处理完本次任务，如果超过200毫秒还没处理完，在未来1秒钟的时间窗口内，断路器打开(保险丝跳闸)微服务不可用，保险丝跳闸断电了 后续我停止jmeter，没有这么大的访问量了，断路器关闭(保险丝恢复)，微服务恢复OK 17.5.2.3、异常比例是什么？ 17.5.2.4、测试 代码 @GetMapping(\"/testD\") public String testD() { log.info(\"testD 测试RT\"); int age = 10/0; return \"------testD\"; } 配置 jmeter压测 结论 按照上述配置，单独访问一次，必然来一次报错一次(int age = 10/0)，调一次错一次 开启jmeter后，直接高并发发送请求，多次调用达到我们的配置条件了 断路器开启(保险丝跳闸)，微服务不可用了，不再报错error而是服务降级了 17.5.2.5、异常数是什么？ 异常数是按照分钟统计的 17.5.2.6、测试 代码 @GetMapping(\"/testE\") public String testE() { log.info(\"testE 测试异常数\"); int age = 10/0; return \"------testE 测试异常数\"; 配置 http://localhost:8401/testE，第一次访问绝对报错，因为除数不能为零，我们看到error窗口，但是达到5次报错后，进入熔断后降级 ","date":"2021-10-14","objectID":"/springcloud/:17:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.6、热点key限流 17.6.1、基本介绍 何为热点 热点即经常访问的数据，很多时候我们希望统计或者限制某个热点数据中访问频次最高的TopN数据，并对其访问进行限流或者其它操作 # 热点参数限流指导文档 17.6.2、承上启下复习 兜底方法，分为系统默认和客户自定义，两种 之前的case，限流出问题后，都是用sentinel系统默认的提示：Blocked by Sentinel (flow limiting) 我们能不能自定?类似hystrix，某个方法出问题了，就找对应的兜底降级方法？ 结论：从HystrixCommand 到@SentinelResource 代码：com.alibaba.csp.sentinel.slots.block.BlockException @GetMapping(\"/testHotKey\") @SentinelResource(value = \"testHotKey\",blockHandler = \"dealHandler_testHotKey\") public String testHotKey(@RequestParam(value = \"p1\",required = false) String p1, @RequestParam(value = \"p2\",required = false) String p2){ return \"------testHotKey\"; } public String dealHandler_testHotKey(String p1,String p2,BlockException exception) { return \"-----dealHandler_testHotKey\"; } sentinel系统默认的提示：Blocked by Sentinel (flow limiting) 17.6.3、配置 两种情况 第一种情况 @SentinelResource(value = \"testHotKey\") 异常打到了前台用户界面看到，不友好 第二种情况 @SentinelResource(value = \"testHotKey\",blockHandler =\"dealHandler_testHotKey\") 方法testHotKey里面第一个参数只要QPS超过每秒1次，马上降级处理，用了我们自己定义的 17.6.4、测试 error：http://localhost:8401/testHotKey?p1=abc error：http://localhost:8401/testHotKey?p1=abc\u0026p2=33 right：http://localhost:8401/testHotKey?p2=abc 17.6.5、参数例外项(重点！！！！！) 上述案例演示了第一个参数p1，当QPS超过1秒1次点击后马上被限流 特例情况 普通：超过1秒钟一个后，达到阈值1后马上被限流 我们期望p1参数当它是某个特殊值时，它的限流值和平时不一样 特例：假如当p1的值等于5时，它的阈值可以达到200 配置 测试 right：http://localhost:8401/testHotKey?p1=5 error：http://localhost:8401/testHotKey?p1=3 当p1等于5的时候，阈值变为200 当p1不等于5的时候，阈值就是平常的1 前提条件：热点参数的注意点，参数必须是基本类型或者String 17.6.6、其它 当你手动在代码中添加一个异常再次访问时，会直接出现报错界面，而不是你设置的兜底方法 @SentinelResource 处理的是Sentinel控制台配置的违规情况，有blockHandler方法配置的兜底处理 RuntimeException int age = 10/0,这个是java运行时报出的运行时异常RunTimeException，@SentinelResource不管 总结：@SentinelResource主管配置出错，运行出错该走异常走异常 ","date":"2021-10-14","objectID":"/springcloud/:17:6","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.7、系统规则 系统自适应限流 各项配置参数说明 可以配置一个全局QPS ","date":"2021-10-14","objectID":"/springcloud/:17:7","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.8、@SentinelResource 17.8.1、按资源名称限流+后续处理 启动Nacos成功 启动Sentinel成功：java -jar sentinel-dashboard-1.7.0.jar 修改cloud-alibaba-sentinel-service8401 修改POM，引入我们自定义的实体类 \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e 增加一个业务类：RateLimitController package com.clover.springcloud.alibaba.controller; import com.alibaba.csp.sentinel.annotation.SentinelResource; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class RateLimitController { @GetMapping(\"/byResource\") @SentinelResource(value = \"byResource\",blockHandler = \"handleException\") public CommonResult byResource() { return new CommonResult(200,\"按资源名称限流测试OK\",new Payment(2020L,\"serial001\")); } public CommonResult handleException(BlockException exception) { return new CommonResult(444,exception.getClass().getCanonicalName()+\"\\t 服务不可用\"); } } 配置流控规则 图形配置和代码关系 表示1秒钟内查询次数大于1，就跑到我们自定义的处流，限流 测试 1秒钟点击1下，OK 超过上述，疯狂点击，返回了自己定义的限流处理信息，限流发生 额外问题 此时关闭问服务8401看看 Sentinel控制台，流控规则消失了？？？？？ 临时/持久？ 17.8.2、按照URL地址限流+后续处理 通过访问的URL来限流，会返回Sentinel自带默认的限流处理信息 修改业务类RateLimitController @GetMapping(\"/rateLimit/byUrl\") @SentinelResource(value = \"byUrl\") public CommonResult byUrl() { return new CommonResult(200,\"按url限流测试OK\",new Payment(2020L,\"serial002\")); } 访问一次 ：http://localhost:8401/rateLimit/byUrl Sentinel控制台配置 测试 疯狂点击http://localhost:8401/rateLimit/byUrl 结果：会返回Sentinel自带的限流处理结果 17.8.3、上面兜底方案面临的问题 系统默认的，没有体现我们自己的业务要求 依照现有条件，我们自定义的处理方法又和业务代码耦合在一块，不直观 每个业务方法都添加一个兜底的，那代码膨胀加剧 全局统一的处理方法没有体现 17.8.4、客户自定义限流处理逻辑 创建CustomerBlockHandler类用于自定义限流处理逻辑 自定义限流处理类：CustomerBlockHandler package com.clover.springcloud.alibaba.myhandler; import com.alibaba.csp.sentinel.slots.block.BlockException; import com.clover.springcloud.entities.CommonResult; public class CustomerBlockHandler { public static CommonResult handleException(BlockException exception){ return new CommonResult(2020,\"自定义的限流处理信息......CustomerBlockHandler---handleException\"); } public static CommonResult handleException2(BlockException exception){ return new CommonResult(2020,\"自定义的限流处理信息......CustomerBlockHandler---handleException2\"); } } 启动微服务后先调用一次 http://localhost:8401/rateLimit/customerBlockHandler Sentinel控制台配置 测试后我们自定义的出来了 进一步说明 17.8.5、更多注解属性说明 多说一句 所有的代码都要用try-catch-finally方式进行处理 Sentinel主要有三个核心Api SphU定义资源 Tracer定义统计 ContextUtil定义了上下文 ","date":"2021-10-14","objectID":"/springcloud/:17:8","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.9、服务熔断功能 sentinel整合ribbon+openFeign+fallback 17.9.1、Ribbon系列 启动nacos和sentinel 提供者9003/9004 新建cloud-alibaba-provider-payment9003/9004两个一样的做法 修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-provider-payment9003\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e\u003c!-- 引入自己定义的api通用包，可以使用Payment支付Entity --\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cartifactId\u003ecloud-api-commons\u003c/artifactId\u003e \u003cversion\u003e${project.version}\u003c/version\u003e \u003c/dependency\u003e \u003c!-- SpringBoot整合Web组件 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--日常通用jar包配置--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 编写YML：记得修改不同的端口号 server: port: 9003 spring: application: name: nacos-payment-provider cloud: nacos: discovery: server-addr: localhost:8848 #配置Nacos地址 management: endpoints: web: exposure: include: '*' 编写主启动类 package com.clover.springcloud.alibaba; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.client.discovery.EnableDiscoveryClient; @SpringBootApplication @EnableDiscoveryClient public class PaymentMain9003 { public static void main(String[] args) { SpringApplication.run(PaymentMain9003.class,args); } } 编写业务类 package com.clover.springcloud.alibaba.controller; import com.clover.springcloud.entities.CommonResult; import com.clover.springcloud.entities.Payment; import org.springframework.beans.factory.annotation.Value; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; @RestController public class PaymentController { @Value(\"${server.port}\") private String serverPort; // 模拟一个数据库的操作 public static HashMap\u003cLong, Payment\u003e hashMap = new HashMap\u003c\u003e(); static { hashMap.put(1L,new Payment(1L,\"28a8c1e3bc2742d8848569891fb42181\")); hashMap.put(2L,new Payment(2L,\"bba8c1e3bc2742d8848569891ac32182\")); hashMap.put(3L,new Payment(3L,\"6ua8c1e3bc2742d8848569891xt92183\")); } @GetMapping(value = \"/paymentSQL/{id}\") public CommonResult\u003cPayment\u003e paymentSQL(@PathVariable(\"id\") Long id) { Payment payment = hashMap.get(id); CommonResult\u003cPayment\u003e result = new CommonResult(200,\"from mysql,serverPort: \"+serverPort,payment); return result; } } 测试地址：http://localhost:9003/paymentSQL/1 消费者84 新建cloud-alibaba-consumer-nacos-order84 修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003ecloud-alibaba-consumer-nacos-order84\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--SpringCloud ailibaba nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifact","date":"2021-10-14","objectID":"/springcloud/:17:9","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"17.10、规则持久化 是什么？ 一旦我们重启应用，sentinel规则将消失，生产环境需要将配置规则进行持久化 怎么玩？ 将限流配置规则持久化进Nacos保存，只要刷新8401某个rest地址，sentinel控制台的流控规则就能看到，只要Nacos里面的配置不删除，针对8401上sentinel上的流控规则持续有效 17.10.1、持久化步骤 修改cloud-alibaba-sentinel-service8401 修改POM \u003c!--SpringCloud ailibaba sentinel-datasource-nacos --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.csp\u003c/groupId\u003e \u003cartifactId\u003esentinel-datasource-nacos\u003c/artifactId\u003e \u003c/dependency\u003e 修改YML 添加Nacos数据源配置 spring: cloud: sentinel: datasource: ds1: nacos: server-addr: localhost:8848 dataId: ${spring.application.name} groupId: DEFAULT_GROUP data-type: json rule-type: flow server: port: 8401 spring: application: name: cloud-alibaba-sentinel-service cloud: nacos: discovery: #Nacos服务注册中心地址 server-addr: localhost:8848 sentinel: transport: #配置Sentinel dashboard地址 dashboard: localhost:8080 #默认8719端口，假如被占用会自动从8719开始依次+1扫描,直至找到未被占用的端口 port: 8719 datasource: ds1: nacos: server-addr: localhost:8848 dataId: cloud-alibaba-sentinel-service groupId: DEFAULT_GROUP data-type: json rule-type: flow management: endpoints: web: exposure: include: '*' 添加Nacos业务规则配置 内容解析 [ { \"resource\": \"/rateLimit/byUrl\", \"limitApp\": \"default\", \"grade\": 1, \"count\": 1, \"strategy\": 0, \"controlBehavior\": 0, \"clusterMode\": false } ] resource：资源名称； limitApp：来源应用； grade：阈值类型，0表示线程数，1表示QPS； count：单机阈值； strategy：流控模式，0表示直接，1表示关联，2表示链路； controlBehavior：流控效果，0表示快速失败，1表示Warm Up，2表示排队等待； clusterMode：是否集群 启动8401后刷新sentinel发现业务规则有了 快速访问测试接口：http://localhost:8401/rateLimit/byUrl 停止8401再看sentinel 重新启动8401再看sentinel 乍一看还是没有，稍等一会儿 多次调用：http://localhost:8401/rateLimit/byUrl 重新配置出现了，持久化验证通过 ","date":"2021-10-14","objectID":"/springcloud/:17:10","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18、SpringCloud Alibaba Seata处理分布式事务 ","date":"2021-10-14","objectID":"/springcloud/:18:0","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.1、分布式事务问题 18.1.1、分布式之前 单机单库没这个问题 从1：1 -\u003e 1：N -\u003e N：N 18.1.2、分布式之后 单体应用被拆分成微服务应用，原来的三个模块被拆分成三个独立的应用，分别使用三个独立的数据源 业务操作需要调用三个服务来完成。此时每个服务内部的数据一致性由本地事务来保证，但是全局的数据一致性问题没法保证 一句话：一次业务操作需要跨多个数据源或需要跨多个系统进行远程调用，就会产生分布式事务问题 ","date":"2021-10-14","objectID":"/springcloud/:18:1","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.2、Seata简介 18.2.1、Seata是什么？ Seata是一款开源的分布式事务解决方案，致力于在微服务架构下提供高性能和简单易用的分布式事务服务。 官网地址 18.2.2、能干嘛？ 一个典型的分布式事务过程 分布式事务处理过程的一ID+三组件模型 Transaction ID XID：全局唯一的事务ID Transaction Coordinator (TC)：事务协调器，维护全局事务的运行状态，负责协调并驱动全局事务的提交或回滚； Transaction Manager (TM)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局提交或全局回滚的决议； Resource Manager (RM)：控制分支事务，负责分支注册、状态汇报，并接收事务协调器的指令，驱动分支（本地）事务的提交和回滚 处理过程 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的 XID； XID 在微服务调用链路的上下文中传播； RM 向 TC 注册分支事务，将其纳入 XID 对应全局事务的管辖； TM 向 TC 发起针对 XID 的全局提交或回滚决议； TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。 简单解释： TM：代表一个班级班主任 TC：代表一个任课老师 RM：代表上课学生 班主任老师向任课老师说，我们这个课程可以开了嘛？老师说好，然后班主任去创建一个班级号，这个就是我们的XID，全局唯一 创建班级号后，班主任老师就去微信群里面发送该班级号，让选了该课程的学生进入到该课程的学习 同学就通过班主任给的班级号进入到直播中来学习，老师就可以实时的看到有多少人成功进入，老师就会把这些学生纳入到该班级管理中 班主任说让学生进行一个签到，然后告诉老师，说学生全部进入，可以开始上课了 当老师将该课程上完的时候，老师就会将该班级该门课程进行结课 18.2.3、去哪下？ 发布说明 18.2.4、怎么玩？ 本地@Transactional 全局@GlobalTransactional SEATA 的分布式交易解决方案 ","date":"2021-10-14","objectID":"/springcloud/:18:2","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.3、Seata-Server安装 官网地址：官网地址 下载版本 https://github.com/seata/seata/releases 下载的是seata-server-0.9.0.zip seata-server-0.9.0.zip解压到指定目录并修改conf目录下的file.conf配置文件 先备份原始file.conf文件 主要修改：自定义事务组名称+事务日志存储模式为db+数据库连接信息 file.conf service模块 store模块 mysql5.7数据库新建库seata 在seata库里建表 建表db_store.sql在\\seata-server-0.9.0\\seata\\conf目录里面：db_store.sql 修改seata-server-0.9.0\\seata\\conf目录下的registry.conf配置文件 先启动Nacos端口号8848 再启动seata-server ","date":"2021-10-14","objectID":"/springcloud/:18:3","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.4、订单/库存/账户业务数据库准备 以下演示都需要先启动Nacos后启动Seata，保证两个都OK Seata没启动报错no available server to connect 分布式事务业务说明 这里我们会创建三个服务，一个订单服务，一个库存服务，一个账户服务 当用户下单时，会在订单服务中创建一个订单，然后通过远程调用库存服务来扣减下单商品的库存 再通过远程调用账户服务来扣减用户账户里面的余额 最后在订单服务中修改订单状态为已完成 该操作跨越三个数据库，有两次远程调用，很明显会有分布式事务问题 下订单—\u003e扣库存—\u003e减账户(余额) 创建业务数据库 seata_order：存储订单的数据库 seata_storage：存储库存的数据库 seata_account：存储账户信息的数据库 按照上述3库分别建对应业务表 seata_order库下建t_order表 CREATE TABLE t_order ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `user_id` BIGINT(11) DEFAULT NULL COMMENT '用户id', `product_id` BIGINT(11) DEFAULT NULL COMMENT '产品id', `count` INT(11) DEFAULT NULL COMMENT '数量', `money` DECIMAL(11,0) DEFAULT NULL COMMENT '金额', `status` INT(1) DEFAULT NULL COMMENT '订单状态：0：创建中；1：已完结' ) ENGINE=INNODB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; SELECT * FROM t_order; seata_storage库下建t_storage 表 CREATE TABLE t_storage ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY, `product_id` BIGINT(11) DEFAULT NULL COMMENT '产品id', `total` INT(11) DEFAULT NULL COMMENT '总库存', `used` INT(11) DEFAULT NULL COMMENT '已用库存', `residue` INT(11) DEFAULT NULL COMMENT '剩余库存' ) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_storage.t_storage(`id`, `product_id`, `total`, `used`, `residue`) VALUES ('1', '1', '100', '0', '100'); SELECT * FROM t_storage; seata_account库下建t_account CREATE TABLE t_account ( `id` BIGINT(11) NOT NULL AUTO_INCREMENT PRIMARY KEY COMMENT 'id', `user_id` BIGINT(11) DEFAULT NULL COMMENT '用户id', `total` DECIMAL(10,0) DEFAULT NULL COMMENT '总额度', `used` DECIMAL(10,0) DEFAULT NULL COMMENT '已用余额', `residue` DECIMAL(10,0) DEFAULT '0' COMMENT '剩余可用额度' ) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO seata_account.t_account(`id`, `user_id`, `total`, `used`, `residue`) VALUES ('1', '1', '1000', '0', '1000'); SELECT * FROM t_account; 按照上述3库分别建对应的回滚日志表 订单-库存-账户3个库下都需要建各自的回滚日志表 \\seata-server-0.9.0\\seata\\conf目录下的db_undo_log.sql -- the table to store seata xid data -- 0.7.0+ add context -- you must to init this sql for you business databese. the seata server not need it. -- 此脚本必须初始化在你当前的业务数据库中，用于AT 模式XID记录。与server端无关（注：业务数据库） -- 注意此处0.3.0+ 增加唯一索引 ux_undo_log drop table `undo_log`; CREATE TABLE `undo_log` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `branch_id` bigint(20) NOT NULL, `xid` varchar(100) NOT NULL, `context` varchar(128) NOT NULL, `rollback_info` longblob NOT NULL, `log_status` int(11) NOT NULL, `log_created` datetime NOT NULL, `log_modified` datetime NOT NULL, `ext` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `ux_undo_log` (`xid`,`branch_id`) ) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8; ","date":"2021-10-14","objectID":"/springcloud/:18:4","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.5、订单/库存/账户业务微服务准备 18.5.1、业务需求 下订单-\u003e减库存-\u003e扣余额-\u003e改(订单)状态 18.5.2、新建订单Order-Module 新建seata-order-service2001 修改POM \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cproject xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"\u003e \u003cparent\u003e \u003cartifactId\u003eSpringCloud\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover.springcloud\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e \u003cmodelVersion\u003e4.0.0\u003c/modelVersion\u003e \u003cartifactId\u003eseata-order-service2001\u003c/artifactId\u003e \u003cdependencies\u003e \u003c!--nacos--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-nacos-discovery\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--seata--\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-alibaba-seata\u003c/artifactId\u003e \u003cexclusions\u003e \u003cexclusion\u003e \u003cartifactId\u003eseata-all\u003c/artifactId\u003e \u003cgroupId\u003eio.seata\u003c/groupId\u003e \u003c/exclusion\u003e \u003c/exclusions\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eio.seata\u003c/groupId\u003e \u003cartifactId\u003eseata-all\u003c/artifactId\u003e \u003cversion\u003e0.9.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--feign--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.cloud\u003c/groupId\u003e \u003cartifactId\u003espring-cloud-starter-openfeign\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--web-actuator--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-web\u003c/artifactId\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-actuator\u003c/artifactId\u003e \u003c/dependency\u003e \u003c!--mysql-druid--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.37\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003edruid-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e1.1.10\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.spring.boot\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring-boot-starter\u003c/artifactId\u003e \u003cversion\u003e2.0.0\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-test\u003c/artifactId\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e \u003c/dependencies\u003e \u003c/project\u003e 编写YML server: port: 2001 spring: application: name: seata-order-service cloud: alibaba: seata: #自定义事务组名称需要与seata-server中的对应 tx-service-group: clover_tx_group nacos: discovery: server-addr: localhost:8848 datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/seata_order username: root password: xn123456 feign: hystrix: enabled: false logging: level: io: seata: info mybatis: mapperLocations: classpath:mapper/*.xml 创建file.conf文件 transport { # tcp udt unix-domain-socket type = \"TCP\" #NIO NATIVE server = \"NIO\" #enable heartbeat heartbeat = true #thread factory for netty thread-factory { boss-thread-prefix = \"NettyBoss\" worker-thread-prefix = \"NettyServerNIOWorker\" server-executor-thread-prefix = \"NettyServerBizHandler\" share-boss-worker = false client-selector-thread-prefix = \"NettyClientSelector\" client-selector-thread-size = 1 client-worker-thread-prefix = \"NettyClientWorkerThread\" # netty boss thread size,will not be used for UDT boss-thread-size = 1 #auto default pin or 8 worker-thread-size = 8 } shutdown { # when destroy server, wait seconds wait = 3 } serialization = \"seata\" compressor = \"none\" } service { vgroup_mapping.clover_tx_group = \"default\" #修改自定义事务组名称 default.grouplist = \"127.0.0.1:8091\" enableDegrade = false disable = false max.commit.retry.timeout = \"-1\" max.rollback.retry.timeout = \"-1\" disableGlobalTransaction = false } client { async.commit.buffer.limit = 10000 lock { retry.internal = 10 retry.times = 30 } report.retry.count = 5 tm.commit.retry.count = 1 tm.rollback.retry.count = 1 } ## transaction log store store { ## store mode: file、db mode = \"db\" ## file store file { dir = \"sessionStore\" # branch session size , if exceeded first try compress lockkey, still exceeded throws exceptions max-branch-sessi","date":"2021-10-14","objectID":"/springcloud/:18:5","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.6、Test 18.6.1、正常下单 http://localhost:2001/order/create?userId=1\u0026productId=1\u0026count=10\u0026money=100 18.6.2、超时异常，没加@GlobalTransactional AccountServiceImpl添加超时 数据库情况 故障情况 当库存和账户金额扣减后，订单状态并没有设置为已经完成，没有从零改为1 而且由于feign的重试机制，账户余额还有可能被多次扣减 18.6.3、超时异常，添加@GlobalTransactional AccountServiceImpl添加超时 OrderServiceImpl添加@GlobalTransactional @GlobalTransactional(name = “clover-create-order”,rollbackFor = Exception.class) 下单后数据库数据并没有任何改变 记录都添加不进来 ","date":"2021-10-14","objectID":"/springcloud/:18:6","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["SpringCloud"],"content":"18.7、一部分补充 Seata 2019年1月份蚂蚁金服和阿里巴巴共同开源的分布式事务解决方案 Simple Extensible Autonomous Transaction Architecture，简单可扩展自治事务框架 2020起始，参加工作后用1.0以后的版本 再看TC/TM/RM三大组件 分布式事务的执行流程 TM 开启分布式事务（TM 向 TC 注册全局事务记录） 按业务场景，编排数据库、服务等事务内资源（RM 向 TC 汇报资源准备状态 ） TM 结束分布式事务，事务一阶段结束（TM 通知 TC 提交/回滚分布式事务） TC 汇总事务信息，决定分布式事务是提交还是回滚 TC 通知所有 RM 提交/回滚 资源，事务二阶段结束 AT模式如何做到对业务的无侵入 是什么 一阶段加载 在一阶段，Seata 会拦截“业务 SQL” 解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成before image 执行“业务 SQL”更新业务数据，在业务数据更新之后 其保存成after image，最后生成行锁 以上操作全部在一个数据库事务内完成，这样保证了一阶段操作的原子性 二阶段提交 二阶段如是顺利提交的话；因为“业务 SQL”在一阶段已经提交至数据库，所以Seata框架只需将一阶段保存的快照数据和行锁删掉，完成数据清理即可 二阶段回滚 二阶段如果是回滚的话，Seata 就需要回滚一阶段已经执行的“业务 SQL”，还原业务数据 回滚方式便是用before image还原业务数据；但在还原前要首先要校验脏写，对比数据库当前业务数据和 after image 如果两份数据完全一致就说明没有脏写，可以还原业务数据，如果不一致就说明有脏写，出现脏写就需要转人工处理 debug 补充 ","date":"2021-10-14","objectID":"/springcloud/:18:7","tags":["SpringCloud"],"title":"Springcloud","uri":"/springcloud/"},{"categories":["React"],"content":"ReactExpand","date":"2021-10-02","objectID":"/reactexpand/","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"1. setState setState更新状态的2种写法 1.对象式setState: setState是一个由我们自己去调用的同步方法，但是调用完setState后，需要react帮我们根据参数去修改状态，并且重新渲染页面，这个是异步的，也就是react不会在调用setState后立马去改变状态和重新渲染。但是setState第二个参数————函数，是在react在调用setState后更新完组件并且重新渲染页面后被调用的，如果需要一更新完状态就查看状态的需求，就可以在这个函数中写输出语句 setState(stateChange, [callback])——对象式的setState stateChange为状态改变对象(该对象可以体现出状态的更改) callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 2.函数式setState： setState(updater, [callback])——函数式的setState 1.updater为返回stateChange对象的函数。 2.updater可以接收到state和props。 4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 总结: 区别：函数式setState可以获取到此次更新前的state以及props 而对象式setState就需要自己this.state去获取state 1.对象式的setState是函数式的setState的简写方式(语法糖) 2.使用原则： (1).如果新状态不依赖于原状态 ===\u003e 使用对象方式 (2).如果新状态依赖于原状态 ===\u003e 使用函数方式 (3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取 App.js import React, { Component } from 'react' import StateTest from './components/1_setState' export default class App extends Component { render() { return ( \u003cdiv\u003e {/* addend：给StateTest组件传递加数 */} \u003cStateTest addend={1}/\u003e \u003c/div\u003e ) } } 1_setState.js import React, { Component } from 'react' export default class StateTest extends Component { state = {count:0} getSum = () =\u003e { /** * 对象式setState： * 参数一：更新状态对象 * 参数二：函数，该函数会在人为调用setState函数后，react接收到信号，去根据参数修改状态并重新渲染组件后被调用 * 所以在该函数中输出的状态，为更新后的状态。由于react根据参数去修改状态并重新渲染页面是异步的，所以在setState下面输出的状态为还未更新成功的状态 */ // this.setState( // {count:this.state.count+1}, // () =\u003e {console.log(this.state.count);} //初次输出1 // ) // console.log(this.state.count); //初次输出0 /** * 函数式setState * 参数一：返回更新状态对象的函数，该函数可以接收到更新前的state以及可以接收到props * 参数二：函数（与对象式setState一样），该函数会在人为调用setState函数后，react接收到信号，去根据参数修改状态并重新渲染组件后被调用 */ this.setState( (state,props) =\u003e ({count:state.count+props.addend}), () =\u003e {console.log(this.state.count);} //初次输出1 ) console.log(this.state.count); //初次输出0 } render() { return ( \u003cdiv\u003e \u003ch2\u003e当前求和为：{this.state.count}\u003c/h2\u003e \u003cbutton onClick={this.getSum}\u003e+1\u003c/button\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/reactexpand/:1:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"2. lazyLoad import About from ‘./About’ import Home from ‘./Home’ 这样引入的路由组件都是直接加载组件，一访问网页，就会加载出所有的路由组件，当你再去点击某个路由组件时，这时已经没有资源请求了，因为在一进页面已经请求完了所有路由组件的资源 用懒加载引入的路由组件，是当点击某个路由组件跳转时，才去请求这个路由组件对应的资源 1.通过React的lazy函数配合import()函数动态加载路由组件 ===\u003e 路由组件代码会被分开打包 2.通过指定在加载得到路由打包文件前显示一个自定义loading界面 About.js import React, { Component } from 'react' export default class About extends Component { render() { return ( \u003ch3\u003e我是About的内容\u003c/h3\u003e ) } } Home.js import React, { Component } from 'react' export default class Home extends Component { render() { return ( \u003ch3\u003e我是Home的内容\u003c/h3\u003e ) } } Loading.js (在加载得到路由打包文件前显示一个自定义loading界面) import React, { Component } from 'react' export default class Loading extends Component { render() { return ( \u003cdiv\u003e \u003ch2 style={{color: \"red\"}}\u003e加载中\u003c/h2\u003e \u003c/div\u003e ) } } LazyLoadTest.js import React, { Component, lazy, Suspense} from 'react' import {NavLink, Route} from 'react-router-dom' // 引入懒加载暂时没加载出来时显示的组件 import Loading from './Loading' // 这样引入的路由组件都是直接加载组件，一访问网页，就会加载出所有的路由组件，当你再去点击某个路由组件时，这时已经没有资源请求了，因为在一进页面已经请求完了所有路由组件的资源 // import About from './About' // import Home from './Home' //懒加载引入路由组件 //切记：这里lazy的函数参数体中的{}必须去掉：import('./Home')，不然会报错。如果加了{}就必须return：{return import('./Home')} const Home = lazy(()=\u003e {return import('./Home')} ) const About = lazy(()=\u003e import('./About') ) export default class LazyLoadTest extends Component { render() { return ( \u003cdiv\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-offset-2 col-xs-8\"\u003e \u003cdiv className=\"page-header\"\u003e\u003ch2\u003eReact Router Demo\u003c/h2\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e \u003cNavLink className=\"list-group-item\" to=\"/about\"\u003eAbout\u003c/NavLink\u003e \u003cNavLink className=\"list-group-item\" to=\"/home\"\u003eHome\u003c/NavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* Suspense中的fallback是为了防止网速过慢，导致懒加载时一下子加载不出来，fallback的属性值是当网速过慢时，懒加载没加载出来之前显示的页面，可以直接写一个VDOM，也可以定义一个组件，但是注意这个组件不能也为懒加载 */} \u003cSuspense fallback={\u003cLoading/\u003e}\u003e \u003cRoute path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003c/Suspense\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/reactexpand/:2:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"3. Hooks 1. React Hook/Hooks是什么? (1). Hook是React 16.8.0版本增加的新特性/新语法 (2). 可以让你在函数组件中使用 state 以及其他的 React 特性 2. 三个常用的Hook (1). State Hook: React.useState() (2). Effect Hook: React.useEffect() (3). Ref Hook: React.useRef() 3. State Hook 数组也可以结构赋值： arr[1,2,3,4] const[a,b]=arr a就为1，b就为2 (1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作 (2). 语法: const [xxx, setXxx] = React.useState(initValue) (3). useState()说明: 参数: 第一次初始化指定的值在内部作缓存（函数式组件中的函数一进页面自动调用一次，之后每修改一次状态，就会重新调用一次，虽然会重新调用const [xxx, setXxx] = React.useState(initValue)这句代码，但是不会让initValue覆盖掉当前state的值，也就是底层只会初始化一次state） 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数 (4). setXxx()2种写法: setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值 setXxx(value =\u003e newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值 StateHookTest.js import React from 'react' // 类式组件操作state // class StateHookTest extends React.Component { // state={count:0} // add = () =\u003e { // this.setState(state =\u003e ({count:state.count+1})) // } // render() { // return ( // \u003cdiv\u003e // \u003ch2\u003e当前求和为：{this.state.count}\u003c/h2\u003e // \u003cbutton onClick={this.add}\u003e点我+1\u003c/button\u003e // \u003c/div\u003e // ) // } // } //函数式组件操作state function StateHookTest (){ const [count,setCount] = useState(0) function add(){ setCount(count+1) } return ( \u003cdiv\u003e \u003ch2\u003e当前求和为：{count}\u003c/h2\u003e \u003cbutton onClick={add}\u003e点我+1\u003c/button\u003e \u003c/div\u003e ) } 4. Effect Hook (1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子) (2). React中的副作用操作: 发ajax请求数据获取 设置订阅 / 启动定时器 手动更改真实DOM (3). 语法和说明: useEffect(() =\u003e { // 在此可以执行任何带副作用操作 return () =\u003e { // 在组件卸载前执行 // 在此做一些收尾工作, 比如清除定时器/取消订阅等 } }, [stateValue]) 1.useEffect的第二个参数次昂当于监测参数数组中的数据改变，如果数组参数中的数据改变了，就会重新调用参数1中的回调函数，该回调函数就相当于componentDidMount+componentDidUpdate钩子。 2.如果指定的是[], 表示回调函数不为任何东西的改变所重新调用，所以回调函数只会在第一次render()后执行，相当于componentDidMount。 3.useEffect函数第一个参数：回调函数的返回函数就相当于componentWillUnmount钩子 (4). 可以把 useEffect Hook 看做如下三个函数的组合 componentDidMount() componentDidUpdate() componentWillUnmount() EffectHook.js import React, {useState, useEffect} from 'react' import { unmountComponentAtNode } from 'react-dom' // 类式组件操作state // class EffectHook extends React.Component { // state={count:0} // // 挂载完毕后开启定时器，使count1秒中+1一次 // componentDidMount(){ // this.timer = setInterval(()=\u003e{ // this.setState(state =\u003e ({count:state.count+1})) // },1000) // } // // 将要卸载时，关闭定时器 // componentWillUnmount(){ // clearInterval(this.timer) // } // add = () =\u003e { // this.setState(state =\u003e ({count:state.count+1})) // } // unmount = () =\u003e{ // unmountComponentAtNode(document.getElementById(\"root\")) // } // render() { // return ( // \u003cdiv\u003e // \u003ch2\u003e当前求和为：{this.state.count}\u003c/h2\u003e // \u003cbutton onClick={this.add}\u003e点我+1\u003c/button\u003e // \u003cbutton onClick={this.unmount}\u003e点我卸载组件\u003c/button\u003e // \u003c/div\u003e // ) // } // } //函数式组件操作state function EffectHook (){ const [count,setCount] = useState(0) const [name,setName] = useState('张三') function add(){ setCount(count+1) } function changeName(){ setName('憨憨') } function unmount(){ unmountComponentAtNode(document.getElementById(\"root\")) } /** * useEffect: * 参数1：函数 * 参数2：监听状态数组 * 如果参数2指定了状态，那么当这些状态的值改变时，参数1的回调函数会重新被调用。相当于componentDidMount钩子+componentDidUpdate钩子 * 如果参数2中没指定状态，只传一个空数组，表示不监听任何状态的改变，所以参数1的回调函数只在第一次进页面时被调用一次，相当于componentDidMount钩子 * 参数1的返回函数相当于componentWillUnMount钩子 */ useEffect(() =\u003e { // 只在第一次进页面开启一个定时器 let timer = setInterval(()=\u003e{setCount(count =\u003e count+1)},1000) // 在页面将要卸载之前关闭定时器 return ()=\u003e{clearInterval(timer)} },[]) return ( \u003cdiv\u003e \u003ch2\u003e当前求和为：{count}---{name}\u003c/h2\u003e \u003cbutton onClick={add}\u003e点我+1\u003c/button\u003e \u003cbutton onClick={changeName}\u003e点我修改名字\u003c/button\u003e \u003cbutton onClick={unmount}\u003e点我卸载组件\u003c/button\u003e \u003c/div\u003e ) } export default EffectHook 5. Ref Hook (1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据 (2). 语法: const refContainer = useRef() (3). 作用:保存标签对象,功能与React.createRef()一样 RefHook.js import React, {useState, useEffect, useRef} from 'react' import { unmountComponentAtNode } from 'react-dom' // 类式组件操作state // class RefHook extends React.Component { // state={count:0} // // 创建一个ref容器 // myRef = React.createRef() // // 挂载完毕后开启定时器，使count1秒中+1一次 // componentDidMount(){ // this.timer = setInterval(()=\u003e{ // this.","date":"2021-10-02","objectID":"/reactexpand/:3:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"4. Fragment ","date":"2021-10-02","objectID":"/reactexpand/:4:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"使用 \u003cFragment\u003e\u003cFragment\u003e \u003c\u003e\u003c/\u003e ","date":"2021-10-02","objectID":"/reactexpand/:4:1","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"作用 可以不用必须有一个真实的DOM根标签了 正常项目出来外层最少会有三级div，第一级：index.html中的，第二级：App.js中的，第三级：自身组件最外层必须套的一个div 为了避免出现这么多无用的div嵌套，可以使用或者\u003c\u003e\u003c/\u003e代替 使用浏览器会在解析时自动抛掉这个标签，并且这个标签只能接收一个参数，就是key，除了key之外不接收任何参数，如果Fragment标签内的东西全都是遍历得到，就需要指定key。 但是使用\u003c\u003e\u003c/\u003e则不能接受任何参数 所以如果Fragment中的内容是遍历出来的，就使用Fragment标签，如果不是遍历来的就可以使用\u003c\u003e\u003c/\u003e空标签 App.js import React, { Component, Fragment } from 'react' import FragmentTest from './components/FragmentTest' export default class App extends Component { render() { return ( \u003cFragment\u003e \u003cFragmentTest/\u003e \u003c/Fragment\u003e ) } } FragmentTest.js import React, {useState, useEffect, useRef, Fragment} from 'react' import { unmountComponentAtNode } from 'react-dom' // 类式组件操作state // class FragmentTest extends React.Component { // state={count:0} // // 创建一个ref容器 // myRef = React.createRef() // // 挂载完毕后开启定时器，使count1秒中+1一次 // componentDidMount(){ // this.timer = setInterval(()=\u003e{ // this.setState(state =\u003e ({count:state.count+1})) // },1000) // } // // 将要卸载时，关闭定时器 // componentWillUnmount(){ // clearInterval(this.timer) // } // add = () =\u003e { // this.setState(state =\u003e ({count:state.count+1})) // } // // 展示myRef容器中的结点的value值 // show = () =\u003e{ // alert(this.myRef.current.value) // } // unmount = () =\u003e{ // unmountComponentAtNode(document.getElementById(\"root\")) // } // render() { // return ( // \u003cdiv\u003e // \u003ch2\u003e当前求和为：{this.state.count}\u003c/h2\u003e // \u003cinput type=\"text\" ref={this.myRef}/\u003e // \u003cbutton onClick={this.add}\u003e点我+1\u003c/button\u003e // \u003cbutton onClick={this.show}\u003e点我提示输入框内容\u003c/button\u003e // \u003cbutton onClick={this.unmount}\u003e点我卸载组件\u003c/button\u003e // \u003c/div\u003e // ) // } // } //函数式组件操作state function FragmentTest (){ const [count,setCount] = useState(0) const [name,setName] = useState('张三') // 创建一个ref容器 const myRef = useRef() function add(){ setCount(count+1) } function changeName(){ setName('憨憨') } // 展示myRef容器中的结点的value值 function show(){ alert(myRef.current.value) } function unmount(){ unmountComponentAtNode(document.getElementById(\"root\")) } /** * useEffect: * 参数1：函数 * 参数2：监听状态数组 * 如果参数2指定了状态，那么当这些状态的值改变时，参数1的回调函数会重新被调用。相当于componentDidMount钩子+componentDidUpdate钩子 * 如果参数2中没指定状态，只传一个空数组，表示不监听任何状态的改变，所以参数1的回调函数只在第一次进页面时被调用一次，相当于componentDidMount钩子 * 参数1的返回函数相当于componentWillUnMount钩子 */ useEffect(() =\u003e { // 只在第一次进页面开启一个定时器 let timer = setInterval(()=\u003e{setCount(count =\u003e count+1)},1000) // 在页面将要卸载之前关闭定时器 return ()=\u003e{clearInterval(timer)} },[]) return ( \u003cFragment\u003e \u003ch2\u003e当前求和为：{count}---{name}\u003c/h2\u003e \u003cinput type=\"text\" ref={myRef}/\u003e \u003cbutton onClick={add}\u003e点我+1\u003c/button\u003e \u003cbutton onClick={changeName}\u003e点我修改名字\u003c/button\u003e \u003cbutton onClick={show}\u003e点我提示输入框内容\u003c/button\u003e \u003cbutton onClick={unmount}\u003e点我卸载组件\u003c/button\u003e \u003c/Fragment\u003e ) } export default FragmentTest ","date":"2021-10-02","objectID":"/reactexpand/:4:2","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"5. Context ","date":"2021-10-02","objectID":"/reactexpand/:5:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"理解 一种组件间通信方式, 常用于**【祖组件】与【后代组件】**间通信 ","date":"2021-10-02","objectID":"/reactexpand/:5:1","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"使用 1) 祖组件中创建Context容器对象： const XxxContext = React.createContext() 2) 祖组件渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据： \u003cxxxContext.Provider value={数据}\u003e 子组件 \u003c/xxxContext.Provider\u003e 3) 后代组件读取数据（需要声明接收祖组件传递的数据）： //第一种方式:仅适用于类组件 static contextType = xxxContext // 声明接收context this.context // 读取context中的value数据 //第二种方式: 函数组件与类组件都可以，在要使用祖组件传递的数据的地方声明接收 \u003cxxxContext.Consumer\u003e { value =\u003e ( // value就是context中的value数据 要显示的内容 ) } \u003c/xxxContext.Consumer\u003e 注意: 在应用开发中一般不用context, 一般都用它的封装react插件，即使用Provider标签传递数据给容器组件 Context.js import React, { Component} from 'react' import './index.css' // 创建一个Context容器，这里大写是因为到时候要把这个作为组件 const MyContext = React.createContext() export default class A extends Component { state={name:'张三', age:18} render() { const{name,age}=this.state return ( \u003cdiv className=\"parent\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e {/* 如果是单个数据，可以直接传 */} {/* \u003cMyContext.Provider value={this.state.name}\u003e \u003cB/\u003e \u003c/MyContext.Provider\u003e */} {/* 如果是多个数据，可以传一个对象，这里触发了对象的简写方式 */} \u003cMyContext.Provider value={{name,age}}\u003e \u003cB/\u003e \u003c/MyContext.Provider\u003e \u003c/div\u003e ) } } class B extends Component { render() { return ( \u003cdiv className=\"son\"\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e \u003cC/\u003e \u003c/div\u003e ) } } // 类式组件C // class C extends Component { // static contextType = MyContext // render() { // return ( // \u003cdiv className=\"grand\"\u003e // \u003ch2\u003e我是孙组件\u003c/h2\u003e // {/* this.context就是祖组件使用MyContext.Provider的属性value传递的数据 */} // \u003ch4\u003e我接受到的A组件传的数据：{`姓名为：${this.context.name},年龄为：${this.context.age}`}\u003c/h4\u003e // \u003c/div\u003e // ) // } // } // 函数式组件C function C (){ return ( \u003cdiv className=\"grand\"\u003e \u003ch2\u003e我是孙组件\u003c/h2\u003e \u003ch4\u003e 我接受到的A组件传的数据： \u003cMyContext.Consumer\u003e { // value就是祖组件使用MyContext.Provider的属性value传递的数据 value =\u003e `姓名为：${value.name},年龄为：${value.age}` } \u003c/MyContext.Consumer\u003e \u003c/h4\u003e \u003c/div\u003e ) } Context.css .parent{ width:500px; background-color: antiquewhite; padding: 10px; } .son{ width:100%; background-color: aquamarine; padding: 10px; } .grand{ width:100%; background-color: burlywood; padding: 10px; } ","date":"2021-10-02","objectID":"/reactexpand/:5:2","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"6. 组件优化 ","date":"2021-10-02","objectID":"/reactexpand/:6:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"Component的2个问题 只要执行setState(),即使不改变状态数据, 组件也会重新render() ==\u003e 效率低 只当前组件重新render(), 就会自动重新render子组件，纵使子组件没有用到父组件的任何数据 ==\u003e 效率低 ","date":"2021-10-02","objectID":"/reactexpand/:6:1","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"效率高的做法 只有当组件的state或props数据发生改变时才重新render() ","date":"2021-10-02","objectID":"/reactexpand/:6:2","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"原因 Component中的shouldComponentUpdate()总是返回true ","date":"2021-10-02","objectID":"/reactexpand/:6:3","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"解决 办法1: 重写shouldComponentUpdate()方法 比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false 缺点是：如果state中有很多个状态，那么判断state是否修改需要判断多个状态，但是可以将state对象转为json字符串，判断字符串是否相等，就可以判断state中多个状态是否都进行了修改 PureComponent.js import React, { Component} from 'react' import './index.css' export default class A extends Component { state = {name:'张三'} /* 解决this.setState({})也能重新调用render的问题 */ // 是否能更新阀门能接收两个参数：要更新的props和要更新的state shouldComponentUpdate (nextProps,nextState) { // 如果props和state都没更新，则不能执行更新，即重新调用render。（A组件没有被传递props，所以只判断state是否更新） return !(this.state.name == nextState.name) } change = () =\u003e{ // 能正常更新并重新调用render this.setState({name:\"李四\"}) // 经处理后，没有改变state，则不能重新调用render // this.setState({}) } render() { // 验证父组件render有没有被调用 console.log(\"Parent-----render\"); const{name}=this.state return ( \u003cdiv className=\"parent\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e \u003cspan\u003e{name}\u003c/span\u003e \u003cbutton onClick={this.change}\u003e点我换名字\u003c/button\u003e {/* 如果子组件接收父组件传递的state，那么当父组件state改变时，会先调用父组件的render，再也会调用子组件的render。 */} {/* \u003cB name={name}/\u003e */} {/* 就算传递给子组件的name是固定的或者根本没传递数据给子组件，父组件的状态改变并导致render重新调用， 也会导致子组件的render被调用*/} \u003cB name=\"芜湖\"/\u003e \u003c/div\u003e ) } } class B extends Component { /* 解决无论子组件没有接收父组件的数据，或者子组件接收了，但是传的参数是固定不变的，在这种情况下，父组件状态改变重新调用render也会导致子组件的render被重新调用的问题 */ shouldComponentUpdate (nextProps,nextState) { // 如果props和state都没更新，则不能执行更新，即重新调用render。（B组件没有state，所以只判断props是否更新） return !(this.props.name == nextProps.name) } render() { // 验证子组件render有没有被调用 console.log(\"Son-----render\"); return ( \u003cdiv\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e \u003cspan\u003e{this.props.name}\u003c/span\u003e \u003c/div\u003e ) } } index.css .parent{ width:500px; background-color: antiquewhite; padding: 10px; } 办法2: 使用PureComponent PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true 注意: 只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false 不要直接修改state数据, 而是要产生新数据 项目中一般使用PureComponent来优化 PureComponent.js import React, { PureComponent} from 'react' import './index.css' export default class A extends PureComponent { state = {name:'张三', age:18, sex:\"男\"} change = () =\u003e{ /** * PureComponent判断状态是否改变时，是浅判断 * 如果state对象的地址没变，只是改变其内部的属性值，那么认为state状态对象没有改变，所以会更新状态但是不会重新调用render，应避免这种写法 * 如果是this.setState({name:\"李四\"})这样去更新状态，{name:\"李四\"}表示的是另一个对象，所以PureComponent监测到state对象的地址改变了，就会重新调用render */ // 能正常更新，但是不会重新调用render // const obj = this.state // obj.name = \"李四\" // this.setState(obj) // 能正常更新并重新调用render this.setState({name:\"李四\"}) // 什么都没改变，所以state状态对象没变，不会调用render // this.setState({}) } render() { // 验证父组件render有没有被调用 console.log(\"Parent-----render\"); const{name}=this.state return ( \u003cdiv className=\"parent\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e \u003cspan\u003e{name}\u003c/span\u003e \u003cbutton onClick={this.change}\u003e点我换名字\u003c/button\u003e {/* 如果子组件接收父组件传递的state，那么当父组件state改变时，会先调用父组件的render，再也会调用子组件的render。 */} {/* \u003cB name={name}/\u003e */} {/* 就算传递给子组件的name是固定的或者根本没传递数据给子组件，父组件的状态改变并导致render重新调用， 也会导致子组件的render被调用*/} \u003cB name=\"芜湖\"/\u003e \u003c/div\u003e ) } } class B extends PureComponent { render() { // 验证子组件render有没有被调用 console.log(\"Son-----render\"); return ( \u003cdiv\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e \u003cspan\u003e{this.props.name}\u003c/span\u003e \u003c/div\u003e ) } } index.css .parent{ width:500px; background-color: antiquewhite; padding: 10px; } ","date":"2021-10-02","objectID":"/reactexpand/:6:4","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"7. render props ","date":"2021-10-02","objectID":"/reactexpand/:7:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"如何向组件内部动态传入带内容的结构(标签)? Vue中: 使用slot技术, 也就是通过组件标签体传入结构 \u003cA\u003e\u003cB/\u003e\u003c/A\u003e React中: 使用children props: 通过组件标签体传入结构 使用render props: 通过组件标签属性传入结构,而且可以携带数据，一般用render函数属性 ","date":"2021-10-02","objectID":"/reactexpand/:7:1","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"普通的父子传数据 ordinaryProps.js import React, { Component } from 'react' import './index.css' export default class ordinaryProps extends Component { render() { return ( \u003cdiv className=\"father\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e \u003cA/\u003e \u003c/div\u003e ) } } class A extends Component { state = {name:\"张三\"} render() { return ( \u003cdiv className=\"son\"\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e \u003cB name={this.state.name}/\u003e \u003c/div\u003e ) } } class B extends Component { render() { return ( \u003cdiv className=\"grand\"\u003e \u003ch2\u003e我是孙组件\u003c/h2\u003e \u003cspan\u003e我接受到A组件的姓名为：{this.props.name}\u003c/span\u003e \u003c/div\u003e ) } } index.css .father{ width:500px; background-color: antiquewhite; } .son{ width:100%; background-color: aquamarine; } .grand{ width:100%; background-color: cadetblue; } ","date":"2021-10-02","objectID":"/reactexpand/:7:2","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"children props \u003cA\u003e \u003cB\u003exxxx\u003c/B\u003e \u003c/A\u003e {this.props.children} 问题: 如果B组件需要A组件内的数据, ==\u003e 做不到 ChildrenProps.js import React, { Component } from 'react' import './index.css' export default class ChildrenProps extends Component { render() { return ( \u003cdiv className=\"father\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e {/* 写在组件标签体的内容，都放在组件的this.props.children中 */} \u003cA\u003e \u003cB/\u003e \u003c/A\u003e \u003c/div\u003e ) } } class A extends Component { state = {name:\"张三\"} render() { return ( \u003cdiv className=\"son\"\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e {/* 存放着B组件 */} {this.props.children} \u003c/div\u003e ) } } class B extends Component { render() { return ( \u003cdiv className=\"grand\"\u003e \u003ch2\u003e我是孙组件\u003c/h2\u003e {/* 此时B组件接收不到A组件中的数据 */} \u003cspan\u003e我接受到A组件的姓名为：{this.props.name}\u003c/span\u003e \u003c/div\u003e ) } } index.css .father{ width:500px; background-color: antiquewhite; } .son{ width:100%; background-color: aquamarine; } .grand{ width:100%; background-color: cadetblue; } ","date":"2021-10-02","objectID":"/reactexpand/:7:3","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"render props \u003cA render={(data) =\u003e \u003cB data={data}/\u003e}\u003e\u003c/A\u003e A组件: {this.props.render(内部state数据)} B组件: 读取A组件传入的数据显示 {this.props.data} **好处是：**可以在A组件中一直预留一个位置，如果想显示谁，就相应的改变一下传递给A组件的render函数的返回值就行了，非常灵活的在A组件预留的位置中，即 {this.props.render(内部state数据)} 这里，想显示谁就显示谁，类似插槽 \u003cA render={(data) =\u003e }\u003e renderProps.js import React, { Component } from 'react' import './index.css' export default class renderProps extends Component { render() { return ( \u003cdiv className=\"father\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e {/* 使用renderProps，传递一个render函数给A组件，调用的返回值即为B组件。A组件可以在调用传递的render函数时，传递数据进去，该数据作为传给B组件的props，这样B组件就可以接收到A组件的数据了 */} \u003cA render={(name)=\u003e\u003cB name={name}/\u003e} /\u003e \u003c/div\u003e ) } } class A extends Component { state = {name:\"张三\"} render() { return ( \u003cdiv className=\"son\"\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e {/* 调用render函数，返回B组件，传递的参数作为props传递给B组件 */} {this.props.render(this.state.name)} \u003c/div\u003e ) } } class B extends Component { render() { return ( \u003cdiv className=\"grand\"\u003e \u003ch2\u003e我是孙组件\u003c/h2\u003e {/* 此时B组件就可以接收到A组件传递的name数据 */} \u003cspan\u003e我接受到A组件的姓名为：{this.props.name}\u003c/span\u003e \u003c/div\u003e ) } } index.css .father{ width:500px; background-color: antiquewhite; } .son{ width:100%; background-color: aquamarine; } .grand{ width:100%; background-color: cadetblue; } ","date":"2021-10-02","objectID":"/reactexpand/:7:4","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"8. 错误边界 理解： 错误边界(Error boundary)：用来捕获后代组件错误，渲染出备用页面，所以在显示容易出错的后代组件，先进行判断后代组件是否出错，如果出错就显示备用页面 特点： 只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误 使用方式： getDerivedStateFromError配合componentDidCatch // 生命周期函数，一旦后台组件报错，就会触发 static getDerivedStateFromError(error) { console.log(error); // 在render之前触发 // 返回新的state return { hasError: true, }; } componentDidCatch(error, info) { // 统计页面的错误。发送请求发送到后台去 console.log(error, info); } 例子： ErrorBoundary.js import React, { Component } from 'react' import './index.css' export default class ErrorBoundary extends Component { state = {hasError:false} // 生命周期函数，一旦后台组件报错，就会触发 static getDerivedStateFromError(error){ // 在render之前触发，能接收错误原因 console.log(error); // 返回新的state return {hasError:true} } // 只要有后代组件出错，就会调用这个钩子，作用是：统计错误次数，反馈给服务器，通知编码人员解决 componentDidCatch(error,info){ console.log(error); console.log(info); } render() { return ( \u003cdiv className=\"father\"\u003e \u003ch2\u003e我是父组件\u003c/h2\u003e {/* 当后代组件有错误时（A组件，即A组件的后代组件），显示备用页面，即不影响当前祖先组件的显示 */} {this.state.hasError?\u003ch2\u003e网络不好，请耐心等待.....\u003c/h2\u003e:\u003cA/\u003e} \u003c/div\u003e ) } } class A extends Component { // per是正确的数据：数组 // state = {per:[{id:1,name:\"张三\",age:18},{id:2,name:\"李四\",age:19},{id:3,name:\"王五\",age:17}]} // per是错误的数据：字符串，如果不对这个错误进行处理，会造成父组件也显示不了，整个页面都报错 state = {per:\"张三\"} render() { const {per} = this.state return ( \u003cdiv className=\"son\"\u003e \u003ch2\u003e我是子组件\u003c/h2\u003e \u003cul\u003e { per.map(item =\u003e \u003cli key={item.id}\u003e{item.name}-----{item.age}\u003c/li\u003e) } \u003c/ul\u003e \u003c/div\u003e ) } } index.css .father{ width:500px; background-color: antiquewhite; } .son{ width:100%; background-color: aquamarine; } ","date":"2021-10-02","objectID":"/reactexpand/:8:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"9. 组件通信方式总结 组件间的关系： 父子组件 兄弟组件（非嵌套组件） 祖孙组件（跨级组件） 几种通信方式： 1.props： (1).children props (2).render props 2.消息订阅-发布： pubs-sub、event等等 3.集中式管理： redux、dva等等 4.conText: 生产者-消费者模式 比较好的搭配方式： 父子组件：props 兄弟组件：消息订阅-发布、集中式管理 祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(开发用的少，封装插件用的多) ","date":"2021-10-02","objectID":"/reactexpand/:9:0","tags":["React"],"title":"ReactExpand","uri":"/reactexpand/"},{"categories":["React"],"content":"React","date":"2021-10-02","objectID":"/react/","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"React ","date":"2021-10-02","objectID":"/react/:0:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"注意事项: 使用脚手架创建react项目后，运行项目只认名为src目录，如果修改了src的目录文件名，那么运行时就找不到src目录。 react中内联样式的写法：style={{xxx:xxx}}，注意不是变量的要加引号 react中标签上的class用的是className react中不能直接渲染一个对象到页面，可以展示对象的某个属性 github搜索案例中的index.html引入了第三方样式bootstrap.css，所以如果运行其他例子的时候，需要讲那一行代码注释掉，否则会出现样式问题 修改react脚手架项目的src文件名前，记得先终止项目运行 ","date":"2021-10-02","objectID":"/react/:1:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.定义 是将数据渲染为html视图的开源js库 ","date":"2021-10-02","objectID":"/react/:2:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"2.特点 解释react的虚拟dom应用： 原来的纯js，每次更新数据，之前所有的数据全部报废，然后又重新加载一遍全部数据。比如原来往真实dom中存放100个人，后来又新加了一个人，相当于原来100个人全作废，又重新加载一遍这101个人，存入真实dom react，虚拟dom会进行新旧虚拟dom比较（比较的最小力度是节点），如果是相同的，那么在真实dom中直接采用，而不会重新加载一遍，不用所有数据都重来，解决js重排重绘问题 ","date":"2021-10-02","objectID":"/react/:3:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.上手 ","date":"2021-10-02","objectID":"/react/:4:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.1 依赖包 babel： 将ES6转为ES5 将jsx转为js（react写的是jsx） react.development： 核心库，一旦引入就有一个对象React react.dom.development 扩展库：支持react操作dom，一旦引入就有一个ReactDOM对象 ","date":"2021-10-02","objectID":"/react/:4:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.2 第一个项目 准备好一个容器 \u003cdiv id=\"test\"\u003e\u003c/div\u003e 引入库 顺序要求：核心库要比扩展库先引入 \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e 创建虚拟dom // 步骤三：创建虚拟dom // 此处一定不要写引号，因为不是字符串，jsx中标签和js可以混写 const VDOM=\u003ch1\u003ehello,react\u003c/h1\u003e 渲染虚拟dom到页面 render：是替换，不是追加，所以如果再渲染一个虚拟DOM，那么之前的会被替换 // 步骤四：渲染虚拟dom到页面中，第一个参数是虚拟dom，第二个参数是容器。由于react不支持选择器的写法，所以需要操作手动获取结点 ReactDOM.render(VDOM,document.getElementById('test')) ","date":"2021-10-02","objectID":"/react/:4:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.3 创建虚拟dom的两种方式 js创建 \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库，不需要babel库了，因为写的是js不是jsx，不需要转换 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是js --\u003e \u003cscript type=\"text/javascript\"\u003e // 步骤三：创建虚拟dom const VDOM=React.createElement('h1',{id:'title'},'hello,react,02') // 步骤四：渲染虚拟dom到页面中,第一个参数是虚拟dom，第二个参数是容器 ReactDOM.render(VDOM,document.getElementById('test')) \u003c/script\u003e \u003c/body\u003e jsx创建 \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e // 步骤三：创建虚拟dom // 此处一定不要写引号，因为不是字符串，如果要将html代码以格式化的方式写，就加一个() const VDOM=( \u003ch1\u003e \u003cspan id=\"test\"\u003ehello,react,02\u003c/span\u003e \u003c/h1\u003e ) // 步骤四：渲染虚拟dom到页面中,第一个参数是虚拟dom，第二个参数是容器 ReactDOM.render(VDOM,document.getElementById('test')) \u003c/script\u003e \u003c/body\u003e jsx是解决用原生js创建虚拟dom太繁琐的问题，jsx是js的语法糖，babel就是将jsx翻译成浏览器认识的js ","date":"2021-10-02","objectID":"/react/:4:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.4 什么是虚拟dom \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003cdiv id=\"demo\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e // 步骤三：创建虚拟dom // 此处一定不要写引号，因为不是字符串 const VDOM=\u003ch1\u003ehello,react\u003c/h1\u003e // 步骤四：渲染虚拟dom到页面中,第一个参数是虚拟dom，第二个参数是容器 ReactDOM.render(VDOM,document.getElementById('test')) //什么是vdom和tdom const TDOM=document.getElementById('demo') console.log('VDOM',VDOM) console.log(\"TDOM\",TDOM) \u003c/script\u003e ","date":"2021-10-02","objectID":"/react/:4:4","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.5 jsx xml和json写法 jsx ","date":"2021-10-02","objectID":"/react/:4:5","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.6 jsx语法规则 定义虚拟dom时不要加引号，直接写html标签 如果标签中嵌套js表达式（不是js语句、代码），需要用{}引起来 js语句（代码）：if(){}、for(){}、switch(){case:} js表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方，如：a、a+b、fun(1)、arr.map()。包括function test (){}也算表达式，因为用const a=function test (){}返回的就是一个函数，也有返回值。即表达式的结果一定是一个值 样式的类名不要用class，而用className。因为ES6中：class是关键字（外部样式中） 内联样式：需要用style={{key:value,key:value}}的形式去写 外面的大括号表示里面写的是js，里面的大括号表示写的是一个对象 key需要遵守驼峰原则，比如js中的font-size，在jsx中就是fontSize。 value要用‘ ’引起来，因为不是一个变量 虚拟DOM必须只有一个根标签 标签必须闭合 标签首字母： 若小写字母开头，则将改标签转为html中同名元素，若html中无同名元素，就报错 若是大写字母开头，react则去渲染对应的组件，若组件没有定义，则报错 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003ejsx语法规则\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003cstyle\u003e .hhh{background:peru;} \u003c/style\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e const id=\"tESt\" const child=\"HeLlo,rEacT,02\" // 步骤三：创建虚拟dom // 此处一定不要写引号，因为不是字符串，如果要将html代码格式化，就加一个() const VDOM=( \u003cdiv\u003e \u003ch1\u003e \u003cspan className=\"hhh\" style={{fontSize:'30px',color:'white'}} id={id.toLowerCase()}\u003e{child.toLowerCase()}\u003c/span\u003e \u003c/h1\u003e \u003cinput type=\"text\" /\u003e \u003c/div\u003e ) // 步骤四：渲染虚拟dom到页面中,第一个参数是虚拟dom，第二个参数是容器 ReactDOM.render(VDOM,document.getElementById('test')) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:4:6","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.7 jsx小练习（遍历） 注意： {}中只能写js表达式，即有返回值的。不能写for这种js语句 页面中遍历出来的每一个child结点都必须要有一个唯一key属性，如：如果单个单个写出的li，浏览器会自动给加上。但是如果是遍历出来的li，就必须显示为每个结点添加唯一key属性 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003eexample\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003cstyle\u003e .dd{ font-size:20px; } \u003c/style\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e const dt=\"前端js框架列表\" const dd=[\"vue\",\"react\",\"angular\"] const VDOM=( \u003cdiv\u003e \u003ch1\u003e{dt}\u003c/h1\u003e \u003cul\u003e { // 由于{}中只能是js表达式，所以这里用处理数组的方式遍历dd数组 dd.map((item,index)=\u003e{ // 给li设置key的值为每一个item的index，注意取值时加{} return \u003cli key={index}\u003e{item}\u003c/li\u003e; }) } \u003c/ul\u003e \u003c/div\u003e ) ReactDOM.render(VDOM,document.getElementById('test')) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:4:7","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.8 复习 1.类的基本知识 类中定义的方法都是放在了类的原型对象上，所有类实例共用的。但是类中构造器中的属性或方法，是实例自身的，不是公用的 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e类的基本知识\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e class Person { // 构造器方法 constructor(name,age){ // this指的是类的实例对象 this.name=name; this.age=age; } // 一般方法 speak(){ //通过Person实例调用的，那么this就指向Person实例 console.log('我叫：'+this.name+' 我的年龄是：'+this.age); } } class Student extends Person{ //要么不写构造器，那么会自动继承父类的构造器 constructor(name,age,grade){ //如果写了构造器，必须要用super()继承父类的构造器，并且super顺序一定要排在第一 super(name,age); this.grade=grade; // 这表示每一个实例对象中都有一个属性school，不需要传参，默认有 this.school='尚硅谷'; } // 重写父类中的speak方法 speak(){ console.log('我叫：'+this.name+' 我的年龄是：'+this.age+' 我读的年级是：'+this.grade); } //子类自己的方法 study(){ console.log('我很爱学习'); } } // 创建一个Person的实例对象 const p1=new Person('憨憨',12); console.log(p1); //输出的格式是：类名{属性：属性值，属性：属性值} p1.speak(); //p1对象调用类中的speak()方法，那么方法中的this指向的是p1对象 //创建一个Student的实例对象 const s1=new Student('小学生',18,'一年级'); console.log(s1); s1.speak(); s1.study(); // -------------------直接在类中写赋值语句----------------------------------- class Car{ constructor(){ // 表示往每一个对象中添加一个固定的属性wheel，且固定为4 this.wheel=4; } // 也表示往每一个对象中添加一个固定的属性a，且值为1。应用场景：当要往每一个对象中添加一个固定值的属性时，可以直接用这种赋值语句，不需要写构造函数 a=1 } const c1=new Car(); console.log(c1); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.原生js的事件绑定 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e原生js的事件绑定\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cbutton onclick=\"fun()\"\u003e按钮1\u003c/button\u003e \u003cscript type=\"text/javascript\"\u003e function fun(){ alert(\"按钮被点击了\"); } \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 3.类中的方法this 类中的方法，在js中默认开启了局部严格模式。所以类中的方法: 如果以对象实例调用的，那么this就指向对象实例。 如果是以函数形式调用的，那么this原本应该指向window，但是由于类中的方法默认开启了严格模式，严格模式不允许函数形式调用的方法中的this指向window，所以如果类中的方法是以函数形式调用的，this就是undefined \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e类中的方法this指向\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e class People{ constructor(name,age){ this.name=name; this.age=age; } speak(){ console.log(this); } } const p1=new People('哈哈',12); // 由对象实例调用的speak()方法，那么speak()方法中的this指向类实例对象 p1.speak(); // 将p1对象的speak方法赋值给x，那么x()就表示以函数的方式调用的，那么this就指向window // 但是js默认在类中的方法中开启局部严格模式，严格模式是不允许函数形式调用的方法中的this指向window，所以这里的this是undefined const x=p1.speak; x(); function test1() { console.log(this); } // js中的函数没有开启严格模式，所以这里的this指向的是window test1(); function test2() { // 手动开启严格模式 'use strict' console.log(this); } // 由于严格模式中不允许函数形式调用的方法中的this指向window，所以这里的this是undefined test2(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 4.函数的bind方法 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e函数的bind方法\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e function demo() { console.log(this); } // 非严格模式下，函数调用的方法中的this指向window demo(); // 意思是：调用demo函数的bind方法，返回一个新函数，并且指定这个新函数的this指向的是{a:1,b:2}这个对象（函数体还是跟demo一样，但是this 指向不一样了） const a=demo.bind({a:1,b:2}); // 调用这个新函数 a(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ５.展开运算符 展开数组：…数组 连接数组：[…数组1,…数组2] 函数传参，批量接收参数，将所有参数封装在一个数组中：function(…参数){} 以字面量形式复制对象：{…对象} \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e展开运算符\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e // 1.展开运算符展开数组 const arr1=[1,2,3]; console.log(...arr1); // 2.展开运算符可用于连接两个数组 const arr2=[4,5,6]; const arr3=[...arr1,...arr2]; console.","date":"2021-10-02","objectID":"/react/:4:8","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.8 模块与组件 模块： 组件： 模块化： 组件化： 1.函数式组件 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e函数式组件\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e // 创建函数式组件 // 注意这里的函数名首字母必须大写，因为组件名必须是首字母大写的，如果是小写的就会被当成标签，去html库中查找。 function Demo(){ console.log(this); //这里的this为undefined，不是指向window，因为babel解析代码会转换为严格模式，严格模式是不允许自定义函数中的this指向window的 return \u003ch2\u003e我是函数定义的组件\u003c/h2\u003e } // 渲染组件到页面ReactDOM.render(组件标签，容器)，注意：这里的标签记得闭合 ReactDOM.render(\u003cDemo/\u003e,document.getElementById(\"test\")) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.类式组件 要求： 必须继承React.Component类 类中必须写render(){return xxx} 不要求写构造函数 知识点： 用类定义组件中的render(){}方法是放在改类的原型对象中的，供实例使用。 类中的this指的是组件实例对象，即用类定义的组件中，类的实例对象 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e类式组件\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e // 类定义组件必须继承React.Component,而且要写render(){return xxx} class MyComponent extends React.Component{ // render是放在MyComponent的原型对象上，供实例使用 render(){ // 这里的this指的是组件实例对象，即用类定义的组件中，类的实例对象 console.log(this); return \u003ch2\u003e我是类定义的组件（一般用于复杂组件）\u003c/h2\u003e } } // 将组件渲染到容器中 ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById('test')); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:4:9","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.9 组件实例的三大核心属性 3.9.1 state 组件的数据存放在状态里，状态的改变驱动着页面的改变。是由组件实例对象生成的，因为state存放在类中的this对象里，而this表示的是组件实例对象 组件就是一个“状态机”，通过更新组件的state来更新对应的页面显示（重新渲染组件） 1.初始化state 初始化state要求： 实例中要用到state属性，所以必须要写构造函数初始化state属性 state值必须是一个对象或者为null \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003estate状态\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e class Weather extends React.Component{ // 实例中要用到state属性，所以必须要写构造函数初始化state属性 constructor(props){ // 只要继承了某个类，并且写了构造函数，就必须要写super() super(props); // state必须是一个对象，或者为null this.state={'isHot':true}; } render(){ return \u003ch2\u003e今天天气真{this.state.isHot?'炎热':'寒冷'}\u003c/h2\u003e; } } // 将组件渲染到页面中 ReactDOM.render(\u003cWeather/\u003e,document.getElementById('test')); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.react事件绑定 事件绑定要求： react中的onxxx事件，都必须用驼峰命名。如原生的js中的onclick，在react中就得用onClick 事件值只需要函数名，且必须为函数，而不是一个字符串，所以要用{}取 事件值中不要加()，函数名()：表示调用函数后的返回值 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003estate状态\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e class Weather extends React.Component{ // 实例中要用到state属性，所以必须要写构造函数初始化state属性 constructor(props){ // 只要继承了某个类，并且写了构造函数，就必须要写super() super(props); // state必须是一个对象，或者为null this.state={'isHot':true}; } render(){ // 1.注意这里的事件名要改为驼峰。2.事件值只需要函数名，且必须为函数，而不是一个字符串，所以要用{}取。3.事件值中不要加()，函数名()：表示调用函数后的返回值 return \u003ch2 onClick={demo}\u003e今天天气真{this.state.isHot?'炎热':'寒冷'}\u003c/h2\u003e; } } function demo() { console.log(\"按钮被点击\"); } // 将组件渲染到页面中 ReactDOM.render(\u003cWeather/\u003e,document.getElementById('test')); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 3.类组件中方法中的this babel解析，也会开启严格模式，所以由函数形式调用的方法中的this都不允许指向window，都为undefined js中类中自定义方法中也会默认开启局部严格模式，所以由函数形式调用的方法中的this，就指向undefined。但是如果由实例对象调用的方法中的this，就指向对象实例 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e类方法中的this\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 步骤一：创建一个容器 --\u003e \u003cdiv id=\"test\"\u003e\u003c/div\u003e \u003c!-- 步骤二：引入库 --\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 表示写的是jsx，用babel转换 --\u003e \u003cscript type=\"text/babel\"\u003e class Weather extends React.Component{ // constructor中的this一定是指向实例对象的 // 实例中要用到state属性，所以必须要写构造函数初始化state属性 constructor(props){ // 只要继承了某个类，并且写了构造函数，就必须要写super() super(props); // state必须是一个对象，或者为null this.state={'isHot':true}; } // render方法中的this指的是类实例对象，因为组件在渲染的时候，自动创建了类实例，并且用类实例调用了render方法 render(){ // 注意：3.如果这里写this.demo，意思是：将实例对象中的demo方法，作为onClick的回调函数去调用，不是由实例对象调用，而是点击这个结点后由react自动调用，属于函数调用，所以demo方法中的this为undefined return \u003ch2 onClick={this.demo}\u003e今天天气真{this.state.isHot?'炎热':'寒冷'}\u003c/h2\u003e; } // 将方法写在类里面 demo() { // 1.babel解析，也会开启严格模式，所以由函数形式调用的方法中的this都不允许指向window，都为undefined // 2.类中自定义方法中也会默认开启局部严格模式，所以由函数形式调用的方法中的this，就指向undefined。但是如果由实例对象调用的方法中的this，就指向对象实例 console.log(this); } } // 将组件渲染到页面中 // Weather类的实例对象是由react内部创建的 ReactDOM.render(\u003cWeather/\u003e,document.getElementById('test')); // 测试由对象实例调用类组件中的方法(这样写是不规范的，因为类组件的实例对象是由react创建的，不是由我们手动创建) const w1=new Weather(); w1.demo(); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 4.用bind解决类组件中方法中","date":"2021-10-02","objectID":"/react/:4:10","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.10 react中的事件绑定 ","date":"2021-10-02","objectID":"/react/:4:11","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.11 react中收集表单数据 1.非受控组件 表单中的数据现用现取。填完之后，从表单中取出来直接用的，为非受控组件 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e1_非受控组件\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ handleSubmit=(event)=\u003e{ // 阻止表单提交,即提交表单后，不进行页面刷新和跳转，做到让用户在本页面中就能处理表单提交的感觉 event.preventDefault(); // 获得并使用两个表单项结点的数据 alert(\"你的用户名为：\"+this.usernameNode.value+\"；你的密码为：\"+this.passwordNode.value); } render(){ return ( // onSubmit：表单提交时触发 \u003cform action=\"\" onSubmit={this.handleSubmit}\u003e \u003cinput ref={c=\u003ethis.usernameNode=c} type=\"text\" name=\"username\"/\u003e \u003cinput ref={c=\u003ethis.passwordNode=c} type=\"password\" name=\"password\"/\u003e \u003cbutton\u003e确定\u003c/button\u003e \u003c/form\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.受控组件 将表单中的数据存到state中，要用的时候，从state中取出来，叫做受控组件（变相的双向绑定） 使用react中的onChange事件（改变时触发）实时拿到表单中的数据，并将表单中的数据存到state中，用的时候直接从state中取即可（state建议最好先初始化，再setState） 建议使用受控组件，因为react官网建议少用ref \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_受控组件\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ // 初始化state state={ username:'', password:'' } // 用户名输入框值发生改变时触发，event.target表示事件源对象 saveName=(event)=\u003e{ this.setState({username:event.target.value}); } // 用户名输入框值发生改变时触发，event.target表示事件源对象 savePass=(event)=\u003e{ this.setState({password:event.target.value}); } // 表单提交的回调 handleSubmit=(event)=\u003e{ // 阻止表单提交,即提交表单后，不进行页面刷新和跳转，做到让用户在本页面中就能处理表单提交的感觉 event.preventDefault(); alert(\"你的用户名为：\"+this.state.username+\";你的密码为：\"+this.state.password); } render(){ return ( // onSubmit：表单提交时触发 \u003cform action=\"\" onSubmit={this.handleSubmit}\u003e \u003cinput onChange={this.saveName} type=\"text\" name=\"username\"/\u003e \u003cinput onChange={this.savePass} type=\"password\" name=\"password\"/\u003e \u003cbutton\u003e确定\u003c/button\u003e \u003c/form\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:4:12","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.12 高阶函数_函数柯里化 1.用函数柯里化 如果将一个函数调用后的返回值（函数的执行结果）作为某个事件触发的回调函数。那么在一进页面，这个函数就被执行一遍，得到一个返回值，将返回值作为事件触发的回调，那么后面无论怎么触发事件，这个函数都不会再被调用，因为事件的回调是这个函数的返回值 如果不仅将一个函数调用后的返回值作为事件回调，还给这函数传了参，那么这个函数的默认参数就不再是event事件源，而是你自己传的参数 函数调用后的返回值如果是一个回调函数，那么表示：一进页面，react就调用这个函数，得到返回值，将返回值作为事件触发的回调，这个返回值又恰好是一个回调函数，所以事件的回调还是一个回调函数。那么每次触发事件时，react都会调用那个返回值回调函数（但是不会再调用之前那个函数了） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_受控组件\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ // 初始化state state={ username:'', password:'' } // 绑定了事件的表单项的值发生改变时触发，参数为你自己传的参数（在一进页面，react就发现onChange事件的回调是一个函数的调用，那么react就直接先调用了这个函数，并且后面再触发onChange事件后，这个函数都不会再被调用。） saveForm=(formType)=\u003e{ // 该事件函数的返回值为一个回调函数，将这个回调函数作为onChange的触发事件，那么在每次触发事件时，react都会调用这个回调函数。这个回调函数被传参数，所以参数默认为event return (event)=\u003e{ // 在对象中读取一个变量，需要将变量用[]括起来 this.setState({[formType]:event.target.value}); }; } // 表单提交的回调 handleSubmit=(event)=\u003e{ event.preventDefault(); alert(\"你的用户名为：\"+this.state.username+\";你的密码为：\"+this.state.password); } render(){ return ( // 事件的回调应该传的是一个函数，每触发一次事件，函数就被react调用一次。但是这里是将一个函数的执行结果的返回值作为onChange的回调，那么结果是：在一进页面，react就发现onChange事件的回调是一个函数的调用，那么react就直接先调用了这个函数，并且后面再触发onChange事件后，这个函数都不会再被调用。这函数还传了实参，那么箭头函数默认的参数不再是事件源event，而是你自己传的那个参数 // 将这个函数调用的返回值设置为一个回调函数，在返回值回调函数中，写在触发onChange后你真正想做的事，返回值回调函数没有传参，所以参数默认就是event了，即事件源对象。每次触发事件，都会调用这个回调函数 \u003cform action=\"\" onSubmit={this.handleSubmit}\u003e \u003cinput onChange={this.saveForm('username')} type=\"text\" name=\"username\"/\u003e \u003cinput onChange={this.saveForm('password')} type=\"password\" name=\"password\"/\u003e \u003cbutton\u003e确定\u003c/button\u003e \u003c/form\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.不用函数柯里化 统一传参： 将箭头函数直接以内联的方式作为事件触发的回调函数，将事件源作为箭头函数的参数直接传入箭头函数中。在箭头函数中调用另一个箭头函数，并将得到的事件源event作为参数传入。那么另一个箭头函数也能拿到事件源对象了 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_不用函数柯里化\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ // 初始化state state={ username:'', password:'' } // 绑定了事件的表单项的值发生改变时触发，参数为你自己传的参数 // 此时的event，为事件触发回调时，拿到的事件源，再将event作为参数传到这里，所以这里的event也为事件源 saveForm=(formType,event)=\u003e{ this.setState({[formType]:event.target.value}); } // 表单提交的回调 handleSubmit=(event)=\u003e{ event.preventDefault(); alert(\"你的用户名为：\"+this.state.username+\";你的密码为：\"+this.state.password); } render(){ return ( // 直接将一个回调函数以内联的方式作为事件触发的回调，那么在每次触发事件时，都会执行这个回调函数，此回调函数的参数默认为当前事件源。 // 在这个回调函数体里是一另一个回调函数。那么事件每次触发时，react先会调用外侧的回调函数，外侧的回调函数被调用的时候，就执行函数体里面的回调函数，达到表单值一改变时，就将当前表单值存入state状态中 \u003cform action=\"\" onSubmit={this.handleSubmit}\u003e \u003cinput onChange={event =\u003e this.saveForm('username',event)} type=\"text\" name=\"username\"/\u003e \u003cinput onChange={event =\u003e this.saveForm('password',event) } type=\"password\" name=\"password\"/\u003e \u003cbutton\u003e确定\u003c/button\u003e \u003c/form\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:4:13","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.13 组件的生命周期（旧） 1.引出生命周期(错误示范) 做一个效果：1.点击按钮，页面中的组件就消失 2.一进页面（即组件刚挂载完后）：页面中的第一行文字，不透明度逐渐减小，等到透明时，自动变为1，再继续减小 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e1_引出生命周期\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ // 初始化state state={ // 最开始不透明度为1，后来慢慢减少 opacity: 1 } // ReactDOM中的unmountComponentAtNode方法表示卸载，将一个组件从页面中卸载 dead = () =\u003e { ReactDOM.unmountComponentAtNode(document.getElementById('test1')); } render(){ // 由于类中不能写函数，所以将函数放在render函数里面 // 这样带来的问题是：第一次页面渲染时，react创建类的实例对象并调用render方法时，调用了这个setInterval定时器，但是在定时器中，修改了state状态，只要状态改变，render就会被重新调用，那么随着render的重新调用，又开了一个定时器。以此类推，无限循环，开启了无数个定时器 setInterval(()=\u003e{ // 获得当前不透明度。这里要用let定义op变量，因为const定义的话，是不能修改变量值的 let op=this.state.opacity; op -= 0.1; // 将当前状态中的不透明度减去0.1 this.setState({opacity:op}); // 如果不透明度小于或等于0了（完全透明了），就将他重新设置为1 if(op \u003c= 0){ this.setState({opacity:1}); } },200); return ( // 注意内联样式的写法：以key，value的形式写属性 \u003cdiv\u003e \u003ch2 style={{opacity:this.state.opacity}}\u003e开始变得透明\u003c/h2\u003e \u003cbutton onClick={this.dead}\u003e点我全部消失\u003c/button\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果是：因为开了很多个定时器，导致越来越快。一直在新开定时器 2.引出生命周期 componentDidMount做到在组件挂载完毕后：页面中的那行文字就开始变透明，一直循环变。 一点击按钮，页面内的组件就消失 componentWillUnmount在组件消失之前，关闭定时器。因为如果在组件卸载后，定时器还开着话，定时器内又一直在改变state，就会报错。Can’t perform a React state update on an unmounted component.（在一个卸载的组件中改变状态） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_引出生命周期\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class MyComponent extends React.Component{ // 初始化state state={ // 最开始不透明度为1，后来慢慢减少 opacity: 1 } // ReactDOM中的unmountComponentAtNode方法表示卸载，将一个组件从页面中卸载 dead = () =\u003e { ReactDOM.unmountComponentAtNode(document.getElementById('test1')); } // 调用时机：组件卸载之前 componentWillUnmount(){ // 在卸载组件前，清除定时器，this.timer为定时器的id clearInterval(this.timer); } // 调用时机：组件挂载完毕后，即第一次渲染页面完毕后执行，且只执行这一次 componentDidMount(){ // 将定时器放在componentDidMount方法中，页面挂载完毕后，调用一次。那么做到了只开启一个定时器 this.timer = setInterval(()=\u003e{ // 获得当前不透明度。这里要用let定义op变量，因为const定义的话，是不能修改变量值的 let op=this.state.opacity; op -= 0.1; // 将当前状态中的不透明度减去0.1 this.setState({opacity:op}); // 如果不透明度小于或等于0了（完全透明了），就将他重新设置为1 if(op \u003c= 0){ this.setState({opacity:1}); } },200); } // 调用时机：1.页面第一次渲染 2.状态改变 render(){ return ( // 注意内联样式的写法：以key，value的形式写属性 \u003cdiv\u003e \u003ch2 style={{opacity:this.state.opacity}}\u003e开始变得透明\u003c/h2\u003e \u003cbutton onClick={this.dead}\u003e点我全部消失\u003c/button\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cMyComponent/\u003e,document.getElementById(\"test1\")); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 3.组件挂载流程 挂载时： construstor：构造器 componentWillMount：组件将要挂载 render：组件挂载 componentDidMount：组件挂载完毕 componentWillUnmount：组件卸载前（unmountComponentByNode(组件) 卸载组件的方法） \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e3_组件挂载流程\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class Count extends React.Component{ // 由于要展示生命周期各个时间段，所以这里写构造器 // 第一阶段：Count----构造器 constructo","date":"2021-10-02","objectID":"/react/:4:14","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.14 组件的生命周期（新） 新的生命周期中：componentWillMount、componentWillReceiveProps、componentWillUpdate使用时都需要加上前缀UNSAFE_。 因为这三个钩子函数被人乱用，可能在React的未来版本造成不安全的隐患。所以要使用，必须加上前缀才能使用，目前的版本中如果不加前缀，会有警告，未来的React版本，可能会直接报废弃的错，不能不加前缀使用 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e1_新旧区别\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class Count extends React.Component{ constructor(props){ console.log(\"构造器\"); super(props); this.state={count:0}; } dead = () =\u003e { ReactDOM.unmountComponentAtNode(document.getElementById('test1')); } add = () =\u003e { this.setState({count:this.state.count+1}); } force = () =\u003e{ this.forceUpdate(); } UNSAFE_componentWillMount(){ console.log(\"Count————组件将要挂载\"); } componentDidMount(){ console.log(\"Count————组件刚挂载完毕\"); } componentWillUnmount(){ console.log(\"Count————组件卸载之前\"); } // 第一阶段：组件是否能更新的阀门 shouldComponentUpdate(){ // 返回true才能更新组件 console.log(\"Count————组件是否能更新？\"); return true; } // 第二阶段：组件更新前 UNSAFE_componentWillUpdate(){ console.log(\"Count————组件更新前\"); } // 第四阶段：组件更新完毕 componentDidUpdate(){ console.log(\"Count————组件更新完毕\"); } render(){ console.log(\"Count————组件挂载/更新\"); return ( \u003cdiv\u003e \u003cbutton onClick={this.dead}\u003e卸载组件\u003c/button\u003e \u003cbutton onClick={this.add}\u003e点我+1\u003c/button\u003e \u003cbutton onClick={this.force}\u003e不修改状态，强制更新组件\u003c/button\u003e \u003c/div\u003e ) } } class Father extends React.Component{ state={car:'奥迪'} changeCar = () =\u003e{ this.setState({car:'奔驰'}) } render(){ return ( \u003cdiv\u003e \u003ch2\u003e我是Father组件\u003c/h2\u003e \u003cbutton onClick={this.changeCar}\u003e点我换车\u003c/button\u003e \u003cSon car={this.state.car}/\u003e \u003c/div\u003e ) } } class Son extends React.Component{ // 第一阶段：组件将要接收到props参数钩子，此钩子可以接收参数props。但是此钩子有一个坑：第一次接收的不算，即第一次接收props参数，此函数不调用，必须得接收新的props参数才开始调用。 UNSAFE_componentWillReceiveProps(props){ console.log(\"组件将要接收到props参数\"); console.log(props); } // 第二阶段：组件是否能更新的阀门 shouldComponentUpdate(){ // 返回true才能更新组件 console.log(\"组件是否能更新？\"); return true; } // 第三阶段：组件更新前 UNSAFE_componentWillUpdate(){ console.log(\"组件更新前\"); } // 第五阶段：组件更新完毕 componentDidUpdate(){ console.log(\"组件更新完毕\"); } // 第四阶段：渲染组件/更新组件 render(){ console.log(\"渲染/更新\"); // 接收到的car参数封装到了this.props对象中，直接拿取 return ( \u003cdiv\u003e \u003ch2\u003e我是Son组件,我接收到的车是：{this.props.car}\u003c/h2\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cCount/\u003e,document.getElementById('test1')); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 就不会报错 1.getDerivedStateFromProps 从props中得到衍生状态。意思是： 首先该函数可以接收props参数，也能接收state参数，但是这个state参数是指当前state 返回值只能是null和状态对象 如果该函数的返回参数是null，那么不影响state 如果函数返回值是一个状态对象，即跟状态中的属性有关的对象，比如{name:‘憨憨’}，或者直接返回props对象，那么相当于将返回的这个对象作为state的初始值，并且不能通过setState修改状态了，**因为setState和forceState也会触发getDerivedStateFromProps方法，所以用过setState修改state后，又触发getDerivedStateFromProps，那么就又将state值更新为props了，所以本质上用setState修改相当于没改。**此后的state改变完全取决于返回的这个对象。 getDerivedStateFromProps必须为一个静态函数 应用场景：state的值完全取决于props时，即接收props参数，并且返回值也为props时 比如：之前的点击按钮+1，是通过setState实现的，但是如果调用了这个函数，且返回值不为null \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_getDerivedStateFromProps\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/babel.min.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/babel\"\u003e class Count extends React.Component{ constructor(props){ console.log(\"constructor————构造器\"); super(props); this.state={count:0}; } add = () =\u003e { this.setState({count:this.state.count+1}); } // 记得getDerivedStateFromProps必须为一个静态函数 static getDerivedStateFromProps(props,state){ // 接收props console.log(props); // 这里是当前state console.log(state);","date":"2021-10-02","objectID":"/react/:4:15","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"4.总结 常用：跟旧版本的一样 render(){} componentDIdMount(){} 初始化的事情 开启定时器 发送网络请求 订阅消息 componentWillUnmount(){} 收尾的事情 关闭定时器 取消订阅 ","date":"2021-10-02","objectID":"/react/:4:16","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.15 Dom的ditting算法 1.引出ditting 页面开始： 1.生成虚拟DOM 2.赋给真实DOM，渲染到页面 3.更新状态 4.生成新的虚拟DOM 5.将新的虚拟DOM中节点的key与旧的虚拟DOM中节点的key比较： 1.key不同：将新虚拟DOM中的节点添加到真实DOM中 2.key相同： (1)如果新虚拟DOM中的内容为文本，则直接进行替换 (2)如果相同的key对应的节点内容也相同，那么就直接采用真实DOM中的这个节点 (3)如果相同的key对应的节点的内容不同，那么就将新的虚拟DOM中的这个节点覆盖真实DOM中的这个节点 (4)如果相同的key中存在子节点，那么子节点则继续进行如上规则的判断 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e1_引出ditting\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 页面开始： 1.生成虚拟DOM 2.赋给真实DOM，渲染到页面 3.更新状态 4.生成新的虚拟DOM 5.将新的虚拟DOM中节点的key与旧的虚拟DOM中节点的key比较： 1.key不同：将新虚拟DOM中的节点添加到真实DOM中 2.key相同： (1)如果新虚拟DOM中的内容为文本，则直接进行替换 (2)如果相同的key对应的节点内容也相同，那么就直接采用真实DOM中的这个节点 (3)如果相同的key对应的节点的内容不同，那么就将新的虚拟DOM中的这个节点覆盖真实DOM中的这个节点 (4)如果相同的key中存在子节点，那么子节点则继续进行如上规则的判断 --\u003e \u003cscript type=\"text/babel\"\u003e class Showdate extends React.Component{ state={currentDate:new Date().toLocaleString()}; componentDidMount(){ // 每一秒钟，更新状态为当前时间 setInterval(() =\u003e { this.setState({currentDate:new Date().toLocaleString()}); }, 1000); } render(){ return ( // 状态的改变，会重新生成一个新的虚拟DOM，这时再将新的虚拟DOM中节点的key与旧的虚拟DOM中节点的key作比较。 // 1.key相同：（1）如果相同的key对应的节点内容也相同，那么就直接采用真实DOM中的这个节点 (2)如果相同的key对应的节点的内容不用，那么就将新的虚拟DOM中的这个节点渲染到真实DOM中 // 2.key不同：直接将新的虚拟DOM中的这个节点渲染到真实DOM中 // 下面外层中的input节点和h1节点，包括span中的input节点，都是直接采用的真实DOM中的，因为每一次状态更新都没影响到这两个节点的内容，所以新旧虚拟DOM中，这两个节点key值相同，且内容相同，不用重新渲染到真实DOM，直接采用真实DOM中的这两个节点 // 而span节点中除了input子节点之外的文本节点部分，就直接用新虚拟DOM覆盖真实DOM，{this.state.currentDate}由于内容不一样，所以也是每次都更新真实DOM \u003cdiv\u003e \u003cinput type=\"text\"/\u003e \u003ch1\u003e哈哈哈\u003c/h1\u003e \u003cspan\u003e 当前时间为：{this.state.currentDate} \u003cinput type=\"text\"/\u003e \u003c/span\u003e \u003c/div\u003e ) } } ReactDOM.render(\u003cShowdate/\u003e,document.getElementById('test1')); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 2.key的作用(1) 页面开始： 1.生成虚拟DOM 2.赋给真实DOM，渲染到页面 3.更新状态 4.生成新的虚拟DOM 5.将新的虚拟DOM中节点的key与旧的虚拟DOM中节点的key比较： 1.key不同：先将新虚拟DOM中的节点添加到真实DOM中，再将旧虚拟DOM中存在，但新虚拟DOM中不存在的节点删除 2.key相同： (1)如果新虚拟DOM中的内容为文本，则直接进行替换 (2)如果相同的key对应的节点内容也相同，那么就直接采用真实DOM中的这个节点 (3)如果相同的key对应的节点的内容不同，那么就将新的虚拟DOM中的这个节点覆盖真实DOM中的这个节点 (4)如果相同的key中存在子节点，那么子节点则继续进行如上规则的判断 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e2_key的作用\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"test1\"\u003e\u003c/div\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/react-dom.development.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\" src=\"../js/新版本/babel.min.js\"\u003e\u003c/script\u003e \u003c!-- 页面开始： 1.生成虚拟DOM 2.赋给真实DOM，渲染到页面 3.更新状态 4.生成新的虚拟DOM 5.将新的虚拟DOM中节点的key与旧的虚拟DOM中节点的key比较： 1.key不同：先将新虚拟DOM中的节点添加到真实DOM中，再将旧虚拟DOM中存在，但新虚拟DOM中不存在的节点删除 2.key相同： (1)如果新虚拟DOM中的内容为文本，则直接进行替换 (2)如果相同的key对应的节点内容也相同，那么就直接采用真实DOM中的这个节点 (3)如果相同的key对应的节点的内容不同，那么就将新的虚拟DOM中的这个节点覆盖真实DOM中的这个节点 (4)如果相同的key中存在子节点，那么子节点则继续进行如上规则的判断 --\u003e \u003c!-- 页面开始：如果以index下标作为key的话 1.生成虚拟DOM \u003cli key={0}\u003e张三---------18\u003c/li\u003e \u003cli key={1}\u003e李四---------19\u003c/li\u003e 2.赋给真实DOM，渲染到页面 3.点击按钮更新状态 4.生成新的虚拟DOM \u003cli key={0}\u003e王五---------20\u003c/li\u003e \u003cli key={1}\u003e张三---------18\u003c/li\u003e \u003cli key={2}\u003e李四---------19\u003c/li\u003e 5.比较新虚拟DOM和旧虚拟DOM key为0：旧虚拟DOM：张三---------18，新虚拟DOM：王五---------20。内容不一样，所以将新虚拟DOM的 王五---------20 添加进真实DOM并渲染到页面 key为1：旧虚拟DOM：李四---------19，新虚拟DOM：张三---------18。内容不一样，所以将新虚拟DOM的 张三---------18 添加进真实DOM并渲染到页面 key为2：旧虚拟DOM中无，所以直接将新虚拟DOM的 李四---------19 添加进真实DOM并渲染到页面 发现问题：张三---------18、李四---------19 在之前已经添加进真实DOM了，却因为key的值为index下标，由于在数组中的顺序改变了，导致index下标也 发生大变化，所以影响到key发生变化，导致 张三---------18 、李四---------19 因为key值与之前不用，被当作内容不一样的节点，又重新再一次添加进真实DOM --\u003e \u003c!-- 页面开始：如果以id(每条数据的唯一标识)作为key的话 1.生成虚拟DOM \u003cli key={1}\u003e张三---------18\u003c/li\u003e \u003cli key={2}\u003e李四---------19\u003c/li\u003e 2.赋给真实DOM，渲染到页面 3.点击按钮更新状态 4.生成新的虚拟DOM \u003cli key={3}\u003e王五---------20\u003c/li\u003e \u003cli key={1}\u003e张三---------18\u003c/li\u003e","date":"2021-10-02","objectID":"/react/:4:17","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"4.初始化react脚手架 ","date":"2021-10-02","objectID":"/react/:5:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.什么叫脚手架 ","date":"2021-10-02","objectID":"/react/:5:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"2.初始化脚手架 使用脚手架创建react项目成功后： 再打开项目文件，启动项目 ","date":"2021-10-02","objectID":"/react/:5:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"5.react脚手架项目结构 public：静态资源文件夹 react和vue都是spa单页面程序，只有一个主页面，所有的子页面都包含在这里面，整个项目只有一个html文件 应用加壳：如果你写了一个web应用，但是想让它在手机上也能运行。一般的做法是，让专门的移动端人员用移动端的语法重新写出这个应用。但是应用加壳的意思是：在这个web应用外层加一层安卓壳（或IOS壳）。让它在移动端看上去运行的是一个移动端的应用，但实际上内部的代码是一个web应用 index.html中 src：源码文件夹 App.css：作用于App.js的外部样式 App.js：实际上是定义了一个函数式组件，函数名叫做App，该组件被默认暴露，在index.js中被渲染到index.html中的div节点中。（注意：index.js只把这一个组件渲染到index.html中，其他的组件全部为App.js的子组件） App.test.js：专门测试App.js的测试文件 index.css：作用于index.js的样式，可以在index.js中引入，也可以在index.html中引入 index.js：入口文件 引入React 引入ReactDOM 引入样式 引入组件（.js和.jsx文件的后缀可以省略） 引入介绍页面性能的文件 渲染App.js组件到index.html的div节点中 reportWebVitals.js：用于介绍页面性能的，靠的是web-vitals这个库 setupTests.js：用于做应用的整体测试的，组件测试 项目执行顺序： 一来就执行index.js，将App组件渲染到index.html页面 ","date":"2021-10-02","objectID":"/react/:6:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"6.分别暴露和默认暴露 默认暴露：直接暴露一整个组件，你可以在另一个页面先引入这个组件 import 组件别名 from 路径 ，然后可以用 const {组件里的东西}=组件 的形式从组件中获取东西，这里的{}表示结构化赋值。 分别暴露：暴露组件内的某个东西，比如方法、属性等等，引入： import {名字} from 路径 ,但是这里的{}不是结构化赋值，这里表示如果是获得分别暴露的东西，那么取的时候就需要加上{} 如果一个出现import 组件别名,{名字} from ‘路径’ 这种引入方式，则表示这个组件内有多种暴露方式 ","date":"2021-10-02","objectID":"/react/:7:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"7.一个简单的hello组件 react中区分组件js文件和普通js文件： 组件js文件的文件名中首字母大写 组件js文件其实可以命名为xxx.jsx，那么.jsx文件就代表组件js，.js文件就代表普通js文件 Hello.js子组件 // 引入默认暴露的React组件 和 分别暴露的React组件中的Component类 import React,{Component} from 'react'; // 引入样式 import './Hello.css'; // export default直接写在这里，简便 // 这里直接写的Component，是因为已经引入了Component，可以不用加React前缀 export default class Hello extends Component{ render(){ return ( \u003cdiv className=\"hello\"\u003e hello!!! \u003c/div\u003e ) } } Hello.css .hello{ background-color: aquamarine; } Wellcom.js子组件 // 引入默认暴露的React组件 和 分别暴露的React组件中的Component类 import React,{Component} from 'react'; // 引入样式 import './Wellcom.css'; // export default直接写在这里，简便 // 这里直接写的Component，是因为已经引入了Component，可以不用加React前缀 export default class Wellcom extends Component{ render(){ return ( \u003cdiv className='wellcom'\u003e Wellcom!!! \u003c/div\u003e ) } } Wellcom.css .wellcom{ background-color: rebeccapurple; } App.js主组件：包含所有子组件 // 引入React组件 import React from 'react'; // 引入Hello组件,react中引入时可以省略后缀.js或者是.jsx import Hello from './component/Hello/Hello' // 引入Wellcom组件 import Wellcom from './component/Wellcom/Wellcom' const {Component}=React // 这里可以直接写Component是因为用结构赋值将Component从React中取出来了 class App extends Component{ render(){ return ( // App.js中一般是引入子组件,而不是自己去写虚拟DOM结构 \u003cdiv\u003e \u003cHello/\u003e \u003cWellcom/\u003e \u003c/div\u003e ) } } // 默认暴露App组件 export default App; index.html：主页面 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e index.js入口：将App组件渲染到页面 // 引入React import React from 'react'; // 引入ReactDOM import ReactDOM from 'react-dom'; // 引入App组件，.js可以省略 import App from './App'; // 渲染App组件到index.html页面 ReactDOM.render(\u003cApp/\u003e,document.getElementById('root')); ","date":"2021-10-02","objectID":"/react/:8:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"8.样式模块化 真正项目开发中一般每个子组件对应的文件夹下的js和css都命名为index.js和index.css。 不管用不用index命名，如果每个组件内都没有与别的组件内的节点的className名发生重名的话，那就没有任何问题。但是如果存在某个组件内与另一个组件内的某个节点的className同名，那么会造成一个问题： 比如两个组件内都有一个className为hello的节点，并且两个组件对应的样式表都对这个节点进行了修改，都为.hello{}。那么最终子组件被引入到App主组件时，主组件采用的永远是后引入的子组件对应的重名样式 解决方法： 用less样式时，样式前面都会加上父节点的 .class名 这样就即使节点同名了也没事，因为父节点不一样 实现样式模块化： 给每个组件的css文件名从 文件名.css 修改为 文件名.module.css 引入的时候就可以把css当成一个模块来引入 那么组件中的节点的className名就为 xxx.title Hello/index.js // 引入默认暴露的React组件 和 分别暴露的React组件中的Component类 import React,{Component} from 'react'; // 引入模块的方式引入样式,hello为自定义名字 import hello from './index.module.css'; // export default直接写在这里，简便 // 这里直接写的Component，是因为已经引入了Component，可以不用加React前缀 export default class Hello extends Component{ render(){ return ( // 这里就可以将hello当成一个模块,直接拿取模块里面的值 \u003cdiv className={hello.title}\u003e hello!!! \u003c/div\u003e ) } } Wellcom/index.js // 引入默认暴露的React组件 和 分别暴露的React组件中的Component类 import React,{Component} from 'react'; // 引入模块的方式引入样式,hello为自定义名字 import wellcom from './index.module.css'; // export default直接写在这里，简便 // 这里直接写的Component，是因为已经引入了Component，可以不用加React前缀 export default class Wellcom extends Component{ render(){ return ( // 这里就可以将hello当成一个模块,直接拿取模块里面的值 \u003cdiv className={wellcom.title}\u003e Wellcom!!! \u003c/div\u003e ) } } App.js // 引入React组件 import React from 'react'; // 引入Hello组件,react中引入时可以省略后缀.js或者是.jsx import Hello from './component/Hello' // 引入Wellcom组件 import Wellcom from './component/Wellcom' const {Component}=React // 这里可以直接写Component是因为用结构赋值将Component从React中取出来了 class App extends Component{ render(){ return ( // App.js中一般是引入子组件,而不是自己去写虚拟DOM结构 \u003cdiv\u003e \u003cHello/\u003e \u003cWellcom/\u003e \u003c/div\u003e ) } } // 默认暴露App组件 export default App; ","date":"2021-10-02","objectID":"/react/:9:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"9. react插件及快捷键 安装后，在.js文件中： rcc+回车：快速生成类式组件模板 rfc+回车：快速生成函数式组件模板 ","date":"2021-10-02","objectID":"/react/:10:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"9.功能界面的组件化编码流程 ","date":"2021-10-02","objectID":"/react/:11:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"10.TodoList案例 效果： 输入任务名称，点击回车，自动将此任务添加进下面列表 鼠标放在列表中的某项上，某项就显示高亮，并且该行右侧出现删除按钮 可以选中要清楚的任务，再点击清除已完成任务按钮，即可从列表中消失并且在左下角的有实时数字显示完成的条数 ","date":"2021-10-02","objectID":"/react/:12:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.静态组件 拆分组件： 实现静态页面（不包含事件） 注意事项： 如果组件中有使用子组件，那么记得导入 记得在主组件App.js中导入所有子组件 记得在每个子组件中导入css样式 记得将主组件渲染到主页面 记得className 记得style={{xxx:xxx}} ","date":"2021-10-02","objectID":"/react/:12:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"2.动态添加列表 所有的东西应该都放在父组件App.js中，因为方便传递给不同的子组件，也能暂时避免兄弟组件之间的数据传递。 注意事项： 遍历出来的组件和标签都要加上key 所有东西都放在父组件的state中，通过prop的方式传递给子组件。 ","date":"2021-10-02","objectID":"/react/:12:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.添加todo 注意事项： 父组件给子组件传数据：props 子组件给父组件传数据： 父组件给子组件通过props传一个函数，子组件调用函数时用实参给父组件传数据 生成全世界唯一的字符串的一个工具叫做：nanoid 先npm install nanoid 再在用到的页面导入import {nanoid} from ’nanoid’，因为它里面用分别暴露的形式暴露了一个nanoid函数 使用时调用nanoid()，即可得到一个全球唯一的字符串 ","date":"2021-10-02","objectID":"/react/:12:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"4.鼠标移入效果 注意事项： 触发事件后执行的，必须是一个函数，如果在赋值的时候，函数带了参数的话，那么它就是一个函数调用，而不是一个函数。解决方法是：让此函数的返回值为一个回调函数 内联style中第一个花括号表示里面写的是js代码，第二个花括号表示这是一个对象 ","date":"2021-10-02","objectID":"/react/:12:4","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"5.勾选时改变状态中的对象属性值 注意事项： 如果是孙组件要给祖组件传数据，那么祖组件需要传一个函数给父组件，父组件再传一个函数给子组件，即要一级一级的传递 可以使用{…对象，属性：新属性值}的方式修改对象中某一属性的属性值，并直接返回一个新对象 type为checkbox的input标签，得到它是否被勾选的属性是checked，checked为true，则被勾选，否则没被勾选 ","date":"2021-10-02","objectID":"/react/:12:5","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"6.对props限制 注意事项： 先install i prop-types 记得导入包：import PropTypes from ‘prop-types’ //引入能对props进行限制的包 记得是在接收props参数的类中进行限制 ","date":"2021-10-02","objectID":"/react/:12:6","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"7.删除一个todo 注意事项： 将删除的id传给App组件，在App组件中用filter进行删除 删除前用confirm进行确认，注意：在react中confirm前要加window.，即window.confirm ","date":"2021-10-02","objectID":"/react/:12:7","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"8.实现底部功能 1.实现底部计数功能： 注意事项： 用reduce对数组进行条件计数，切记：二目运算符中使用三目运算符，是需要加括号的。赋值语句中使用三目运算符，不需要加括号 2.实现全选框选中时，所有选项全被选中。取消时：所有选择框全部被取消 通过map修改done的值，判断checked，当全选框的checked属性值为true时，修改所有选项的done为true，当全选框的checked属性值为false时，修改所有选项的done为false 状态在哪，修改状态的方法就在哪里，所以修改状态应该放在App组件 3.实现当所有选框都被选中时，全选框被选中，取消一个时，全选框被取消 通过设置标签上checked属性值，判断如果全部完成的数量===所有事项的数量，则将全选框的checked属性设置为true ","date":"2021-10-02","objectID":"/react/:12:8","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"9.todolist总结 ","date":"2021-10-02","objectID":"/react/:12:9","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"11.脚手架配置代理 ","date":"2021-10-02","objectID":"/react/:13:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.理解 ","date":"2021-10-02","objectID":"/react/:13:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"2.例子 先安装axios包，再导入包 有一个小型的服务器，能返回固定学生数据，当服务器启动后，网址是：http://localhost:5000/students 现写一个页面：点击按钮，则请求到http://localhost:5000/students这个页面 结果：报错，因为当前页面所在网址是http://localhost:3000，不能跨域到http://localhost:5000/students。请求发送成功了，但是不能返回数据，因为客户端有Ajax引擎，Ajax引擎拒绝接收跟客户端端口不一致的服务器数据 解决：配置代理 中间代理的端口号要和客户端一样，中间代理能接收不同端口号的服务器数据，因为它里面没有Ajax请求，它是由请求转发实现的 ","date":"2021-10-02","objectID":"/react/:13:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.配置代理 方法一： 在前端的package.json加一个\"proxy\":“代理服务器地址”，表示：所有发给3000的请求，全部转发给了5000。注意：修改了配置文件后，必须重启一下项目 设置一下请求的地址，改为3000，因为中间代理的端口号要和客户端的一致 import React, { Component } from 'react' import Axios from 'axios' export default class App extends Component { getStudent=()=\u003e{ // 请求先发给中间代理，中间代理的端口号与客户端一致，由于在package.json中设置了proxy为5000，表示：所有发给3000的请求都会被转发到5000，所以这里发给中间代理3000的请求，又会被转发给5000 Axios.get('http://localhost:3000/students').then( response=\u003e{console.log(\"成功了\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.getStudent}\u003e点我获取学生信息\u003c/button\u003e \u003c/div\u003e ) } } 启动服务器，运行程序，前端即可请求到端口不一致的服务器的数据 但是并不是所有的3000请求都会被转发到5000，如果是3000中存在的资源，就不会被转发到5000，直接在3000中拿取。3000没有的资源，就会被转发到5000 getStudent=()=\u003e{ // 请求先发给中间代理，中间代理的端口号与客户端一致，由于在package.json中设置了proxy为5000，表示：所有发给3000的请求都会被转发到5000，所以这里发给中间代理3000的请求，又会被转发给5000 Axios.get('http://localhost:3000/students').then( response=\u003e{console.log(\"成功了\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) // 设置proxy为5000，并不是代表所有请求都被转发到了5000，如果是3000中存在的资源，就不会被转发到5000，直接在3000中拿取 // 比如这里的index.html是3000中存在的，那么就不会去到服务器5000拿 Axios.get('http://localhost:3000/index.html').then( response=\u003e{console.log(\"成功了\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) } 方法一的局限：3000没有的资源只会找5000要，只能转发到一个服务器 方法二： 建一个名为setupProxy.js的配置文件，文件名不能改，react会自动识别这个配置文件。配置文件中不能用ES6的语法，而要用CIS的语法去写，因为setupProxy.js不是给前端运行的，react会识别这个配置文件，并将它加到webpack配置中，webpack中用的就是CJS语法 增加了文件后，一定要重启项目 setupProxy.js // 此包在安装react脚手架时就安装了 const proxy = require('http-proxy-middleware') module.exports = function(app){ /** proxy第一个参数：请求的前缀；第二个参数：转发详情 * 1.proxy：表示将带有某个前缀的请求转发到另一个网址 * 2.changeOrigin：控制服务器收到的请求头中Host字段的值，Host：标识着本次请求从哪里发出的 * 为false（默认）：Host值为真正发出请求的来源，此例中即为3000 * 为true：Host值为转发后的网址，此例中为5000或5001。最好改为true，因为避免服务器知道你实际上是3000发出的请求，就会对你有一些限制 * 3.pathRewrite：修改请求前缀 */ // 表示只要是3000，并且带了/api1前缀的请求，即前面有http://localhost:3000/api1的请求，就会被转发到http://localhost:5000/api1。这时我们需要去掉前缀，所以用pathRewrite去掉前缀。 // 所以只要有http://localhost:3000/api1的请求，就会被转发到http://localhost:5000 // 同理只要有http://localhost:3000/api2的请求，就会被转发到http://localhost:5001 app.use( proxy('/api1',{ target:'http://localhost:5000', changeOrigin:true, pathRewrite:{'^/api1':''} }), proxy('/api2',{ target:'http://localhost:5001', changeOrigin:true, pathRewrite:{'^/api2':''} }) ) } App.js import React, { Component } from 'react' import Axios from 'axios' export default class App extends Component { getStudent=()=\u003e{ // 如果3000中没有请求的这个资源，就会走/api1配置的这个代理：http://localhost:3000/api1前缀的请求被转发到http://localhost:5000 Axios.get('http://localhost:3000/api1/students').then( response=\u003e{console.log(\"成功了，学生为：\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) } getCar=()=\u003e{ // 如果3000中没有请求的这个资源，就会走/api2配置的这个代理：http://localhost:3000/api2前缀的请求被转发到http://localhost:5001 Axios.get('http://localhost:3000/api2/cars').then( response=\u003e{console.log(\"成功了，汽车为：\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) } render() { return ( \u003cdiv\u003e \u003cbutton onClick={this.getStudent}\u003e点我获取学生信息\u003c/button\u003e \u003cbutton onClick={this.getCar}\u003e点我获取汽车信息\u003c/button\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:13:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"12.github搜索案例 ","date":"2021-10-02","objectID":"/react/:14:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.静态组件 先将普通前端项目转化为react前端项目 再拆分组件，拆分的时候注意查看html中可以舍弃的标签在css中有没有给它设置样式 拆分时记得在主组件中引入子组件，并且将组件放在该渲染的位置 样式也要拆分，先将所有样式放在父组件的样式中，然后根据不同子组件将样式进行拆分 注意： 第三方样式库，如bootStrap.css最好放在public文件夹中，在public文件夹中建一个css文件夹，将第三方样式放在里面。放在public的样式应该被index.html文件引入。其他样式就放在src文件夹中（如果要运行其他项目，需要将index.html中引入bootStrap样式的代码注释掉） 注意修改class为className（vscode中ctrl+shift+l表示全选中文件中的出现的所有某个字段） 注意修改外部样式为style={{key,value}}形式 ","date":"2021-10-02","objectID":"/react/:14:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"2.axios发送请求 问题：如果向github服务器发送的请求次数多了，github就会禁止发送请求。 解决方法：设置一个中间服务器，端口号假设为5000，3000向5000发送请求，5000再向github服务器发送请求，请求的返回数据再返回给3000。5000请求github次数多了，github就会禁止5000再向它发送请求，但是在中间服务器5000中还设有另一个接口，就是返回模拟数据给3000。 所以如果5000向github发送请求，那么5000返回的就是真实数据，如果5000不能向github发送请求了，就直接返回模拟数据给3000 启动5000服务器 配置setupProxy // 此包在安装react脚手架时就安装了 const proxy = require('http-proxy-middleware') module.exports = function(app){ /** proxy第一个参数：请求的前缀；第二个参数：转发详情 * 1.proxy：表示将带有某个前缀的请求转发到另一个网址 * 2.changeOrigin：控制服务器收到的请求头中Host字段的值，Host：标识着本次请求从哪里发出的 * 为false（默认）：Host值为真正发出请求的来源，此例中即为3000 * 为true：Host值为转发后的网址，此例中为5000或5001。最好改为true，因为避免服务器知道你实际上是3000发出的请求，就会对你有一些限制 * 3.pathRewrite：修改请求前缀 */ // 表示只要是3000，并且带了/api1前缀的请求，即前面有http://localhost:3000/api1的请求，就会被转发到http://localhost:5000/api1。这时我们需要去掉前缀，所以用pathRewrite去掉前缀。 // 所以只要有http://localhost:3000/api1的请求，就会被转发到http://localhost:5000 // 同理只要有http://localhost:3000/api2的请求，就会被转发到http://localhost:5001 app.use( proxy('/api1',{ target:'http://localhost:5000', changeOrigin:true, pathRewrite:{'^/api1':''} }) ) } 发送请求 // 这里客户端为3000服务器为5000，而且5000服务器中没有解决跨域问题。所以需要设置代理，代理端口号为3000，所有发送给3000的请求都会被转发到5000 // 这里有一个简写的方法：如果当前客户端为3000，代码中可以省略主机名+3000，即省略http://localhost:3000 axios.get(`/api1/search/users?q=${keywords}`).then( response=\u003e{console.log(\"成功了\",response.data);}, error=\u003e{console.log(\"失败了\",error);} ) ","date":"2021-10-02","objectID":"/react/:14:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"3.展示数据 分析请求回来的数据： 由于数据是在Search组件中请求回来的，需要在List组件中展示，所以需要先把数据传给父组件App，再由父组件传给List组件。 ","date":"2021-10-02","objectID":"/react/:14:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"4.完善案例 效果： 一进页面，还没有搜索任何东西的时候，页面显示“欢迎使用，输入关键字点击搜索，即可获取github用户” 点击搜索后，在没返回数据之前，显示加载中 成功返回数据后，显示返回的数据 请求失败后，显示“请求失败” 实现： 不同时刻显示不同页面，由于状态的改变必会驱动页面改变，所以需要在状态中设置这四种情况对应的属性 在Search组件中根据不同时刻修改state属性的属性值，并传给App组件 App组件得到修改后的对象属性，进而setState，并将state对象传给List子组件进行条件展示 注意：react中不能直接渲染一个对象到页面，可以展示对象的某个属性 App.js import React, { Component } from 'react' import Search from './component/Search/index' import List from './component/List/index' export default class App extends Component { state={first:true, //是否第一次打开页面 loading:false, //是否正在加载中 error:'', //存储错误信息 people:[]}; //用户数据 // 点击查询按钮时，获取修改了值的属性对象，再更新状态中相应的属性 updateState=(stateObj)=\u003e{ this.setState(stateObj); } render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch updateState={this.updateState}/\u003e \u003cList {...this.state}/\u003e \u003c/div\u003e ) } } Search.js import React, { Component } from 'react' import axios from 'axios'; export default class Search extends Component { handleClick=()=\u003e{ // 获取用户的输入 // 连续结构赋值并给拿到的属性取别名 // 表示：从this中拿到inputElement对象的value属性，并给value属性取一个别名叫作keywords const {inputElement:{value:keywords}} = this // 发送网络请求 // 这里客户端和服务器的主机名和端口不一样，但能请求成功，是因为github服务器在后端用了cors加了一个特殊的响应头解决了跨域问题 // 在点击搜索按钮后，发送请求前，设置页面的first为false，loading设置为true this.props.updateState({first:false,loading:true}); // axios.get(`https://api.github.comdd/search/users?q=${keywords}`).then( // response=\u003e{console.log(\"成功了\",response.data);}, // error=\u003e{console.log(\"失败了\",error);} // ) // 这里客户端为3000服务器为5000，而且5000服务器中没有解决跨域问题。所以需要设置代理，代理端口号为3000，所有发送给3000的请求都会被转发到5000 // 这里有一个简写的方法：如果当前客户端为3000，代码中可以省略主机名+3000，即省略http://localhost:3000 axios.get(`/api1/search/users?q=${keywords}`).then( // 请求成功时将通知App更新状态 response=\u003e{this.props.updateState({people:response.data.items,loading:false})}, // 请求失败时将通知App更新状态 error=\u003e{this.props.updateState({error:error,loading:false})} ) } render() { return ( \u003csection className=\"jumbotron\"\u003e \u003ch3 className=\"jumbotron-heading\" \u003eSearch Github Users\u003c/h3\u003e \u003cdiv\u003e {/* 回调函数的形式定义ref，将input输入框结点赋值给实例对象中的inputElement属性 */} \u003cinput ref={currentCode=\u003ethis.inputElement=currentCode} type=\"text\" placeholder=\"enter the name you search\"/\u003e\u0026nbsp;\u003cbutton onClick={this.handleClick}\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/section\u003e ) } } List.js import { object } from 'prop-types' import React, { Component } from 'react' import './index.css' export default class List extends Component { render() { const {first,loading,error,people}=this.props; console.log(first,loading,error,people); return ( \u003cdiv className=\"row\"\u003e { // 因为在jsx中的大括号内只能写表达式，不能写if这种语句判断，所以选择用嵌套三元式来进行条件判断 // react中不能直接渲染一个对象到页面，可以展示对象的某个属性，所以显示error对象中的message属性 first?\u003ch2\u003e欢迎使用，请输入关键字进行搜索用户\u003c/h2\u003e: loading?\u003ch2\u003e加载中.........\u003c/h2\u003e: error?\u003ch2 style={{color:\"red\"}}\u003e错误信息:{error.message}\u003c/h2\u003e: people.map(item=\u003e{ return ( \u003cdiv className=\"card\" key={item.id}\u003e {/* href中如果设置了target=\"_blank\"，另开一个页面。但是需要和rel=\"noreferrer\"一起使用，否则会弹出警告 */} \u003ca rel=\"noreferrer\" href={item.html_url} target=\"_blank\"\u003e {/* img标签必须设置一个alt属性：表示当图片加载失败时显示的文字，否则会警告 */} \u003cimg alt=\"Avatar\" src={item.avatar_url} style={{width:'100px'}}/\u003e \u003c/a\u003e \u003cp className=\"card-text\"\u003e{item.login}\u003c/p\u003e \u003c/div\u003e ) }) } \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:14:4","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"13.消息订阅与发布 订阅步骤： 指定消息名 接收数据（包含消息名、数据） 发布步骤： 指定消息名 携带数据 在需要接收数据的组件中订阅消息，指定消息名，**如果有人发布了这个消息，那么你指定的回调就要被调用。**不是你调的，是发布消息者调的，别人在调用函数的时候需要指定消息名和携带这个消息的数据 消息订阅与发布需要借助工具库：有很多工具库，这里我们选择Pubsub库 安装库：npm i pubsub-js 导入库：import PubSub from ‘pubsub-js’ ","date":"2021-10-02","objectID":"/react/:15:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"1.优化github搜索案例 可以做到任何组件之间的数据直接传递 之前的思想：Search组件中的搜索举动影响着List组件中的展示，但由于兄弟组件之间无法直接传递数据，所以借助App父组件，将所有数据都放在App父组件的state中，Search的举动影响着那些状态属性，所以每改变一次，就将改变的状态属性传给父组件，父组件再去修改自己状态中的相应属性，然后传给List子组件去动态展示 现在的思想：利用消息发布与订阅，Search组件负责发布消息，List组件负责订阅消息，所以将所有的数据放在List组件的State中。Search的举动影响着那些状态属性，所以每改变一次，就将改变的状态属性数据发布一次，那么List组件就会动态订阅消息，再进行setState状态修改，进而驱动页面动态显示数据 注意事项： 消息的订阅一般放在componentDidMount，组件挂载后 subscribe方法中第二个参数：回调函数，函数的参数必须是两个，第一个为消息名，第二个为数据，如果没有用到某个参数，可以用_占位符代替那个参数 一般需要指定一个变量接收消息订阅，方便在取消订阅的时候能找的到取消的是哪一个消息订阅。如this.token=PubSub.subscribe(‘stateObj’,(_,data)=\u003e{this.setState(data)}); PubSub.unsubscribe(this.token); App.js import React, { Component } from 'react' import Search from './component/Search/index' import List from './component/List/index' export default class App extends Component { render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch/\u003e \u003cList/\u003e \u003c/div\u003e ) } } Search.js import React, { Component } from 'react' import axios from 'axios'; import PubSub from 'pubsub-js' export default class Search extends Component { handleClick=()=\u003e{ const {inputElement:{value:keywords}} = this // 在点击搜索按钮后，发送请求前，发布消息：{first:false,loading:true}，消息名为：stateObj PubSub.publish('stateObj',{first:false,loading:true}); // axios.get(`https://api.github.comdd/search/users?q=${keywords}`).then( // response=\u003e{console(\"成功了\",response.data);}, // error=\u003e{console(\"失败了\",error);} // ) // 这里客户端为3000服务器为5000，而且5000服务器中没有解决跨域问题。所以需要设置代理，代理端口号为3000，所有发送给3000的请求都会被转发到5000 // 这里有一个简写的方法：如果当前客户端为3000，代码中可以省略主机名+3000，即省略http://localhost:3000 axios.get(`/api1/search/users?q=${keywords}`).then( // 请求成功时，发布消息：{people:response.data.items,loading:false}，消息名为：stateObj response=\u003e{PubSub.publish('stateObj',{people:response.data.items,loading:false});}, // 请求失败时，发布消息：{error:error,loading:false}，消息名为：stateObj error=\u003e{PubSub.publish('stateObj',{error:error,loading:false});} ) } render() { return ( \u003csection className=\"jumbotron\"\u003e \u003ch3 className=\"jumbotron-heading\" \u003eSearch Github Users\u003c/h3\u003e \u003cdiv\u003e \u003cinput ref={currentCode=\u003ethis.inputElement=currentCode} type=\"text\" placeholder=\"enter the name you search\"/\u003e\u0026nbsp;\u003cbutton onClick={this.handleClick}\u003eSearch\u003c/button\u003e \u003c/div\u003e \u003c/section\u003e ) } } List.js import React, { Component } from 'react'; import PubSub from 'pubsub-js'; import './index.css'; export default class List extends Component { state={ first:true, //是否第一次打开页面 loading:false, //是否正在加载中 error:'', //存储错误信息 people:[] //用户数据 }; // 将订阅消息放在componentDidMount中，组件挂载完毕后，调用一次componentDidMount函数，那么就开启了一个消息订阅 // subscribe中第二个参数：回调函数，回调函数的参数必须有两个，第一个是消息名，第二个是数据。如果有某个参数用不到，可以用_占位符代替，一下例子中就用占位符代替了msg componentDidMount(){ // 指定变量接收消息订阅，方便取消消息订阅时能找到是哪一个消息订阅 // 只要一发布stateObj消息，就会调用回调函数，从而更新state this.token=PubSub.subscribe('stateObj',(_,data)=\u003e{this.setState(data)}); } // 在组件被卸载之前取消消息订阅 componentWillUnmount(){ PubSub.unsubscribe(this.token); } render() { const {first,loading,error,people}=this.state; return ( \u003cdiv className=\"row\"\u003e { // 因为在jsx中的大括号内只能写表达式，不能写if这种语句判断，所以选择用嵌套三元式来进行条件判断 // react中不能直接渲染一个对象到页面，可以展示对象的某个属性，所以显示error对象中的message属性 first?\u003ch2\u003e欢迎使用，请输入关键字进行搜索用户\u003c/h2\u003e: loading?\u003ch2\u003e加载中.........\u003c/h2\u003e: error?\u003ch2 style={{color:\"red\"}}\u003e错误信息:{error.message}\u003c/h2\u003e: people.map(item=\u003e{ return ( \u003cdiv className=\"card\" key={item.id}\u003e {/* href中如果设置了target=\"_blank\"，另开一个页面。但是需要和rel=\"noreferrer\"一起使用，否则会弹出警告 */} \u003ca rel=\"noreferrer\" href={item.html_url} target=\"_blank\"\u003e {/* img标签必须设置一个alt属性：表示当图片加载失败时显示的文字，否则会警告 */} \u003cimg alt=\"Avatar\" src={item.avatar_url} style={{width:'100px'}}/\u003e \u003c/a\u003e \u003cp className=\"card-text\"\u003e{item.login}\u003c/p\u003e \u003c/div\u003e ) }) } \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:15:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"14.fetch发送请求 学习文档 发送ajax请求有三种方法： 原生xhr（XMLHttpRequest） jQuery（封装的xhr，需要安装） axios（封装xhr，需要安装） fetch： 跟xhr同级，不再使用xhr对象提交请求 是js的原生函数，不需要安装 promise风格 知识点： fetch主要是关注分离思想：分步骤做某件事，如果当前步骤成功了，再往下继续做，如果失败了，就不继续做。如果是请求数据：那么先看服务器连接成不成功，再看数据返回成不成功 promise实例才能.then，.then是用来指定成功的回调和失败的回调的。.then的实例对象的状态和值取决于当前.then的返回值。 如果.then的返回值为非promise值，那么.then的promise实例对象的状态为成功，值为这个非promise值 如果.then的返回值为promise对象，那么.then的promise实例对象就为当前返回的这个promise实例对象 只有断网或者其他不可抗因素，才会使.then的promise实例对象的状态为失败 返回初始化promise对象是可以终止promise链的 ​ return new Promise(()=\u003e{}); promise实例可以在最后统一处理错误，但是在最后统一处理错误的话，那么.then中就只有成功的情况，就可以用await简化.then。 await后面接的是promise实例对象，可以等到这个promise实例对象的成功的结果，但是需要在await所在函数上添加async。由于await只能等到成功的结果，所以需要用try、catch捕捉失败的情况 服务器请求成功中的response.json()是一个promise实例对象。如果数据获取成功了，那么.then的promise实例对象的状态为成功，值为获取的数据。如果数据获取数据失败了，那么.then的promise实例对象的状态为失败，值为失败原因。如果抛出异常了，.then的promise实例对象的状态为失败，值为抛出的异常 // 不规范的fetch写法 fetch(`/api1/search/users2?q=${keywords}`).then( // 此处的response.json()为一个实例对象，数据获取成功了，那么.then的promise实例对象的状态为成功，值为获取的数据。如果数据获取数据失败了，那么.then的promise实例对象的状态为失败，值为失败原因。 response=\u003e{ console.log(\"连接服务器成功了\"); // 访问数据 response.json().then( response=\u003e{console.log(\"访问数据成功了\",response)}, error=\u003e{console.log(\"访问数据失败了\",error)} ) }, error=\u003e{console.log(\"连接服务器失败了\",error);} ) 应用到github搜索案例上： Search.js import React, { Component } from 'react' import axios from 'axios'; import PubSub from 'pubsub-js' export default class Search extends Component { handleClick=async()=\u003e{ const {inputElement:{value:keywords}} = this // 在点击搜索按钮后，发送请求前，发布消息：{first:false,loading:true}，消息名为：stateObj PubSub.publish('stateObj',{first:false,loading:true}); // axios.get(`/api1/search/users?q=${keywords}`).then( // response=\u003e{PubSub.publish('stateObj',{people:response.data.items,loading:false});}, // error=\u003e{PubSub.publish('stateObj',{error:error,loading:false});} // ) // 不规范的fetch写法 // fetch(`/api1/search/users2?q=${keywords}`).then( // // 此处的response.json()为一个实例对象，数据获取成功了，那么.then的promise实例对象的状态为成功，值为获取的数据。如果数据获取数据失败了，那么.then的promise实例对象的状态为失败，值为失败原因。 // response=\u003e{ // console.log(\"连接服务器成功了\"); // // 访问数据 // response.json().then( // response=\u003e{console.log(\"访问数据成功了\",response)}, // error=\u003e{console.log(\"访问数据失败了\",error)} // ) // }, // error=\u003e{console.log(\"连接服务器失败了\",error);} // ) // 规范的fetch写法 // fetch(`/api1/search/users2?q=${keywords}`).then( // // 此处的response.json()为一个实例对象，数据获取成功了，那么.then的promise实例对象的状态为成功，值为获取的数据。如果数据获取数据失败了，那么.then的promise实例对象的状态为失败，值为失败原因。 // response=\u003e{ // console.log(\"连接服务器成功了\"); // // 访问数据 // // 返回的为promise实例对象，所以此promise实例对象将作为.then的promise实例对象，那么：就可以链式.then // return response.json(); // }, // error=\u003e{ // console.log(\"连接服务器失败了\",error); // // 返回初始化promise对象是可以终止promise链的 // return new Promise(()=\u003e{}); // } // ).then( // response=\u003e{console.log(\"访问数据成功了\",response)}, // error=\u003e{console.log(\"访问数据失败了\",error)} // ) // 优化：统一处理错误 // fetch(`/api1/search/users2?q=${keywords}`).then( // // 此处的response.json()为一个实例对象，数据获取成功了，那么.then的promise实例对象的状态为成功，值为获取的数据。如果数据获取数据失败了，那么.then的promise实例对象的状态为失败，值为失败原因。 // response=\u003e{ // console.log(\"连接服务器成功了\"); // // 访问数据 // // 返回的为promise实例对象，所以此promise实例对象将作为.then的promise实例对象，那么：就可以链式.then // return response.json(); // }, // ).then( // response=\u003e{console.log(\"访问数据成功了\",response)}, // ).catch( // error=\u003e{ // console.log(\"出现错误\",error); // } // ) // 优化：await后面接的是promise实例对象，可以等到这个promise实例对象的成功的结果，但是需要在await所在函数上添加async。由于await只能等到成功的结果，所以需要用try、catch捕捉失败的情况 // try{ // // 得到的是服务器连接成功的结果 // const response=await fetch(`/api1/search/users2?q=${keywords}`); // // 得到的是数据获取成功的结果 // const data=await response.json(); // console.log(\"请求成功\",data); // }catch(error){ // console.log(\"请求出错\",error); // } // 应用到本例 try{ // 得到的是服务器连接成功的结果 const response=await fetch(`/api1/search/users2?q=${keywords}`); // 得到的是数据获取成功的结果 const data=await response.json(); PubSub.publish('stateObj',{people:data.items,loading:false}); }catch(error){ PubSub.publish('stateObj',{error:error,loading:false}); } } render() { return ( \u003csection className=\"jumbotron\"\u003e \u003ch3 className=\"jumbotron-heading\" \u003eSe","date":"2021-10-02","objectID":"/react/:16:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.路由 ","date":"2021-10-02","objectID":"/react/:17:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.1 SPA 单页面，多组件 做一个导航栏按钮的切换效果 以前：先写多个页面，用超链接，点击超链接跳转到另一个页面 现在：使用路由，点击导航链接，引起浏览器路径变化。路径变化被路由器捕捉到，进行组件匹配，从而改变展示区内容 ","date":"2021-10-02","objectID":"/react/:17:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.2 对路由的理解 前端路由就是通过改变浏览器上面地址的path来达到显示不同组件的效果，改变地址的path不会去到一个新页面，而是改变当前页面内显示的组件 path就是/xxx，不带.html，如果是/xxx.html表示的是一个页面，而/xxx表示一个组件 ","date":"2021-10-02","objectID":"/react/:17:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.3 路由原理history BOM浏览器对象中存在一个history对象：window.history。 history是一个栈，后push的path就存在栈顶 原理：浏览器地址后面跟的永远是history栈顶的path，显示的也是栈顶的path对应的组件 方法一：直接使用H5推出的history身上的API \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e前端路由的基石_history\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 浏览器地址后面跟的的永远是history栈顶的path，显示的也是栈顶的path对应的组件 --\u003e \u003c!-- onclick=\"return false\" 表示点击连接不会跳转到其他页面 --\u003e \u003ca href=\"http://www.atguigu.com\" onclick=\"return push('/test1') \"\u003epush test1\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"push('/test2')\"\u003epush test2\u003c/button\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"replace('/test3')\"\u003ereplace test3\u003c/button\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"back()\"\u003e\u0026lt;= 回退\u003c/button\u003e \u003cbutton onclick=\"forword()\"\u003e前进 =\u0026gt;\u003c/button\u003e \u003c!-- 引入此库后，就有一个History对象 --\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcss.com/history/4.7.2/history.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e // 方法一，直接使用H5推出的history身上的API // 这里的history直接操作的是BOM里面的history对象，直接修改浏览器的访问地址后缀 let history = History.createBrowserHistory() function push (path) { // 往BOM中的history栈顶中添加此path history.push(path) // onclick=\"return return false\" 表示点击连接不会跳转到其他页面 return false } function replace (path) { // 表示替换掉栈顶的那个元素 history.replace(path) } function back() { // 将history堆栈中的指针位置减1 history.goBack() } function forword() { // 将history堆栈中的指针位置加1 history.goForward() } // history监听 // 只要路径变化了就会触发此回调函数 history.listen((location) =\u003e { console.log('请求路由路径变化了', location) }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 方法二：hash值（锚点） #后面的path不会作为资源发送给服务器，也就是不干涉请求资源的路径 \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003e前端路由的基石_history\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c!-- 浏览器地址后面跟的的永远是history栈顶的path，显示的也是栈顶的path对应的组件 --\u003e \u003c!-- onclick=\"return false\" 表示点击连接不会跳转到其他页面 --\u003e \u003ca href=\"http://www.atguigu.com\" onclick=\"return push('/test1') \"\u003epush test1\u003c/a\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"push('/test2')\"\u003epush test2\u003c/button\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"replace('/test3')\"\u003ereplace test3\u003c/button\u003e\u003cbr\u003e\u003cbr\u003e \u003cbutton onclick=\"back()\"\u003e\u0026lt;= 回退\u003c/button\u003e \u003cbutton onclick=\"forword()\"\u003e前进 =\u0026gt;\u003c/button\u003e \u003c!-- 引入此库后，就有一个History对象 --\u003e \u003cscript type=\"text/javascript\" src=\"https://cdn.bootcss.com/history/4.7.2/history.js\"\u003e\u003c/script\u003e \u003cscript type=\"text/javascript\"\u003e // 方法二，hash值（锚点） // 这里的history直接操作的是BOM里面的history对象，自动在浏览器访问地址后面加上#/，点击链接改变的浏览器地址部分，全在#/后面，而#后面的部分不会作为请求资源 let history = History.createHashHistory() function push (path) { // 往BOM中的history栈中添加此path history.push(path) // onclick=\"return return false\" 表示点击连接不会跳转到其他页面 return false } function replace (path) { // 表示替换掉栈顶的那个元素 history.replace(path) } function back() { // 将栈顶元素出栈 history.goBack() } function forword() { // 将goBack出栈的那个栈顶元素重新进栈 history.goForward() } // history监听 // 只要路径变化了就会触发此回调函数 history.listen((location) =\u003e { console.log('请求路由路径变化了', location) }) \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-10-02","objectID":"/react/:17:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.4 react-router-dom理解 react-router库有三个方面： web，针对web用 native any 现在所学的是第一种，针对web用的，所以用的是react-router-dom库 （印记中文中有react-router相关中文文档） ","date":"2021-10-02","objectID":"/react/:17:4","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.5 路由的基本使用 安装react-router-dom npm install react-router-dom 找到导航栏，找到展示区。思想：点击导航链接，引起浏览器路径变化。路径变化被路由器捕捉到，进行组件匹配，从而改变展示区内容 编写路由链接：指定点击链接后，改变浏览器path 注册路由：指定每个path对应的是哪个组件，key为path，value为组件 注意： 记得导入组件 由于Link标签和Route标签都需要包含在路由器标签中，所以直接将路由器标签在组件被使用的地方包含整个组件 不同路由器标签表示不同路由器，所以不能用两个路由器标签分别包含Link和Route 路由器分为BrowserRouter和HashRouter，主要区别见15.20 Route中的component属性首字母小写，属性值为{组件名}形式，而不是\u003c组件名/\u003e形式 About.js import React, { Component } from 'react' export default class About extends Component { render() { return ( \u003ch3\u003e我是About的内容\u003c/h3\u003e ) } } Home.js import React, { Component } from 'react' export default class Home extends Component { render() { return ( \u003ch3\u003e我是Home的内容\u003c/h3\u003e ) } } index.js import React from 'react' import ReactDom from 'react-dom' // 记得要引入组件 import {BrowserRouter} from 'react-router-dom' import App from './App' ReactDom.render( // 直接将路由器标签包含整个组件，那么组件中就不存在不同路由器标签互相不能访问的问题 \u003cBrowserRouter\u003e \u003cApp/\u003e \u003c/BrowserRouter\u003e, document.getElementById(\"root\") ); App.js import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {Link, Route} from 'react-router-dom' import About from './component/About' import Home from './component/Home' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-offset-2 col-xs-8\"\u003e \u003cdiv className=\"page-header\"\u003e\u003ch2\u003eReact Router Demo\u003c/h2\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} \u003cLink className=\"list-group-item active\" to=\"/about\"\u003eAbout\u003c/Link\u003e \u003cLink className=\"list-group-item\" to=\"/home\"\u003eHome\u003c/Link\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* 注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } 样式需要引入第三方库 index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- 引入第三方样式：bootstrap --\u003e \u003clink rel=\"stylesheet\" href=\"./css/bootstrap.css\"/\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 细节：其实浏览器是不认识Link这种链接的，所以浏览器会自动将Link链接转为a链接，并加一些监听让其实现不跳转 ","date":"2021-10-02","objectID":"/react/:17:5","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.6 路由组件与一般组件 location.pathname、match.path、match.url都可以获取当前组件所处的路由路径 ","date":"2021-10-02","objectID":"/react/:17:6","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.7 NavLink的使用（高亮） 对于booptstrap来说，点击链接，链接变成高亮的话，需要在className属性值后面追加一个active 而直接使用NavLink代替Link，就可以达到点击链接后，改变链接的样式 先引入NavLink组件从react-router-dom包中 NavLink默认是点击链接后，往className属性值的后面追加一个active，但是可以用activeClassName属性指定点击链接后追加的是什么 需要注意的点是：bootstrap样式的权重很高，如果追加的是自己定义的样式，那么需要在每一个样式后面加上 !important index.heml \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- 引入第三方样式：bootstrap --\u003e \u003clink rel=\"stylesheet\" href=\"./css/bootstrap.css\"/\u003e \u003cstyle\u003e /* bootstrap样式的权重很高，所以加上!important */ .testNavLink{background-color:cadetblue !important}; \u003c/style\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e App.js import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {NavLink, Route} from 'react-router-dom' import About from './component/About' import Home from './component/Home' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-offset-2 col-xs-8\"\u003e \u003cdiv className=\"page-header\"\u003e\u003ch2\u003eReact Router Demo\u003c/h2\u003e\u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} \u003cNavLink activeClassName=\"testNavLink\" className=\"list-group-item\" to=\"/about\"\u003eAbout\u003c/NavLink\u003e \u003cNavLink activeClassName=\"testNavLink\" className=\"list-group-item\" to=\"/home\"\u003eHome\u003c/NavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* 注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:7","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.8 二次封装NavLink 虽然NavLink上的activeClassName可以指定链接被点击后，className后面能追加的属性名，但是如果页面中有很多个链接，className都相同，并且点击链接后都变成橙色 ，那么页面中就有很多NavLink标签，并且很多重复的属性。 我们可以把NavLink进行二次封装，将相同的属性封装起来，不同的属性值通过props传递。不同的标签体内容，也可以通过props传递，只不过标签体内容传递到props里面，是一个value，它的key默认指定为children。通过this.props.children就可以得到传递的标签体内容 index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- 引入第三方样式：bootstrap --\u003e \u003clink rel=\"stylesheet\" href=\"./css/bootstrap.css\"/\u003e \u003cstyle\u003e /* bootstrap样式的权重很高，所以加上!important */ .testNavLink{background-color:cadetblue !important}; \u003c/style\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e MyNavLink.js import React, { Component } from 'react' import { NavLink } from 'react-router-dom' export default class MyNavLink extends Component { render() { return ( \u003cdiv\u003e {/* 这里不需要将所有传递的属性一一以键值对的形式写在标签上，直接用...{this.props}展开运算符。 包括标签体内容children，因为在标签上写children属性和直接在开始标签和结束标签之间写标签体内容是一样的 */} \u003cNavLink activeClassName=\"testNavLink\" className=\"list-group-item\" {...this.props}\u003e\u003c/NavLink\u003e \u003c/div\u003e ) } } App.js import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {Route} from 'react-router-dom' import About from './pages/About' import Home from './pages/Home' import Header from './component/Header' import MyNavLink from './component/MyNavLink' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cHeader/\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} {/* 不同的属性值，通过props传递。不同的标签体，也可以通过props传递，传递后的value为children，值为传递的标签体内容，在MyNavLink中可以通过this.props.children拿到传递的标签体内容 */} \u003cMyNavLink to=\"/about\"\u003eAbout\u003c/MyNavLink\u003e \u003cMyNavLink to=\"/home\"\u003eHome\u003c/MyNavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* 注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:8","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.9 Switch 防止注册路由的时候，一个路径对应多个组件，这多个组件都生效的情况。当用Switch标签将注册的所有路由包裹起来时，即使一个path对应着多个组件，那么永远只会对第一个生效 App.js （Switch组件要引入） import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {Route, Switch} from 'react-router-dom' import About from './pages/About' import Home from './pages/Home' import Test from './pages/Test' import Header from './component/Header' import MyNavLink from './component/MyNavLink' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cHeader/\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} {/* 不同的属性值，通过props传递。不同的标签体，也可以通过props传递，传递后的value为children，值为传递的标签体内容，在MyNavLink中可以通过this.props.children拿到传递的标签体内容 */} \u003cMyNavLink to=\"/about\"\u003eAbout\u003c/MyNavLink\u003e \u003cMyNavLink to=\"/home\"\u003eHome\u003c/MyNavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* 加了Switch，一个path对应多个组件时，只对第一个组件生效，不加的话就对两个都生效 */} \u003cSwitch\u003e {/* 注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute path='/about/a/b' component={About}/\u003e {/* 一个path对应两个组件 */} \u003cRoute path='/home' component={Home}/\u003e \u003cRoute path='/home' component={Test}/\u003e \u003c/Switch\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:9","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.10 解决样式丢失问题 localhost:3000是react脚手架内置的一个服务器，是由webpack、devServer开启的一个服务器。它的主机号加端口号代表的就是React脚手架中的public文件夹 如果请求的资源是正确的，就返回相应资源。如果请求的资源不存在，就返回public中的index.html 当路由path为两级以上，刷新页面后样式丢失的原因： 当路由的path路径为两级及两级以上时，如，浏览器在第一次进页面，请求bootstrap资源时的request url是正确的：http://localhost:3000/css/bootstrap.css，所以能成功请求到bootstrap样式。但是一旦将页面刷新后，浏览器请求bootstrap资源的地址就发生了变化，将path路径最后一级路径前的所有路径都加到了 bootstrap资源请求路径中端口号的后面：http://localhost:3000/test/test2/css/bootstrap.css，bootstrap路径不在此请求路径中，所以请求bootstrap样式失败，直接返回的是public中的index.html 第一次进页面： 刷新页面后： 解决方法： 去掉html中引入bootstrap库路径最前面的. （将相对路径改为绝对路径） index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- ./css/bootstrap.css表示index.html同级目录下的css文件夹下的bootstrap.css文件 --\u003e \u003c!-- /css/bootstrap.css，去掉.表示：由于浏览器的localhost:3000表示的就是public，而localhost:3000又可以省略不写，所以/css/bootstrap.css表示直接在public文件夹下去找css/bootstrap.css，不会因为刷新页面而改变请求路径了 --\u003e \u003clink rel=\"stylesheet\" href=\"/css/bootstrap.css\"/\u003e \u003cstyle\u003e /* bootstrap样式的权重很高，所以加上!important */ .testNavLink{background-color:cadetblue !important}; \u003c/style\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 用%PUBLIC_URL%代替. （只适合在react脚手架里面这么写，在其他地方没有这东西） （将相对路径改为绝对路径） index.html \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003cmeta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"\u003e \u003cmeta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u003e \u003c!-- 引入第三方样式：bootstrap --\u003e \u003c!-- %PUBLIC_URL%就表示public --\u003e \u003clink rel=\"stylesheet\" href=\"%PUBLIC_URL%/css/bootstrap.css\"/\u003e \u003cstyle\u003e /* bootstrap样式的权重很高，所以加上!important */ .testNavLink{background-color:cadetblue !important}; \u003c/style\u003e \u003ctitle\u003e主页面\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cdiv id=\"root\"\u003e\u003c/div\u003e \u003c/body\u003e \u003c/html\u003e 方法三（用的少）：用HashRouter，因为HashRouter会自动在浏览器地址后面加上#，#后面的不会作为请求资源。如果path为‘/test/test2/about’，点击链接后，浏览器地址会变成：http://localhost:3000/#/test/test2/about，#后面的不会作为请求资源路径，所以/test/test2/about不会存在于请求资源路径中，不会出现请求bootstrap资源的请求路径为：http://localhost:3000/#/test/test2/about这种情况。 index.js import React from 'react' import ReactDom from 'react-dom' // 记得要引入组件 import {HashRouter} from 'react-router-dom' import App from './App' ReactDom.render( // 直接将路由器标签包含整个组件，那么组件中就不存在不同路由器标签互相不能访问的问题 \u003cHashRouter\u003e \u003cApp/\u003e \u003c/HashRouter\u003e, document.getElementById(\"root\") ); ","date":"2021-10-02","objectID":"/react/:17:10","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.11 路由的模糊匹配和严格匹配 路由默认是模糊匹配的，exact=\"false\"，给的路径不少于要的路径，且顺序位置要对应上 情况一：给的路径少于要的路径，就不能匹配 ​ About ​ 情况二：给的路径多，要的路径少。能匹配，因为匹配是将一个个路径拎出来，about a b与about匹配，发现路由的path为about与给的路径：about a b中的第一个匹配成功 ​ About ​ 情况三：给的路径与要的路径字段位置不匹配。不能匹配成功，因为匹配是按位置顺序匹配的，第一个没匹配成功就不会再继续匹配 ​ About ​ 解决：开启严格匹配，在路由上加一个exact属性，默认为false，设置其为true即可开启严格匹配。 ​ About ​ 但是严格匹配不能随便开启。开启时机：模糊匹配出问题的时候再开启严格匹配。因为随意开启严格匹配有时候会出现问题，比如多级路由的时候（详见15.13嵌套路由） ","date":"2021-10-02","objectID":"/react/:17:11","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.12 Redirect重定向 当所有路由都匹配不上点击路由链接后给的路由地址时，可以使用重定向直接指定路由到哪里去，比如实现一进页面就显示的是About组件的内容： App.js import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {Route, Redirect} from 'react-router-dom' import About from './pages/About' import Home from './pages/Home' import Header from './component/Header' import MyNavLink from './component/MyNavLink' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cHeader/\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} {/* 不同的属性值，通过props传递。不同的标签体，也可以通过props传递，传递后的value为children，值为传递的标签体内容，在MyNavLink中可以通过this.props.children拿到传递的标签体内容 */} \u003cMyNavLink to=\"/about\"\u003eAbout\u003c/MyNavLink\u003e \u003cMyNavLink to=\"/home\"\u003eHome\u003c/MyNavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e {/* 注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003cRedirect to='/about'/\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:12","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.13 嵌套路由 子路由和子路由链接不需要用路由器标签包裹起来 路由链接匹配路由的顺序，是按照注册路由的顺序来的。每一个具体路由链接与路由的匹配规则是从左向右，一旦从左向右出现匹配不成功的path字段，就匹配失败 路由链接一旦执行重定向指定的路由，就不会再继续匹配后面的路由 子路由要写上父路由的path值的原因是：父路由先注册，子路由后注册，子路由中的路由链接匹配顺序就是从父路由的路由中开始，如果子路由没有加上父路由的path，那么子路由的路由链接上也应该没有父路由的path，那么子路由的路由链接从父路由中开始匹配的，就匹配不到任何父路由，那么就会走父组件的重定向，一旦走了父组件的重定向指定的路由，那么就不会再继续匹配后面的路由了，所以最终显示的是父组件的重定向指定的路由对应的组件，不会显示任何子路由对应的组件 如果子路由的path值前面加上了父路由的path值，那么子路由链接匹配时，会匹配成功父路由，父路由对应的组件就会显示出来。子路由链接继续匹配，匹配到子路由那么子路由对应的组件也会显示出来达到了点击子路由链接时，既不丢弃父组件也会显示子组件 如果在父路由中开启了严格匹配，那么子路由链接按照注册顺序匹配时，匹配不到任何父路由，所以会走重定向，一旦走了重定向指定的路由，就不会再继续匹配后面的路由了，所以也匹配不到任何子路由 App.js import React, { Component } from 'react' // Link、Route首字母大写，是组件 import {Route, Redirect, Switch} from 'react-router-dom' import About from './pages/About' import Home from './pages/Home' import Header from './component/Header' import MyNavLink from './component/MyNavLink' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cHeader/\u003e \u003cdiv className=\"row\"\u003e \u003cdiv className=\"col-xs-2 col-xs-offset-2\"\u003e \u003cdiv className=\"list-group\"\u003e {/* 原生html中，靠a标签跳转到不用页面实现导航功能 */} {/* \u003ca className=\"list-group-item active\" href=\"./about.html\"\u003eAbout\u003c/a\u003e \u003ca className=\"list-group-item\" href=\"./home.html\"\u003eHome\u003c/a\u003e */} {/* 在React路由中靠路由链接实现切换组件-------编写路由链接 */} {/* 不是href了，而是to，并且to属性值为path，即 /组件名 这种形式的 */} {/* 路由链接需要被包含在路由器里面，所以外侧需要包含一个Router标签，但是Router标签有两种：BrowserRouter、HashRouter，需要在其中选择一个。二者区别在 路由原理history 中有详解。一般路由器标签都直接放在组件使用的地方，直接包含整个组件 */} {/* 在组件内部使用多个路由器标签，代表的是不同的路由器，互相不相干，所以一般直接将路由器标签放在组件被使用的地方，直接包含整个组件 */} {/* 不同的属性值，通过props传递。不同的标签体，也可以通过props传递，传递后的value为children，值为传递的标签体内容，在MyNavLink中可以通过this.props.children拿到传递的标签体内容 */} \u003cMyNavLink to=\"/about\"\u003eAbout\u003c/MyNavLink\u003e \u003cMyNavLink to=\"/home\"\u003eHome\u003c/MyNavLink\u003e \u003c/div\u003e \u003c/div\u003e \u003cdiv className=\"col-xs-6\"\u003e \u003cdiv className=\"panel\"\u003e \u003cdiv className=\"panel-body\"\u003e \u003cSwitch\u003e {/* 组件级别最高，所以是最先注册路由 */} {/* 一定要注意component首字母小写 */} \u003cRoute exact path='/about' component={About}/\u003e \u003cRoute path='/home' component={Home}/\u003e \u003cRedirect to='/about'/\u003e \u003c/Switch\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e ) } } Home.js import React, { Component } from 'react' import {Route, Redirect, Switch} from 'react-router-dom' import MyNavLink from '../../component/MyNavLink' import Message from './Message' import News from './News' export default class Home extends Component { render() { return ( \u003cdiv\u003e \u003ch2\u003eHome组件内容\u003c/h2\u003e \u003cdiv\u003e \u003cul className=\"nav nav-tabs\"\u003e \u003cli\u003e {/* 先匹配父组件中先注册的路由，to=\"/home/news\"能和path=\"/home\"匹配上，所以能显示Home组件的内容，再继续匹配到子组件中的路由，能和path=\"/home/news\"匹配上，所以也能显示News组件的内容 */} \u003cMyNavLink to=\"/home/news\"\u003eNews\u003c/MyNavLink\u003e \u003c/li\u003e \u003cli\u003e \u003cMyNavLink to=\"/home/message\"\u003eMessage\u003c/MyNavLink\u003e \u003c/li\u003e \u003c/ul\u003e \u003cSwitch\u003e {/* 组件级别其次，第二注册的路由 */} \u003cRoute path=\"/home/news\" component={News}/\u003e \u003cRoute path=\"/home/message\" component={Message}/\u003e \u003cRedirect to=\"/home/news\"/\u003e \u003c/Switch\u003e \u003c/div\u003e \u003c/div\u003e ) } } News.js import React, { Component } from 'react' export default class News extends Component { render() { return ( \u003cul\u003e \u003cli\u003enews001\u003c/li\u003e \u003cli\u003enews002\u003c/li\u003e \u003cli\u003enews003\u003c/li\u003e \u003c/ul\u003e ) } } Message.js import React, { Component } from 'react' export default class Message extends Component { render() { return ( \u003cul\u003e \u003cli\u003e {/* 浏览器根据此请求路径找不到相关资源，会默认显示public下的index.html */} \u003ca href=\"/message1\"\u003emessage001\u003c/a\u003e\u0026nbsp;\u0026nbsp; \u003c/li\u003e \u003cli\u003e \u003ca href=\"/message2\"\u003emessage002\u003c/a\u003e\u0026nbsp;\u0026nbsp; \u003c/li\u003e \u003cli\u003e \u003ca href=\"/message/3\"\u003emessage003\u003c/a\u003e\u0026nbsp;\u0026nbsp; \u003c/li\u003e \u003c/ul\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:13","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.14 向路由组件传递参数params数据 在编写路由链接时，传递参数，格式：路由链接的路由path/参数值1/参数值2 在注册路由时，声明接收参数，格式：路由path/参数1/参数2 在路由对应组件中接收参数：/:参数名1/:参数名2，传递的参数以props的形式传递给路由对应的组件，参数都放在props对象中的match对象中的params对象中 Message.js import React, { Component } from 'react' import {Link, Route} from 'react-router-dom' import Detail from './Detail' export default class Message extends Component { state={messageArr:[ {id:1,title:\"消息1\"}, {id:2,title:\"消息2\"}, {id:3,title:\"消息3\"} ]} render() { const {messageArr}=this.state return ( \u003cdiv\u003e \u003cul\u003e { messageArr.map(item=\u003e{ // 带上祖先路由的path return ( \u003cli key={item.id}\u003e {/* 向路由组件传递params参数 */} {/* Link是标签，而反引号``属于js的语法，所以要在外侧包一个{} */} \u003cLink to={`/home/message/detail/${item.id}/${item.title}`}\u003e{item.title}\u003c/Link\u003e \u003c/li\u003e ) }) } \u003c/ul\u003e {/* 声明接收params参数，参数以props传递到路由对应的组件中了,参数存放在props中的match对象中的params对象中，参数以key value键值对的形式存放 */} \u003cRoute path=\"/home/message/detail/:id/:title\" component={Detail}/\u003e \u003c/div\u003e ) } } Detail.js import React, { Component } from 'react' const detailMsg=[ {id:1,context:\"你是猪\"}, {id:2,context:\"天天就知道睡觉\"}, {id:3,context:\"就知道吃饭\"} ] export default class Detail extends Component { render() { const {id,title}=this.props.match.params; // find得到的是满足条件的那个数组项，而filter得到的是将满足条件的数组项封装成的那个数组 const matchMsg=detailMsg.find(item=\u003e{ return item.id==id }) return ( \u003cdiv\u003e \u003cul\u003e \u003cli\u003eID:{id}\u003c/li\u003e \u003cli\u003eTITLE:{title}\u003c/li\u003e \u003cli\u003eCONTEXT:{matchMsg.context}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:14","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.15 向路由器传递参数search数据 传递参数，以?开始，每个参数之间用\u0026连接：路由链接path路径/?参数1=参数值\u0026参数2=参数值 声明接收参数，在注册路由时不需要写任何接收参数，正常注册路由即可 路由对应组件中接收参数，接收参数从this.props.location.search中拿，参数类型为urlencoded编码的字符串 Message.js import React, { Component } from 'react' import {Link, Route} from 'react-router-dom' import Detail from './Detail' export default class Message extends Component { state={messageArr:[ {id:1,title:\"消息1\"}, {id:2,title:\"消息2\"}, {id:3,title:\"消息3\"} ]} render() { const {messageArr}=this.state return ( \u003cdiv\u003e \u003cul\u003e { messageArr.map(item=\u003e{ // 带上祖先路由的path return ( \u003cli key={item.id}\u003e {/* 向路由组件传递params参数 */} {/* Link是标签，而反引号``属于js的语法，所以要在外侧包一个{} */} {/* \u003cLink to={`/home/message/detail/${item.id}/${item.title}`}\u003e{item.title}\u003c/Link\u003e */} {/* 向路由组件传递search参数,以?开始，每个参数之间用\u0026连接 */} \u003cLink to={`/home/message/detail/?id=${item.id}\u0026title=${item.title}`}\u003e{item.title}\u003c/Link\u003e \u003c/li\u003e ) }) } \u003c/ul\u003e {/* 声明接收params参数，参数以props传递到路由对应的组件中了,参数存放在props中的match对象中的params对象中，参数以key value键值对的形式存放 */} {/* \u003cRoute path=\"/home/message/detail/:id/:title\" component={Detail}/\u003e */} {/* 声明接收search参数，search参数不需要在注册路由时声明接收，正常注册路由即可。且参数以urlencoded编码方式存放在props的localhost的search中: 参数1:参数值\u0026参数2:参数值 */} \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e \u003c/div\u003e ) } } Detail.js import React, { Component } from 'react' import qs from 'querystring' const detailMsg=[ {id:1,context:\"你是猪\"}, {id:2,context:\"天天就知道睡觉\"}, {id:3,context:\"就知道吃饭\"} ] export default class Detail extends Component { render() { // 向路由传递params参数时，接收参数从props.match.params中拿，参数类型为键值对 // const {id,title}=this.props.match.params; // 向路由传递params参数时，接收参数从props.location.searc中拿，参数类型为urlencoded编码的字符串 const {search}=this.props.location // 从字符串1位开始截取字符串，去掉参数字符串首部的?号 const detail = search.substring(1) // 将urlencoded编码转换为键值对对象形式 const {id,title}=qs.parse(detail) // find得到的是满足条件的那个数组项，而filter得到的是将满足条件的数组项封装成的那个数组 const matchMsg=detailMsg.find(item=\u003e{ return item.id==id }) return ( \u003cdiv\u003e \u003cul\u003e \u003cli\u003eID:{id}\u003c/li\u003e \u003cli\u003eTITLE:{title}\u003c/li\u003e \u003cli\u003eCONTEXT:{matchMsg.context}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:15","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.16 向路由组件传递state参数 传递参数，向路由组件传递state参数,to值必须为一个对象，每个属性格式为键值对,state属性值也必须为一个对象，参数格式为键值对 声明接收参数，state参数不需要在注册路由时声明接收，正常注册路由即可。且参数以key value存放在props的localhost的state中 路由对应组件中接收参数，接收参数从props.location.state中拿，参数类型为键值对 state传参不会在浏览器地址栏显示出来，刷新页面，参数不会丢，因为BrowserRouter是一直操作history对象的，history对象中也存放了一个location对象，所以state数据会一直保存在history中，除非清空浏览器缓存，所以刷新页面不会导致state数据的丢失 Message.js import React, { Component } from 'react' import {Link, Route} from 'react-router-dom' import Detail from './Detail' export default class Message extends Component { state={messageArr:[ {id:1,title:\"消息1\"}, {id:2,title:\"消息2\"}, {id:3,title:\"消息3\"} ]} render() { const {messageArr}=this.state return ( \u003cdiv\u003e \u003cul\u003e { messageArr.map(item=\u003e{ // 带上祖先路由的path return ( \u003cli key={item.id}\u003e {/* 向路由组件传递params参数 */} {/* Link是标签，而反引号``属于js的语法，所以要在外侧包一个{} */} {/* \u003cLink to={`/home/message/detail/${item.id}/${item.title}`}\u003e{item.title}\u003c/Link\u003e */} {/* 向路由组件传递search参数,以?开始，每个参数之间用\u0026连接 */} {/* \u003cLink to={`/home/message/detail/?id=${item.id}\u0026title=${item.title}`}\u003e{item.title}\u003c/Link\u003e */} {/* 向路由组件传递state参数,to值必须为一个对象，每个属性格式为键值对,state属性值也必须为一个对象，参数格式为键值对*/} {/* 最外侧括号表示html中写的是js代码，里侧的括号表示to属性值为一个对象 */} \u003cLink to={{pathname:'/home/message/detail',state:{id:item.id,title:item.title}}}\u003e{item.title}\u003c/Link\u003e \u003c/li\u003e ) }) } \u003c/ul\u003e {/* 声明接收params参数，参数以props传递到路由对应的组件中了,参数存放在props中的match对象中的params对象中，参数以key value键值对的形式存放 */} {/* \u003cRoute path=\"/home/message/detail/:id/:title\" component={Detail}/\u003e */} {/* 声明接收search参数，search参数不需要在注册路由时声明接收，正常注册路由即可。且参数以urlencoded编码方式存放在props的localhost的search中: 参数1:参数值\u0026参数2:参数值 */} {/* \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e */} {/* 声明接收state参数，state参数不需要在注册路由时声明接收，正常注册路由即可。且参数以key value存放在props的localhost的state中 */} \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e \u003c/div\u003e ) } } Detail.js import React, { Component } from 'react' import qs from 'querystring' const detailMsg=[ {id:1,context:\"你是猪\"}, {id:2,context:\"天天就知道睡觉\"}, {id:3,context:\"就知道吃饭\"} ] export default class Detail extends Component { render() { // 向路由传递params参数时，接收参数从props.match.params中拿，参数类型为键值对 // const {id,title}=this.props.match.params; // 向路由传递search参数时，接收参数从props.location.search中拿，参数类型为urlencoded编码的字符串 // const {search}=this.props.location // // 从字符串1位开始截取字符串，去掉参数字符串首部的?号 // const detail = search.substring(1) // // 将urlencoded编码转换为键值对对象形式 // const {id,title}=qs.parse(detail) // 向路由传递state参数时，接收参数从props.location.state中拿，参数类型为键值对 // 如果路由没传state参数，那么this.props.location.state就为默认值undefined，从undefined中取值就会报错，所以当没传state参数时，让其为空对象，而不是默认值undefined const {id,title}=this.props.location.state||{}; // find得到的是满足条件的那个数组项，而filter得到的是将满足条件的数组项封装成的那个数组 // 如果this.props.location.state没有id属性，id为undefined，detailMsg中没有id值与undefined相同，所以matchMsg为undefined，那么下面matchMsg.context就会报错，所以当没有值与state中的id相同时，让matchMsg为空对象 const matchMsg=detailMsg.find(item=\u003e{ return item.id==id })||{} return ( \u003cdiv\u003e \u003cul\u003e \u003cli\u003eID:{id}\u003c/li\u003e \u003cli\u003eTITLE:{title}\u003c/li\u003e \u003cli\u003eCONTEXT:{matchMsg.context}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:16","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.17push与replace push: 压栈的方式，当前组件路径永远在history栈顶 所有的都会留下记录，都能返回和前进 replace：开启方法是在编写路由链接时设置replace属性为true 替换掉栈顶路由路径，不会留下历史记录 \u003cLink replace to={{pathname:'/home/message/detail',state:{id:item.id,title:item.title}}}\u003e{item.title}\u003c/Link\u003e Message.js import React, { Component } from 'react' import {Link, Route} from 'react-router-dom' import Detail from './Detail' export default class Message extends Component { state={messageArr:[ {id:1,title:\"消息1\"}, {id:2,title:\"消息2\"}, {id:3,title:\"消息3\"} ]} render() { const {messageArr}=this.state return ( \u003cdiv\u003e \u003cul\u003e { messageArr.map(item=\u003e{ // 带上祖先路由的path return ( \u003cli key={item.id}\u003e {/* 向路由组件传递params参数 */} {/* Link是标签，而反引号``属于js的语法，所以要在外侧包一个{} */} {/* replace开启替换history栈顶的路由路径，每点击消息链接，会替换掉/home/message，再点击就会替换掉刚刚的消息链接路由路径，所以点击返回，返回的是/home/news */} \u003cLink replace to={`/home/message/detail/${item.id}/${item.title}`}\u003e{item.title}\u003c/Link\u003e {/* 向路由组件传递search参数,以?开始，每个参数之间用\u0026连接 */} {/* \u003cLink to={`/home/message/detail/?id=${item.id}\u0026title=${item.title}`}\u003e{item.title}\u003c/Link\u003e */} {/* 向路由组件传递state参数,to值必须为一个对象，每个属性格式为键值对,state属性值也必须为一个对象，参数格式为键值对*/} {/* 最外侧括号表示html中写的是js代码，里侧的括号表示to属性值为一个对象 */} {/* \u003cLink replace to={{pathname:'/home/message/detail',state:{id:item.id,title:item.title}}}\u003e{item.title}\u003c/Link\u003e */} \u003c/li\u003e ) }) } \u003c/ul\u003e {/* 声明接收params参数，参数以props传递到路由对应的组件中了,参数存放在props中的match对象中的params对象中，参数以key value键值对的形式存放 */} \u003cRoute path=\"/home/message/detail/:id/:title\" component={Detail}/\u003e {/* 声明接收search参数，search参数不需要在注册路由时声明接收，正常注册路由即可。且参数以urlencoded编码方式存放在props的localhost的search中: 参数1:参数值\u0026参数2:参数值 */} {/* \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e */} {/* 声明接收state参数，state参数不需要在注册路由时声明接收，正常注册路由即可。且参数以key value存放在props的localhost的state中 */} {/* \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e */} \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:17","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.18 编程式路由导航 实现不点击链接也能跳转路由，即不用Link、NavLink，比如点击某个按钮实现跳转路由：利用路由组件中的history对象中的push方法实现push形式的路由跳转，replace方法实现replace形式的跳转 go：参数为nubmer，表示前进几步，可以为负值，负值表示后退 goBack：后退一步 goForward：前进一步 push：以push形式路由 replace：以replace形式路由 pathname、path、url都可以获取当前组件所处的路由路径 Message.js import React, { Component } from 'react' import {Link, Route} from 'react-router-dom' import Detail from './Detail' export default class Message extends Component { state={messageArr:[ {id:1,title:\"消息1\"}, {id:2,title:\"消息2\"}, {id:3,title:\"消息3\"} ]} pushShow=(id,title)=\u003e{ // push跳转+携带params参数 // this.props.history.push(`/home/message/detail/${id}/${title}`) // push跳转+携带search参数 // this.props.history.push(`/home/message/detail/?id=${id}\u0026title=${title}`) // push跳转+携带state参数 // push可以携带两个参数：path,state this.props.history.push('/home/message/detail',{id,title}) } replaceShow=(id,title)=\u003e{ // replace跳转+携带params参数 // this.props.history.replace(`/home/message/detail/${id}/${title}`) // replace跳转+携带search参数 // this.props.history.replace(`/home/message/detail/?id=${id}\u0026title=${title}`) // replace跳转+携带state参数 // replace可以携带两个参数：path,state this.props.history.replace('/home/message/detail',{id,title}) } back=()=\u003e{ this.props.history.goBack() } forward=()=\u003e{ this.props.history.goForward() } render() { const {messageArr}=this.state return ( \u003cdiv\u003e \u003cul\u003e { messageArr.map(item=\u003e{ // 带上祖先路由的path return ( \u003cli key={item.id}\u003e {/* 向路由组件传递params参数 */} {/* Link是标签，而反引号``属于js的语法，所以要在外侧包一个{} */} {/* replace开启替换history栈顶的路由路径，每点击消息链接，会替换掉/home/message，再点击就会替换掉刚刚的消息链接路由路径，所以点击返回，返回的是/home/news */} \u003cLink replace to={`/home/message/detail/${item.id}/${item.title}`}\u003e{item.title}\u003c/Link\u003e {/* 向路由组件传递search参数,以?开始，每个参数之间用\u0026连接 */} {/* \u003cLink to={`/home/message/detail/?id=${item.id}\u0026title=${item.title}`}\u003e{item.title}\u003c/Link\u003e */} {/* 向路由组件传递state参数,to值必须为一个对象，每个属性格式为键值对,state属性值也必须为一个对象，参数格式为键值对*/} {/* 最外侧括号表示html中写的是js代码，里侧的括号表示to属性值为一个对象 */} {/* \u003cLink replace to={{pathname:'/home/message/detail',state:{id:item.id,title:item.title}}}\u003e{item.title}\u003c/Link\u003e */} \u003cbutton onClick={()=\u003e{this.pushShow(item.id,item.title)}}\u003epush跳转\u003c/button\u003e \u003cbutton onClick={()=\u003e{this.replaceShow(item.id,item.title)}}\u003ereplace跳转\u003c/button\u003e \u003c/li\u003e ) }) } \u003c/ul\u003e {/* 声明接收params参数，参数以props传递到路由对应的组件中了,参数存放在props中的match对象中的params对象中，参数以key value键值对的形式存放 */} {/* \u003cRoute path=\"/home/message/detail/:id/:title\" component={Detail}/\u003e */} {/* 声明接收search参数，search参数不需要在注册路由时声明接收，正常注册路由即可。且参数以urlencoded编码方式存放在props的localhost的search中: 参数1:参数值\u0026参数2:参数值 */} {/* \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e */} {/* 声明接收state参数，state参数不需要在注册路由时声明接收，正常注册路由即可。且参数以key value存放在props的localhost的state中 */} \u003cRoute path=\"/home/message/detail\" component={Detail}/\u003e \u003cbutton onClick={this.back}\u003e回退\u003c/button\u003e \u003cbutton onClick={this.forward}\u003e前进\u003c/button\u003e \u003c/div\u003e ) } } Detail.js import React, { Component } from 'react' import qs from 'querystring' const detailMsg=[ {id:1,context:\"你是猪\"}, {id:2,context:\"天天就知道睡觉\"}, {id:3,context:\"就知道吃饭\"} ] export default class Detail extends Component { render() { // 向路由传递params参数时，接收参数从props.match.params中拿，参数类型为键值对 // const {id,title}=this.props.match.params; // 向路由传递search参数时，接收参数从props.location.search中拿，参数类型为urlencoded编码的字符串 // const {search}=this.props.location // // 从字符串1位开始截取字符串，去掉参数字符串首部的?号 // const detail = search.substring(1) // // 将urlencoded编码转换为键值对对象形式 // const {id,title}=qs.parse(detail) // 向路由传递state参数时，接收参数从props.location.state中拿，参数类型为键值对 // 如果路由没传state参数，那么this.props.location.state就为默认值undefined，从undefined中取值就会报错，所以当没传state参数时，让其为空对象，而不是默认值undefined const {id,title}=this.props.location.state||{}; // find得到的是满足条件的那个数组项，而filter得到的是将满足条件的数组项封装成的那个数组 // 如果this.props.location.state没有id属性，id为undefined，detailMsg中没有id值与undefined相同，所以matchMsg为undefined，那么下面matchMsg.context就会报错，所以当没有值与state中的id相同时，让matchMsg为空对象 const matchMsg=detailMsg.find(item=\u003e{ return item.id==id })||{} return ( \u003cdiv\u003e \u003cul\u003e \u003cli\u003eID:{id}\u003c/li\u003e \u003cli\u003eTITLE:{title}\u003c/li\u003e \u003cli\u003eCONTEXT:{matchMsg.context}\u003c/li\u003e \u003c/ul\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:17:18","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.19 withRouter使用 是react-router-dom中的一个方法，需要引入 withRouter作用：可以让一般组件也能使用路由组件的api，比如this.props自动有history、location、match属性 现在Header组件内也加上回退、前进、go按钮 Header.js import React, { Component } from 'react' import {withRouter} from 'react-router-dom' class Header extends Component { back=()=\u003e{ this.props.history.goBack() } forward=()=\u003e{ this.props.history.goForward() } go=()=\u003e{ this.props.history.go(2) } render() { return ( \u003cdiv className=\"col-xs-offset-2 col-xs-8\"\u003e \u003cdiv className=\"page-header\"\u003e\u003ch2\u003eReact Router Demo\u003c/h2\u003e\u003c/div\u003e \u003cbutton onClick={this.back}\u003e回退\u003c/button\u003e \u003cbutton onClick={this.forward}\u003e前进\u003c/button\u003e \u003cbutton onClick={this.go}\u003ego\u003c/button\u003e \u003c/div\u003e ) } } // 默认暴露出withRouter(Header)的返回值，withRouter能让一般组件也能使用路由组件的api，返回值为能使用路由组件api的新的一般组件 export default withRouter(Header) ","date":"2021-10-02","objectID":"/react/:17:19","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"15.20 BrowserRouter和HashRouter的区别 在向路由组件传递state参数时，由于这种传参方式不会在浏览器地址栏中显示出来参数，而HashRputer靠的就是地址栏后面的哈希值，所以使用HashRouter时，会造成参数的丢失。BrowserRouter使用的是浏览器BOM内置的history对象，与this.props.history对象不一样，所以刷新页面不影响路由携带的参数，因为state保存在了浏览器内置history栈中。而HashRouter没有使用浏览器内置history，它使用的是url的哈希值，由于state参数不会在地址栏显示出来，所以没有人帮它记住历史path，所以刷新页面会造成路由参数丢失 所以BrowserRouter用的多，但是HashRouter的兼容性比较好 ","date":"2021-10-02","objectID":"/react/:17:20","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"16. antd ","date":"2021-10-02","objectID":"/react/:18:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"16.1 antd的基本使用 ant-design：第三方组件库 需要安装：npm install antd 引入库：import antd from ‘antd’，如果from后面只有一个包名，那么会默认去node_modules中找 需要引入antd包下的dist文件夹中的antd.css样式，样式才有效：import antdcss from ‘antd/dist/antd.css’ App.js import React, { Component } from 'react' import antd, { Button } from 'antd' // 需要引入antd样式，样式才有效 import antdcss from 'antd/dist/antd.css' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cbutton\u003e普通按钮\u003c/button\u003e \u003cButton type=\"primary\"\u003e主要按钮\u003c/Button\u003e \u003c/div\u003e ) } } 有很多子库，安装antd库的时候就已经安装了子库，但是使用的时候需要分别引入，因为子库中的内容，antd主库中没有。比如：如果需要使用antd中的图标，就需要引入@ant-design/icons库，针对不同图标对应的不同组件，从@ant-design/icons库中引入 import React, { Component } from 'react' import antd, { Button } from 'antd' // 需要引入antd样式，样式才有效 import antdcss from 'antd/dist/antd.css' // 引入antd的子库：图标库，需引入图标库中图标对应的组件 import {RedditOutlined} from '@ant-design/icons' export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cbutton\u003e普通按钮\u003c/button\u003e \u003cButton type=\"primary\"\u003e主要按钮\u003c/Button\u003e \u003cRedditOutlined /\u003e \u003c/div\u003e ) } } ","date":"2021-10-02","objectID":"/react/:18:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"16.2 antd样式的按需引入 直接引入@ant-design/icons表示引入所有antd组件的样式，文件会很大，而且我们用到的只有那么几个组件，其他组件样式引入后根本没用。 按需引入样式的方法：修改react配置 方法一：可以使用 create-react-app 提供的npm run eject命令将所有react内建的配置暴露出来。这种方法非常不推荐使用，因为一旦暴露出来，不小心修改错了，那么会导致项目都运行不起来，而且是不可恢复的 执行命令后react脚手架会出现一个config文件夹，里面存放着配置文件 方法二： 将要修改的内容单独放在一个文件中，这个文件一般是在根目录中创建一个config-overrides.js文件，用于修改默认配置 npm add react-app-rewired customize-cra：安装react-app-rewired customize-cra这两个包， customize-cra包用于找到craco.config.js配置文件，并执行。react-app-rewired包用于启动项目，因为用customize-cra修改配置时，会导致用原来的react-scripts start命令不能启动脚手架，所以需要安装这个包去启动项目 npm start是个短命令，原命令是：react-scripts start。用customize-cra修改配置后，原来的react-scripts start不能启动项目了，所以需要在package.json中修改启动命令，用刚下载的react-app-rewired去启动项目 修改start、build、test的命令 npm add babel-plugin-import：安装babel-plugin-import插件，这个插件支持样式按需引入 修改config-overrides.js文件内容 // 修改默认配置 const { override, fixBabelImports } = require('customize-cra'); // import表示引入，antd表示引入的是antd的东西，es表示用了es规范，css表示引入的是样式 module.exports = override( fixBabelImports('import', { libraryName: 'antd', libraryDirectory: 'es', style: 'css', }), ); 做完了以上5步后，在写代码的时候就可以不用引入import antdcss from ‘antd/dist/antd.css’样式了 出现问题：修改package.json文件react-app-rewired后，用npm start发现启动不了项目。 解决方法： https://www.cnblogs.com/tu-0718/p/12541841.html https://www.cnblogs.com/qianxiaox/p/13830977.html ","date":"2021-10-02","objectID":"/react/:18:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"16.3 antd自定义主题 antd底层样式全是用less写的，react会自动将less编译成css，如果你要修改antd组件的样式，需要安装less 和 less-loader，antd组件样式底层是用less写的，要改就要先安装less，由于需要将less编译为css，所以需要安装less-loader。之前不用安装是因为之前底层已经自动编译好了。 例子：修改底层主题颜色，antd的主题颜色是蓝色 安装less 和 less-loader：npm 修改config-overrides.js，将style:‘css’，修改为style:true，因为现在不是将css按需引入，而是将修改后的less，再编译成css按需引入 引入addLessLoader 添加代码 // javascriptEnabled表示能用js修改底层less样式文件 // 这里不能用modifyVars去修改主题样式了，因为现在less-loader更新了，不再用modifyVars去修改主题样式了，而是用lessOptions对象 // addLessLoader:修改antd底层样式的方法 addLessLoader({ // 坑：如果你使用的less-loader是5.0.0版本的，就不要加lessOptions，直接写里面两个属性 lessOptions:{ javascriptEnabled: true, modifyVars: { '@primary-color': 'green' }, } }), 报错1：addlessloader is not defined，可能是因为你使用的less-loader是5.0.0版本，要去掉lessOptions，直接配置里面的选项 报错2：this.getOptions is not a function，less-loader版本过高，降低版本，建议不要降到5.0.0版本，因为5.0.0版本不能加lessOption npm uninstall less-loader npm install less-loader@6.0.0 坑：如果你使用的less-loader是5.0.0版本的，就不要加lessOptions，直接配置里面两个属性 ","date":"2021-10-02","objectID":"/react/:18:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17. redux ","date":"2021-10-02","objectID":"/react/:19:0","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.1 redux简介 英文文档: https://redux.js.org/ 中文文档: http://www.redux.org.cn/ Github: https://github.com/reactjs/redux ","date":"2021-10-02","objectID":"/react/:19:1","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.2 redux工作流程 React Components：提出要对redux里面的状态进行某些动作，比如想对redux中的状态数据进行+运算 Action Creators：当React Components要对redux里面的状态数据操作时，将要做的动作（如：加法运算）封装在一个对象action对象中，对象中包含两个属性： type：动作类型，比如+。 2.data：数据，比如1。 dispatch函数：将参数action对象分发给Store去做，存在于store对象中 Store：是一个指挥者，负责将收到的动作对象交给Reducers去做，并获取到完成后的结果 Reducers： 本质是一个函数： ​ 接收参数：preState、action对象 ​ 返回值：newState 初始化状态。由于加工状态的时候，需要知道加工前的状态——–previousState，以及要进行加工的动作——-action对象，比如：+1这个动作，需要知道之前一次的数是多少，才能进行+1运算。 但是第一次加工的时候，状态并没有初始值，所以Reducers还能初始化状态。当previousState没有值时，那么它的初始值为undefined。 当为初始化动作时，action对象中，preState为undefined，type内置为：@@init+随机生成的字符串，（后面加上随机生成的字符串，是为了防止初始化的type，和加工状态的type重名）。data：没有任何值。在reduce.js中指定状态初始值为多少 当为初始化状态时，reduce中的方法是由store自动调用的 当为加工状态时，reduce里面的方法是当在组件中使用store.dispatch(action)方法后，再调用的 加工状态，能修改redux里面的状态，先获取上一次的状态，再对上一次的状态进行加工动作,得到结果newState，将结果返回给Store，React Components通过getState得到新状态 ","date":"2021-10-02","objectID":"/react/:19:2","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.3 求和案例 1. 纯react版 状态放在组件自身上 Count.js import React, { Component } from 'react' export default class Count extends Component { state={count:0} increment = () =\u003e{ const {value} = this.selectNumNode; const {count} = this.state; // value是一个字符串，所以需要-0转为数字再进行运算 this.setState({count:count+(value-0)}); } decrement = () =\u003e{ const {value} = this.selectNumNode; const {count} = this.state; this.setState({count:count-(value-0)}); } incrementIfOdd = () =\u003e{ const {value} = this.selectNumNode; const {count} = this.state; if(count%2 !== 0){ this.setState({count:count+(value-0)}); } } incrementAsync = () =\u003e{ const {value} = this.selectNumNode; const {count} = this.state; // 每次点击按钮后，过2秒再执行这个函数 setTimeout(()=\u003e{ this.setState({count:count+(value-0)}); },2000); } render() { const {count} = this.state; return ( \u003cdiv\u003e \u003ch2\u003e当前求和为：{count}\u003c/h2\u003e {/* 获取选中的结点 */} \u003cselect ref={c=\u003e{this.selectNumNode=c}}\u003e \u003coption value=\"1\"\u003e1\u003c/option\u003e \u003coption value=\"2\"\u003e2\u003c/option\u003e \u003coption value=\"3\"\u003e3\u003c/option\u003e \u003c/select\u003e\u0026nbsp; \u003cbutton onClick={this.increment}\u003e+\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.decrement}\u003e-\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.incrementIfOdd}\u003e当前求和为奇数时再加\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.incrementAsync}\u003e异步加\u003c/button\u003e \u003c/div\u003e ) } } 2. 精简版的redux 即不用Action Creators创建action对象 做一个计算器 （1）去除Count组件自身的状态（如果只有Count组件自己用的或者被很少组件需要的状态，就直接放在组件内部） 安装redux：npm i redux 创建一个redux文件夹，存放唯一的store.js文件和reducer.js，当一个组件需要用到redux中的状态时，就会为这个组件单独建一个reducer，所以最好命名为：一看就知道是哪个组件的名字。比如Count组件的reducer，可以命名为count_reducer store.js /** * 该文件专门用于暴露一个store对象，整个应用只有一个store对象 */ // 引入创建store对象的方法 import { createStore } from \"redux\"; // 引入为Count组件服务的reducer对象 import countReducer from './count_reducer' // 创建store的同时，指定为store做事的reducer // 并默认暴露 export default createStore(countReducer) count_reducer.js 注意： redux中的state初始化是由store自动调用的 redux只负责管理state，加工和初始化state，不负责更新页面渲染，不能像setState一样，一改变state就自动重新渲染页面。 解决：用store.ubscribe去监听reducer中的状态，一旦有状态改变，那么就自己去调用render重新渲染组件。自己调用render的方法有：1.this.setState({})，改变state时，不改变任何东西，传递一个空对象，那么react也会重新调用render 2.用forceUpdate不修改状态也能强制更新组件：this.forceUpdate(); 结合17.2来看 /** * 该组件是创建一个为Count组件服务的reducer */ // 初始化方法一： const initState=0; // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState export default function countReducer(preState=initState,action){ const {type,data}=action; console.log(preState); // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState switch (type) { case 'increment': return preState+data; case 'decrement': return preState-data; default: return preState; } } // // 初始化方法二： // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // if(preState===undefined) // // 设置你想初始化的值 // preState=0; // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return preState; // } // } // // 初始化方法三： // // // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return 0; // } // // 不是increment也不是decrement，那就是初始化，所以直接返回要初始化的值，这里写的是0 // } Count.js store三大方法： getState()，获取状态 dispatch({type:xxx,data:xxx})，参数为action对象 subScribe(()=\u003e{})，一旦reducer中的状态有变化，就会触发里面的回调函数 import React, { Component } from 'react' import store from '../../redux/store'; ex","date":"2021-10-02","objectID":"/react/:19:3","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.4 react-redux理解 UI组件不与redux打交道，只负责界面，不能使用任何redux的api 容器组件只做两件事：1.传递redux中的状态给UI组件 2.传递操作redux状态的方法给UI组件，让UI组件不直接与redux交互 1. 连接容器组件与UI组件 新建一个容器组件，一般放在containers文件夹中 删掉原UI组件中的有关与redux交互的东西 npm install react-redux 连接UI组件和容器组件 渲染到页面的是容器组件，由于容器组件中包含UI组件，所以渲染的同时会将UI组件也渲染到页面，所以App.js中应该渲染的是容器组件 容器组件自身引入redux是引入的store，但是它自身不能引入store，所以需要在容器组件的父组件中（例子中为App.js）以props形式将store传给容器组件 记得暴露容器组件 2.react-redux的基本使用 使用容器组件与redux进行交互时，redux中的状态改变时，会自动重新渲染页面，不需要监听redux状态改变，手动去重新渲染页面 connect第一次调用，即第一个括号中的参数作用是向UI组件传东西，参数名最好固定，参数必须为函数，且第一个参数函数表示传递状态给UI组件，第二个参数函数表示传递操作状态的方法给UI组件，函数的返回值都要为一个对象，对象中的属性名作为UI组件的props中的key，对象中的属性值作为UI组件的props中的value 由于第一个函数参数固定是传递状态的，所以默认可以接收到state状态，不需要通过store.getState()方法去获取状态 由于第二个函数参数固定是传递操作状态的方法的，那么一定会使用store.dispatch(action)方法，所以默认可以接收到dispatch方法，不需要通过store.dispatch去获取 App.js import React, { Component } from 'react' import Count from './containers/Count' import store from './redux/store' export default class App extends Component { render() { return ( \u003cdiv\u003e {/* 由于容器组件自身不能引入store，所以将store以props形式传给容器组件 */} \u003cCount store={store}/\u003e \u003c/div\u003e ) } } 容器组件Count.js // 引入UI组件 import CountUI from '../components/Count' // 引入连接UI组件和容器组件、以及连接容器组件与redux的方法:connect import {connect} from 'react-redux' import {incrementAction, decrementAction, incrementAsyncAction} from '../redux/count_action' // mapStateToProps函数返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件的value————状态 // 由于第一个函数参数固定是传递状态的，所以默认可以接收到state状态，不需要通过store.getState()方法去获取状态 const mapStateToProps=(state)=\u003e{ return {count:state}; } // mapDispatchToProps函数返回的对象中的key就作为传递给UI组件props的key，value就作为传递给UI组件的value————操作状态的方法 // 由于第二个函数参数固定是传递操作状态的方法的，那么一定会使用store.dispatch(action)方法，所以默认可以接收到dispatch方法，不需要通过store.dispatch去获取 const mapDispatchToProps=(dispatch)=\u003e{ return {jia:data =\u003e dispatch(incrementAction(data)),jian:data =\u003e dispatch(decrementAction(data)), asyncAdd:(data,time) =\u003e dispatch(incrementAsyncAction(data,time))}; } // 创建一个容器组件并连接相应的UI组件 // connect第一次调用，即第一个括号中的参数作用是向UI组件传东西，参数名最好固定 // 参数必须为函数，且第一个参数函数表示传递状态给UI组件，第二个参数函数表示传递操作状态的方法给UI组件，函数的返回值都要为一个对象，对象中的属性名作为UI组件的props中的key，对象中的属性值作为UI组件的props中的value export default connect(mapStateToProps, mapDispatchToProps)(CountUI); UI组件Count.js import React, { Component } from 'react' export default class Count extends Component { increment = () =\u003e{ const {value} = this.selectNumNode; this.props.jia(value-0); } decrement = () =\u003e{ const {value} = this.selectNumNode; this.props.jian(value-0); } incrementIfOdd = () =\u003e{ const {value} = this.selectNumNode; if(this.props.count % 2 !== 0){ this.props.jia(value-0); } } incrementAsync = () =\u003e{ const {value} = this.selectNumNode; this.props.asyncAdd(value-0,3000); } render() { return ( \u003cdiv\u003e \u003ch2\u003e当前求和为：{this.props.count}\u003c/h2\u003e {/* 获取选中的结点 */} \u003cselect ref={c=\u003e{this.selectNumNode=c}}\u003e \u003coption value=\"1\"\u003e1\u003c/option\u003e \u003coption value=\"2\"\u003e2\u003c/option\u003e \u003coption value=\"3\"\u003e3\u003c/option\u003e \u003c/select\u003e\u0026nbsp; \u003cbutton onClick={this.increment}\u003e+\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.decrement}\u003e-\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.incrementIfOdd}\u003e当前求和为奇数时再加\u003c/button\u003e\u0026nbsp; \u003cbutton onClick={this.incrementAsync}\u003e异步加\u003c/button\u003e \u003c/div\u003e ) } } 3.总结 4.mapDispatchToProps精简版 mapDispatchToPropsc参数可以是一个对象，当为对象时，redux会自动调用dispatch，不需要我们手动去调用dispatch 容器组件：Count // 引入UI组件 import CountUI from '../components/Count' // 引入连接UI组件和容器组件、以及连接容器组件与redux的方法:connect import {connect} from 'react-redux' import {incrementAction, decrementAction, incrementAsyncAction} from '../redux/count_action' // 创建一个容器组件并连接相应的UI组件 // 1.可以直接将函数体写在参数中 // 2.mapDispatchToProps可以传一个函数，也可以传一个对象，当只传一个对象时，即action对象，redux会自动帮你调用dispatch，不需要自己去调用 export default connect( state =\u003e ({count:state}), //mapDispatchToProps的一般写法：传函数 // dispatch =\u003e ({ // jia:data =\u003e dispatch(incrementAction(data)), // jian:data =\u003e dispatch(decrementAction(data)), // asyncAdd:(data,time) =\u003e dispatch(incrementAsyncAction(data,time)) // }) //mapDispatchToProps的简写版：传对象 //跟jia:(data) =\u003e ({type:INCREMENT,data:data})作用一样，所以在UI组件中调用jia函数时传递参数传给了incrementAction函数，所以返回结果为一个action对象，当返回为action对象时，redux会自动帮你调用disp","date":"2021-10-02","objectID":"/react/:19:4","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.5 数据共享 redux要存多个组件存放在redux中的状态，那么redux存放的总状态应该为一个对象，每个组件对应一个key，组件中需要共享的状态即为value 如果redux总存储状态为一个对象，那么容器组件中的connect第一个参数中的返回的state即为一个对象，所以不能将这个总状态对象渲染到UI组件中，需要取对象中你需要的状态显示在UI组件上 store.js /** * 该模块专门用于暴露一个store对象，整个应用只有一个store对象 */ // 1.引入创建store对象的方法 // 2.引入第三方组件，允许store调用异步action函数 import { createStore, applyMiddleware, combineReducers} from \"redux\"; // 引入redux-thunk允许store调用异步action函数 import thunk from 'redux-thunk' // 引入为Count组件服务的reducer对象 import countReducer from './reducers/count' // 引入为Person组件服务的reducer对象 import personReducer from './reducers/person' // redux中存放的总状态为一个对象，combineReducers就是将对象参数转化为redux中的总状态 // he:countReducer表示：he代表Count组件在redux中存放的状态，rens代表Person组件在redux中存放的状态 const allReducers = combineReducers({ he:countReducer, rens:personReducer }) // 创建store的同时，指定为store做事的reducer // 并默认暴露 // 需要将applyMiddleware函数作为创建store的第二个参数传递，一定要是第二个参数，并且将thunk作为参数传给applyMiddleware函数 export default createStore(allReducers,applyMiddleware(thunk)) reducers/count.js /** * 该模块是创建一个为Count组件服务的reducer */ import {INCREMENT, DECREMENT} from '../constant' // 初始化方法一： const initState=0; // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState export default function countReducer(preState=initState,action){ const {type,data}=action; console.log(preState); // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState switch (type) { case INCREMENT: return preState+data; case DECREMENT: return preState-data; default: return preState; } } // // 初始化方法二： // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // if(preState===undefined) // // 设置你想初始化的值 // preState=0; // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return preState; // } // } // // 初始化方法三： // // // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return 0; // } // // 不是increment也不是decrement，那就是初始化，所以直接返回要初始化的值，这里写的是0 // } reducers/person.js // 引入type变量 import {ADD_PERSON} from '../constant' import {nanoid} from 'nanoid' const initPerson = [{id:nanoid(),name:'张三',age:19}]; export default function personReducer(preState=initPerson,action){ const {type,data} = action; switch (type) { case ADD_PERSON: return [data,...preState] default: return preState } } constant.js /** * 该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错 */ // Count组件进行加法运算的type export const INCREMENT = 'increment'; // Count组件进行减法运算的type export const DECREMENT = 'decrement'; // Person组件中添加人的type export const ADD_PERSON = 'add_person' actions/count.js /** * * 该模块专门为Count组件创建action对象 * */ import {INCREMENT, DECREMENT} from '../constant' // 箭头函数体中，如果只有一行代码，并且是返回之，那么可以省略{}和return，但是如果返回的是一个对象那么()=\u003e{xxx:xxx}会报错，因为会把这个大括号解析为是一个代码块，而不是对象外面的大括号。 // 方法一：加上{}和return // const incrementAction = (data) =\u003e {return {type:'increment',data:data}}; // 方法二：对象外面加一个小括号 // 分别暴露 // 该函数返回一个同步action：对象 export const incrementAction = (data) =\u003e ({type:INCREMENT,data:data}); export const decrementAction = (data) =\u003e ({type:DECREMENT,data:data}); // 该函数返回一个异步action：函数 export const incrementAsyncAction = (data,time) =\u003e { // 由于只要配置好了redux-thunk，store就会帮你调用这个函数，并且一般在异步action函数中都会分发同步action给store，所以异步action函数可","date":"2021-10-02","objectID":"/react/:19:5","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.6 纯函数 contains/Person/index.js // 引入type变量 import {ADD_PERSON} from '../constant' import {nanoid} from 'nanoid' const initPerson = [{id:nanoid(),name:'张三',age:19}]; export default function personReducer(preState=initPerson,action){ const {type,data} = action; // 1.这里往数组头部添加一个值，不适用数组自带的方法：unshift()是因为： // preState.unshift(data) 往数组头部添加一个数，但是preState这个数组的地址并没有改变，redux在检测状态更新时，在底层进行了一个浅比较，发现数组的地址没变，就认为这个状态并没有被更新，所以不会驱动页面重新渲染 // 所以一般react 和 redux很少使用数组自带的那些方法 //2. redux的reducer函数必须是一个纯函数，纯函数不能对参数进行修改，unshift是会修改原数组的值，所以preState.unshift(xxx)是会修改preState的值的 switch (type) { case ADD_PERSON: return [data,...preState] default: return preState } } ","date":"2021-10-02","objectID":"/react/:19:6","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.7 redux开发者工具 导入redux开发者工具 安装 npm install redux-devtools-extension 在store中引用 /** * 该模块专门用于暴露一个store对象，整个应用只有一个store对象 */ // 1.引入创建store对象的方法 // 2.引入第三方组件，允许store调用异步action函数 import { createStore, applyMiddleware, combineReducers} from \"redux\"; // 引入redux-thunk允许store调用异步action函数 import thunk from 'redux-thunk' // 引入为Count组件服务的reducer对象 import countReducer from './reducers/count' // 引入为Person组件服务的reducer对象 import personReducer from './reducers/person' // 使用redux开发者工具 import {composeWithDevTools} from 'redux-devtools-extension' const allReducers = combineReducers({ he:countReducer, rens:personReducer }) // 如果createStore没有第二个参数，那么直接将composeWithDevTools()作为第二个参数 // 如果createStore有第二个参数，那么将composeWithDevTools()作为第二个参数，并将原来的第二个参数作为composeWithDevTools的参数 export default createStore(allReducers,composeWithDevTools(applyMiddleware(thunk))) 做完上述三步就可以使用redux开发者工具了 ","date":"2021-10-02","objectID":"/react/:19:7","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.8 最终版 可以汇总reducer的事情放在单独的一个文件夹中，因为如果有很多个容器组件，那么就需要在store中import很多次，并且在combineReducers中定义很多个key、value。一般是将汇总reducer放在reducers文件夹中的index.js文件中 对象简写方法：{count:count,person:person}可以简写为只要属性值{count,person}，这表示count为对象的属性值，属性名也为count所以.count==count的 index.js import React from 'react'; import ReactDOM from 'react-dom'; import App from './App'; import store from './redux/store' import {Provider} from 'react-redux' ReactDOM.render( // Provider保证App组件中的所有用到store的地方（App中的所有容器组件），都会给它传store \u003cProvider store={store}\u003e \u003cApp/\u003e \u003c/Provider\u003e, document.getElementById('root') ) App.js import React, { Component } from 'react' import Count from './containers/Count' //引入Count容器组件 import Person from './containers/Person' //引入Person容器组件 export default class App extends Component { render() { return ( \u003cdiv\u003e \u003cCount/\u003e \u003chr/\u003e \u003cPerson/\u003e \u003c/div\u003e ) } } store.js /** * 该模块专门用于暴露一个store对象，整个应用只有一个store对象 */ // 1.引入创建store对象的方法 // 2.引入第三方组件，允许store调用异步action函数 import { createStore, applyMiddleware} from \"redux\"; // 引入redux-thunk允许store调用异步action函数 import thunk from 'redux-thunk' // 使用redux开发者工具 import {composeWithDevTools} from 'redux-devtools-extension' // 引入汇总后的reducer import reducer from './reducers' // 如果createStore没有第二个参数，那么直接将composeWithDevTools()作为第二个参数 // 如果createStore有第二个参数，那么将composeWithDevTools()作为第二个参数，并将原来的第二个参数作为composeWithDevTools的参数 export default createStore(reducer,composeWithDevTools(applyMiddleware(thunk))) constant.js /** * 该模块是用于定义action对象中type类型的常量值，目的只有一个：便于管理的同时防止程序员单词写错 */ // Count组件进行加法运算的type export const INCREMENT = 'increment'; // Count组件进行减法运算的type export const DECREMENT = 'decrement'; // Person组件中添加人的type export const ADD_PERSON = 'add_person' reducers/count.js /** * 该模块是创建一个为Count组件服务的reducer */ import {INCREMENT, DECREMENT} from '../constant' // 初始化方法一： const initState=0; // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState export default function countReducer(preState=initState,action){ const {type,data}=action; // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState switch (type) { case INCREMENT: return preState+data; case DECREMENT: return preState-data; default: return preState; } } // // 初始化方法二： // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // if(preState===undefined) // // 设置你想初始化的值 // preState=0; // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return preState; // } // } // // 初始化方法三： // // // // 如果type为初始化，那么就初始化state为initState，下一次由组件触发函数发生时，获取到的参数preState就为初始化state值，所以可以直接给preState赋initState值 // // 参数中赋值表示如果preState为undefined，那么就会被赋值为initState，如果preState有值，那么就不会执行preState=initState // export default function countReducer(preState,action){ // const {type,data}=action; // // 使用switch直接按条件返回结果，由于当初始化时给preState设置了初始化state值，所以初始化时直接返回preState // switch (type) { // case 'increment': // return preState+data; // case 'decrement': // return preState+data; // default: // return 0; // } // // 不是increment也不是decrement，那就是初始化，所以直接返回要初始化的值，这里写的是0 // } reducers/person.js // 引入type变量 import {ADD_PERSON} from '../constant' import {nanoid} from 'nanoid' const initPerson = [{id:nanoid(),name:'张三',age:19}]; export default function personReducer(preState=initPerson,action){ const {type,data} = action; switch (type) { case ADD_PERSON: return [data,...preState] default: return preState } } reducers/index.js import {combineReducers} from \"redux\"; // 引入为Count组件服务的reducer对象 import count from '../reducers/count' // 引入为Person组件服务的reducer对象 import persons from '../reducers/person' // 汇总所有的reducer变成一个总reducer // {count:c","date":"2021-10-02","objectID":"/react/:19:8","tags":["React"],"title":"React","uri":"/react/"},{"categories":["React"],"content":"17.9 项目打包运行 项目一般是打包成静态资源给后端服务器去部署的，但是由于现在没有服务器，可以借助一个包serve，指定某个文件夹，然后开启一个小型服务器 全局安装serve包,npm install serve -g 将项目打包：npm run build 将build作为服务器根目录，开启一个服务器：serve build 如果serve build报错，原因是：无法加载文件 D:\\nvm\\v12.16.0\\node_global\\serve.ps1，因为在此系统上禁止运行脚本。 解决方法： 使用管理员权限打开工具软件（如VScode） 命令行执行：get-ExecutionPolicy，得到结果为Restricted，表示禁止状态 命令行执行：set-ExecutionPolicy RemoteSigned 再次执行命令：get-ExecutionPolicy，结果显示为RemoteSigned 执行serve build,运行成功。 成功后直接访问5000 运行serve build 报错；serve : 无法将“serve”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次 解决方法： 使用yarn语法进行服务器安装yarn add serve，安装完毕后执行yarn serve build即可成功 ","date":"2021-10-02","objectID":"/react/:19:9","tags":["React"],"title":"React","uri":"/react/"},{"categories":["Docker"],"content":"DockerDeploy","date":"2021-08-18","objectID":"/dockerdeploy/","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"使用Dockers部署若依项目 ","date":"2021-08-18","objectID":"/dockerdeploy/:0:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"1、先进行docker安装 ","date":"2021-08-18","objectID":"/dockerdeploy/:1:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"2、安装mysql 在执行命令之前，先在服务器上创建好对应的文件目录，在执行命令，否则会报错！！！！ docker run -p 3307:3306 --name mysql01 -v /home/westbrook/mysql/log:/var/log/mysql \\ -v /home/westbrook/mysql/conf/my.cnf:/etc/mysql/my.cnf \\ -v /home/westbrook/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 -d mysql:5.7.33 执行成功后 注意：如果第一次直接执行该命令，它会自动的把`mysql/conf`下的my.cnf配置文件创建成为一个目录，会产生报错，需要你手动删除该目录后重建一个配置文件 开启远程连接时需要进行以下操作： 1、先查看用户信息 docker exec -it mysql01 /bin/bash select host,user,plugin,authentication_string from mysql.user; 备注：host为 % 表示不限制ip ，localhost表示本机使用 plugin非mysql_native_password 则需要修改密码 2、如果是8.0版本以上还需要修改加密规则，而我采用的是5.7，所以不需要修改，直接执行以下命令即可 flush privileges; ","date":"2021-08-18","objectID":"/dockerdeploy/:2:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"3、安装Toomcat docker run --name tomcat01 -p 8081:8080 -d tomcat 执行命令成功以后，去本机访问时，发现资源未找到，这就是我们常说的一个问题，可以进容器查看 进入容器可以看到有一个webapps.dist文件夹，我们tomcat所需要的文件全部存放在其中，而不是存放在webapps目录下面 先将两个文件server.xml和tomcat-users.xml复制过去为后面做映射做准备 docker cp bb50d6e13752:/usr/local/tomcat/conf/server.xml /home/westbrook/tomcat/conf docker cp bb50d6e13752:/usr/local/tomcat/conf/tomcat-users.xml /home/westbrook/tomcat/conf 然后清除之前运行起来的tomcat01 # 先停止运行 docker stop tomcat01 # 再移除tomcat01 docker rm tomcat01 拉取tomcat镜像并运行 docker run --name tomcat01 -p 8081:8080 -v /home/westbrook/tomcat/webapps:/usr/local/tomcat/webapps \\ -v /home/westbrook/tomcat/conf/server.xml:/usr/local/tomcat/conf/server.xml \\ -v /home/westbrook/tomcat/conf/tomcat-users.xml:/usr/local/tomcat/conf/tomcat-users.xml \\ -v /home/westbrook/tomcat/logs:/usr/local/tomcat/logs -d tomcat 现在再次访问还是访问不到 我们进入容器中，将webapps.dist文件中的资源拷贝到webapps中去 # 进入容器 docker exec -it tomcat01 /bin/bash # 进入webapps.dist目录中，将文件中的内容复制到webapps目录下 cp -r * ../webapps 因为这里进行了数据卷的挂载，实现了容器内与宿主机的数据绑定，所以再容器中将文件复制到了webapps中后，宿主机中的webapps文件也自动同步对应容器文件中的数据，所以可以访问成功！ ","date":"2021-08-18","objectID":"/dockerdeploy/:3:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"4、安装redis docker run -p 6380:6379 --name redis01 \\ -v /home/westbrook/redis/data:/data \\ -v /home/westbrook/redis/conf/redis.conf:/etc/redis/redis.conf \\ -d redis redis-server /etc/redis/redis.conf # -d以后台的方式启动；redis是要运行什么镜像；redis-server以后面这个配置文件路径的方式启动 ","date":"2021-08-18","objectID":"/dockerdeploy/:4:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"5、安装nginx docker run --name nginx01 -p 81:80 \\ -v /home/westbrook/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\ -v /home/westbrook/nginx/html:/usr/share/nginx/html \\ -v /home/westbrook/nginx/logs:/var/log/nginx \\ -d nginx 注意：如果再拉取镜像并运行的时候进行数据卷的挂载，虽然会成功，但是nginx会直接挂掉；原因是因为你在宿主机建立一个空的配置文件来进行映射是行不同的； 解决方法：先运行一个nginx镜像不进行数据卷的挂载，获取到它的配置文件后再次进行数据卷挂载 ","date":"2021-08-18","objectID":"/dockerdeploy/:5:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"6、前端部署 先进入若依前端目录，进入目录后再文件夹目录地方输入cmd 然后输入cnpm install安装依赖 在输入npm build:prod对项目进行打包，如果再命令行出现这种报错 那就去vs code中的package.json文件中找到build:prod命令，鼠标放在上面出现运行脚本后点击运行，让其开始打包 打包完成后生成了一个dist文件夹，将其拷贝到服务器上/home/westbrook/nginx/html目录下 同时进入服务器该/home/westbrook/nginx/conf目录下，编辑nginx配置文件 server { listen 80; server_name 192.168.167.48; #charset koi8-r; #access_log logs/host.access.log main; location / { root /usr/share/nginx/html/dist; index index.html index.htm; } } 最后重启nginx容器即可！docker restart nginx01 ","date":"2021-08-18","objectID":"/dockerdeploy/:6:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Docker"],"content":"7、部署后端 打开若依项目，先修改resources目录下的logback.xml文件 然后再修改application-druid.yml文件中数据库配置 再修改application.yml文件中关于redis配置以及路径配置 如果想要打jar包，克隆下来后直接运行就可以了 如果想打war包就得进行一些修改 首先修改pom.xml文件，引入tomcat依赖将tomcat内置的依赖去掉，因为springboot自动集成了tomcat，打war包就得去掉。 然后继续修改pom.xml文件，将packaging修改成你所要打包对应的类型 后端还未部署起来，还在继续测试！！！ 后端打jar包时运行一直报数据库错误 ","date":"2021-08-18","objectID":"/dockerdeploy/:7:0","tags":["DockerDeploy"],"title":"DockerDeploy","uri":"/dockerdeploy/"},{"categories":["Vuex"],"content":"Vuex","date":"2021-07-28","objectID":"/vue/","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"开始、简介 每一个Vuex应用的核心就是store（仓库）。”store“基本上就是一个容器，它包含着你的应用中绝大部分的状态。Vuex和单纯的全局对象有以下两点不同。 1、Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会得到高效的更新。 2、你不能直接改变store中的状态。改变store中的状态唯一的途径就是显示的提交（commit）mutation。这样是得我们可以方便的跟踪每一个状态的变化。 安装完Vuex之后，我们来创建一个store import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) const store = new Vuex.Store({ state: { count: 0 }, mutations: { increment (state) { state.count++ } } }) 现在，我们可以通过store.state来获取状态对象，以及通过store.commit方法触发状态变更： store.commit('increment') console.log(store.state.count) // -\u003e 1 为了在Vue组件中访问this.$store property，你需要为Vue实例提供创建好的store。Vuex提供了一个从根组件向所有子组件，以store选项的方式注入该store的机制： new Vue({ el: '#app', store: store, }) 为子组件或vue实例提供一个创建好的store。 现在我们可以去子组件中调用一个方法实现状态的变更： methods: { increment() { this.$store.commit('increment') console.log(this.$store.state.count) } } 注意：我们通过提交mutation的方式，而非直接改变store.state.count，是因为我们星耀更明确地追踪到状态的变化。这个简单的约定能够让你的意图更加明显，这样在阅读代码的时候能更容易地理解应用内部的状态改变。 核心概念 ","date":"2021-07-28","objectID":"/vue/:0:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"State Vuex使用单一状态树，一个对象就包含了全部的应用层级状态。至此它便作为一个”唯一数据源“而存在。这样意味着，每一个应用将仅仅包含一个store实例 存储在Vuex中的数据和Vue实例中的data遵循相同的规则。例如状态对象必须是纯粹 (plain) 的。 ","date":"2021-07-28","objectID":"/vue/:1:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"在Vue组件中获得Vuex状态 由于Vuex的状态存储时响应式的，从store实例中读取状态最简单的方法就是在计算属性中返回某个状态： // 创建一个 Counter 组件 const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return store.state.count } } } 每当 store.state.count 变化的时候，都会重新请求计算属性，并且触发更新相关联的DOM 缺点：这种模式导致组件依赖全局状态单例。在模块化的构建系统中，在每个需要使用state的组件中需要频繁地导入。 Vuex通过store选项，提供了一种机制将状态从根组件”注入“到每一个子组件中（需要调用Vue.use(Vuex)） const app = new Vue({ el: '#app', // 把 store 对象提供给 “store” 选项，这可以把 store 的实例注入所有的子组件 store, components: { Counter }, template: ` \u003cdiv class=\"app\"\u003e \u003ccounter\u003e\u003c/counter\u003e \u003c/div\u003e ` }) 通过在根实例中注册 store 选项，该 store 实例会注入到根组件下的所有子组件中，且子组件能通过 this.$store 访问到。让我们更新下 Counter 的实现： const Counter = { template: `\u003cdiv\u003e{{ count }}\u003c/div\u003e`, computed: { count () { return this.$store.state.count } } } ","date":"2021-07-28","objectID":"/vue/:2:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Vuex"],"content":"ref ","date":"2021-07-28","objectID":"/vue/:3:0","tags":["Vuex"],"title":"Vue","uri":"/vue/"},{"categories":["Network"],"content":"Network","date":"2021-07-07","objectID":"/network/","tags":["Network"],"title":"Network","uri":"/network/"},{"categories":["Network"],"content":"计算机网络的概念 计算机网络：是一个将分散的、具有独立功能的计算机系统，通过通信设备与线路连接起来，由功能完善 的软件实现资源共享和信息传递的系统 计算机网络是互联的、自治的计算机集合 互联-互联互通 使用的就是通信链路 自治-无主从关系 计算机系统之间是相互独立的 ","date":"2021-07-07","objectID":"/network/:0:0","tags":["Network"],"title":"Network","uri":"/network/"},{"categories":["Linux"],"content":"Frp","date":"2021-07-06","objectID":"/frp/","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"配置FRP实现内网穿透 ","date":"2021-07-06","objectID":"/frp/:0:0","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"1、安装frp frp的作用 利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。 对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。 利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务（ps：例如在家里通过 ssh 访问处于公司内网环境内的主机） 说明 实现功能 ① 外网通过ssh访问内网机器（ps：主要验证实现此功能） ② 自定义绑定域名访问内网web服务 配置准备 ① 公网服务器1台（演示用机为CentOS系统） ② 内网服务器1台（演示用机为CentOS系统） ③ 公网服务器绑定域名1个（实现1-①功能不需要公网服务器绑定域名，1-②功能必须需要公网服务器绑定域名） ④ 内网服务器部署一个web服务，可以用tomcat模拟，没有测试。 先去官网下载frp：https://github.com/fatedier/frp/releases 下载完传到Linux服务器上，并且在/etc/local目录下创建frp文件夹，并且将frp解压至该文件下 mkdir /usr/local/frp cd frp tar -zxvf /root/frp_0.37.0_linux_amd64.tar.gz -C ./ 进入解压目录cd frp_0.13.0_linux_amd64，这里主要关注4个文件，分别是frpc、frpc.ini和frps、 frps.ini，**前者两个文件是客户端**所关注文件，**后者两个文件是服务端**所关注两个文件。 配置服务端（公网服务器），首先删掉frpc、frpc.ini两个文件，然后再进行配置，vi ./frps.ini [common] bind_port = 7000 #与客户端绑定的进行通信的端口 vhost_http_port = 7081 #访问客户端web服务自定义的端口号 保存然后启动服务，这是前台启动， ./frps -c ./frps.ini 后台启动命令为 nohup ./frps -c ./frps.ini \u0026 启动成功后的样子： 配置客户端（内网服务器），首先删掉frps、frps.ini两个文件,然后再进行配置，vi ./frpc.ini [common] server_addr = 192.168.167.227 # 公网服务器IP server_port = 7000 # 与服务端bind_port一致 # 公网通过ssh访问内部服务器 [ssh] type = tcp # 连接协议 local_ip = 192.168.167.117 # 内网服务器ip local_port = 22 # ssh默认端口号 remote_port = 7088 # 自定义的访问内部ssh端口号 # 公网访问内部web服务器以http方式 [web] type = http # 访问协议 local_prot = 8081 # 内部web服务的端口号 custom_domains = repo.clover.com # 所绑定的公网服务器域名，一级、二级域名都可以 保存然后执行启动，这是前台启动， ./frpc -c ./frpc.ini 后台启动命令为 nohup ./frpc -c ./frpc.ini \u0026 这种方法，我没有做成功，我换到使用隧道代理的方法上去了，以后有了计网的基础后，再来实践 这是隧道代理的信息 ","date":"2021-07-06","objectID":"/frp/:1:0","tags":["Frp"],"title":"Frp","uri":"/frp/"},{"categories":["Linux"],"content":"Environment","date":"2021-07-05","objectID":"/environment/","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"Linux编程环境和软件安装 ","date":"2021-07-05","objectID":"/environment/:0:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"1、安装JDK 去官网地址下载JDK：https://www.oracle.com/java/technologies/javase/javase-jdk8-downloads.html 第一步，先卸载掉服务器自带的openJDK，通过命令查看已安装的openJDK rpm -qa | grep java 然后将java开头的删除完毕即可 yum -y remove java-1.7.0-openjdk-1.7.0.141-2.6.10.5.el7.x86_64 ...... 也可以执行，一次删除，删完后可以再次查看一次 yum -y remove javapackages-tools.noarch 然后将/root目录下的jdk解压到/usr/local/java路径下，java文件夹是你自己创建的 cd /usr/local mkdir java tar -zxvf /root/jdk-8u161-linux-x64.tar.gz -C ./ 再去/etc/profile文件中配置环境变量 JAVA_HOME=/usr/local/java/jdk1.8.0_291 CLASSPATH=$JAVA_HOME/lib PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH 然后执行命令使配置文件生效 source /etc/profile 输入下面命令检查结果 java -version javac ","date":"2021-07-05","objectID":"/environment/:1:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"2、安装Node 先去官网下载node：https://nodejs.org/en/ 历史版本链接：https://nodejs.org/dist/ 先在/usr/local下创建一个node文件，然后将root目录下的node解压到当前node目录下 cd /usr/local/ mkdir node cd node tar -zxvf /root/node-v12.16.0-linux-x64.tar.gz -C ./ 解压完成后，去/etc/profile文件中配置环境变量 export PATH=/usr/local/node/node-v12.16.0-linux-x64/bin:$PATH 然后刷新文件 source /etc/profile 使用下面命令检查安装结果 node -v npm -v npx -v ","date":"2021-07-05","objectID":"/environment/:2:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"3、安装Maven 去官网下载Maven：http://maven.apache.org/ maven 下载地址：http://maven.apache.org/download.cgi maven 历史版本：https://archive.apache.org/dist/maven/maven-3/ 先去/opt目录下创建一个maven文件，然后将roo目录下的maven其解压到该文件中 cd /opt mkdir maven tar -zxvf /root/apache-maven-3.6.3-bin.tar.gz -C ./ 然后配置阿里的镜像 编辑修改 /opt/maven/apache-maven-3.6.3/conf/settings.xml文件 在\u003cmirrors\u003e\u003c/mirrors\u003e标签对⾥添加如下内容即可 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e 镜像配置完成后，去/etc/profile文件中配置环境变量 export MAVEN_HOME=/opt/maven/apache-maven-3.6.3 export PATH=$MAVEN_HOME/bin:$PATH 配置完环境变量，执行命令使配置文件生效 source /etc/profile 使用下面命令检查结果 mvn -v ","date":"2021-07-05","objectID":"/environment/:3:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"4、安装Redis 去官网下载Redis：https://redis.io/download 历史版本：http://download.redis.io/releases/ 先去/usr/local下创建一个redis文件，然后将root目录下的redis解压到该文件中 cd /usr/local/ mkdir redis cd redis tar -zxvf /root/redis-6.2.4.tar.gz -C ./ 解压完毕后，进入redis-6.2.4文件中执行下面命令 注意：如果你所装虚拟机为最小化介质安装，则需要先安装gcc，执行yum -install gcc后，才能执行下面命令，否则会报错 make \u0026\u0026 make install 将 REDIS 安装为系统服务并后台启动，进⼊ utils ⽬录，并执⾏如下脚本即可 cd utils/ ./install_server.sh 使用高版本的Redis的时候执行./install_server.sh，会报错 解决方法： 进入./install_server.sh文件中，对其编辑，将其中一段代码注释即可 再次执行./install_server.sh，即可成功，此处所有配置使用默认的 查看REDIS服务启动情况 systemctl status redis_6379.service 然后启动客户端进行测试 但是此时只能在本地访问，⽆法远程连接，因此还需要做部分设 设置允许远程连接 编辑redis配置文件 vim /etc/redis/6379.conf 将 bind 127.0.0.1 修改为 0.0.0.0 然后重启 Redis 服务即可： systemctl restart redis_6379.service 设置密码 编辑redis配置文件,并且找到如下内容，去掉注释，将foobared修改为⾃⼰想要的密码，保存即可，最后重启redis vim /etc/redis/6379.conf #requirepass foobared systemctl restart redis_6379.service 这样后续的访问需要先输⼊密码认证通过⽅可： ","date":"2021-07-05","objectID":"/environment/:4:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"5、安装Nginx 先去官网下载Nginx：http://nginx.org/en/download.html 先去/usr/local下创建一个nginx文件，然后将root目录下的nginx解压到该文件中 cd /usr/local/ mkdir nginx cd nginx tar -zxvf /root/nginx-1.18.0.tar.gz -C ./ 预先安装额外的依赖 yum -y install pcre-devel yum -y install openssl openssl-devel 编译安装Nginx cd nginx-1.17.10 ./configure make \u0026\u0026 make install 安装完成后，Nginx的可执⾏⽂件位置位于 /usr/local/nginx/sbin/nginx 启动Nginx 直接执行如下命令就可以了 /usr/local/nginx/sbin/nginx 如果想停⽌Nginx服务，可执⾏： /usr/local/nginx/sbin/nginx -s stop 如果修改了配置⽂件后想重新加载Nginx，可执⾏： /usr/local/nginx/sbin/nginx -s reload 注意其配置⽂件位于： /usr/local/nginx/conf/nginx.conf 浏览器验证启动情况 出现访问不了的问题有两个原因 是自己搭配的服务器，那就是看防火墙开了80端口没有 2.如果使用的是阿里或者腾讯云的要去网络安全组把80端口打开 执行下面命令打开防火墙的80端口 # 查看防火墙规则 firewall-cmd --list-all # 查询端口是否开放 firewall-cmd --query-port=8080/tcp # 开放80端口 firewall-cmd --permanent --add-port=80/tcp # 移除端口 firewall-cmd --permanent --remove-port=8080/tcp # 重启防火墙（修改配置后要重启防火墙） firewall-cmd --reload # 参数解释： firewall-cmd：是Linux提供的操作firewall的一个工具 --permanent：表示设置为持久 --add-port：标识添加的端口 开放端口号访问的结果： ","date":"2021-07-05","objectID":"/environment/:5:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"6、安装Mysql 先去官网下载Mysql：https://dev.mysql.com/downloads/mysql/ 如果系统之前⾃带 Mariadb ，可以先卸载之。 ⾸先查询已安装的 Mariadb 安装包: rpm -qa|grep mariadb 将其均卸载之 # 使用该四条命令可删除全部 yum -y remove mariadb-server-5.5.56-2.el7.x86_64 yum -y remove mariadb-5.5.56-2.el7.x86_64 yum -y remove mariadb-devel-5.5.56-2.el7.x86_64 yum -y remove mariadb-libs-5.5.56-2.el7.x86_64 # 但是用该条命令可以直接删除完毕 yum -y remove mariadb-libs.x86_64 先去/usr/local下创建一个mysql文件，然后将root目录下的mysql解压到该文件中 cd /usr/local mkdir mysql cd mysql tar -zxvf /root/mysql-5.7.34-linux-glibc2.12-x86_64.tar.gz -C ./ mv mysql-5.7.34-linux-glibc2.12-x86_64/* . 创建MYSQL⽤户和⽤户组 groupadd mysql useradd -g mysql mysql 同时新建/usr/local/mysql/data⽬录，后续备⽤ 修改MYSQL⽬录的归属⽤户 chown -R mysql:mysql ./ 准备MYSQL的配置⽂件 在/etc⽬录下新建my.cnf⽂件 写入如下简化配置 [mysql] # 设置mysql客户端默认字符集 default-character-set=utf8 socket=/var/lib/mysql/mysql.sock [mysqld] skip-name-resolve #设置3306端⼝ port = 3306 socket=/var/lib/mysql/mysql.sock # 设置mysql的安装⽬录 basedir=/usr/local/mysql # 设置mysql数据库的数据的存放⽬录 datadir=/usr/local/mysql/data # 允许最⼤连接数 max_connections=200 # 服务端使⽤的字符集默认为8⽐特编码的latin1字符集 character-set-server=utf8 # 创建新表时将使⽤的默认存储引擎 default-storage-engine=INNODB lower_case_table_names=1 max_allowed_packet=16M 同时使⽤如下命令创建/var/lib/mysql⽬录，并修改权限： mkdir /var/lib/mysql chmod 777 /var/lib/mysql 正式开始安装MYSQL cd /usr/local/mysql ./bin/mysqld --initialize --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data 注意：记住上⾯打印出来的root的密码，后⾯⾸次登陆需要使用 复制启动脚本到资源⽬录 cp ./support-files/mysql.server /etc/init.d/mysqld 并修改/etc/init.d/mysqld ，修改其 basedir 和 datadir 为实际对应⽬录： basedir=/usr/local/mysql datadir=/usr/local/mysql/data 设置MYSQL系统服务并开启⾃启 首先增加mysqld服务控制脚本执⾏权限： chmod +x /etc/init.d/mysqld 同时将mysqld服务加⼊到系统服务： chkconfig --add mysqld 最后检查mysqld服务是否已经⽣效即可： chkconfig --list mysqld 这样就表明mysqld服务已经⽣效了，在2、3、4、5运⾏级别随系统启动⽽⾃动启动，以后可以直接使 ⽤service命令控制mysql的启停. 直接执行 service mysqld start 将Mysql的BIN目录加入到PATH环境变量 这样方便以后任意目录上都可以使用mysql提供的命令 编辑/etc/profile文件，在文件末尾处追加如下信息 export PATH=$PATH:/usr/local/mysql/bin 最后执行如下命令使环境变量生效 source /etc/profile 首次登录Mysql 以root账户登录Mysql，使用上文安装完成提示的密码进行登入 mysql -u root -p 接下来修改ROOT账户密码 在mysql的命令执行如下命令即可，密码可以换成你想设置的密码即可 alter user user() identified by \"xn123456\"; flush privileges; 设置远程主机登录 use mysql; update user set user.Host='%' where user.User='root'; flush privileges; ","date":"2021-07-05","objectID":"/environment/:6:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"6.1、在Linux中创建数据库并导入 在连接终端上执行命令 create database XXXXX; 执行命令 show database; 查看是否有XXXXX数据库 执行命令source /xxx/xxx.sql，找到对应路径下的sql文件 ","date":"2021-07-05","objectID":"/environment/:6:1","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"7、安装Tomcat ","date":"2021-07-05","objectID":"/environment/:7:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"8、安装Zookeeper 去官网下载Zookeeper：http://zookeeper.apache.org/releases.html 先在/usr/local下创建一个zookeeper文件，然后将root目录下的zookeeper解压到当前zookeeper目录下 cd /usr/local/ mkdir zookeeper cd zookeeper tar -zxvf /root/zookeeper-3.4.9.tar.gz -C ./ 解压完成后，进入zookeeper目录下的conf cp zoo_sample.cfg zoo.cfg vim zoo.cfg 修改zoo.cfg文件，加入以下两个 dataDir=/usr/local/zookeeper-3.4.9/data dataLogDir=/usr/local/zookeeper-3.4.9/logs 进入bin目录 ./zkServer.sh start ./zkServer.sh stop ./zkServer.sh restart ./zkServer.sh status 启动Cli，执行成功后得到以下响应 ","date":"2021-07-05","objectID":"/environment/:8:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Linux"],"content":"9、安装Nacos 官网下载 先去/opt目录下创建一个nacos文件，然后将roo目录下的nacos其解压到该文件中 cd /opt mkdir nacos tar -zxvf /root/nacos-server-1.1.4.tar.gz _C ./ ","date":"2021-07-05","objectID":"/environment/:9:0","tags":["Environment"],"title":"Environment","uri":"/environment/"},{"categories":["Netty"],"content":"Netty","date":"2021-07-04","objectID":"/netty/","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"1、Netty的介绍 1、Netty是由JBOSS提供的一个Java开源框架，现为Github上的独立项目 2、Netty是一个异步的、基于事件驱动的网络应用框架，用以快速开发高性能、高可靠性的网络IO程序 基于事件驱动：比如一个网页中有一个按钮，当你点击时会触发一个事件，这个事件就会去调用一个函数 3、Netty主要针对在TCP协议下，面向Clients端的高并发应用，或者Peer-to-Peer场景下的大量数据持续传输的应用。 4、Netty本质是一个NIO框架，适用于服务器通讯相关的多种应用场景 5、要透彻理解Netty，需要先学习NIO，这样才能阅读Netty源码 ","date":"2021-07-04","objectID":"/netty/:1:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2、BIO ","date":"2021-07-04","objectID":"/netty/:2:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.1、I/O模型基本说明 I/O模型简单理解：就是用什么样的通道进行数据的发送和接收，很大程度上决定了程序通信的性能 Java共支持3种网络编程模型I/O模型：BIO、NIO、AIO Java BIO：同步并阻塞(传统阻塞型)，服务器实现模式为一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销 Java NIO：同步非阻塞，服务器实现模式为一个线程处理多个请求(连接)，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求就进行处理 5.Java AIO(NIO.2)：异步非阻塞，AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程去处理，一般适用于连接数较多且连接时间较长的应用 ","date":"2021-07-04","objectID":"/netty/:2:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.2、I/O模型适用场景 BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前唯一选择，但是程序简单易理解。 NIO方式适用于连接数目多且连接比较短(轻操作)的架构，比如聊天服务器，弹幕系统，服务器间通讯等。编程比较复杂，JDK1.4开始支持。 AIO方式适用于连接数目多且连接比较长(重操作)的架构，比如相册服务器，充分调用操作系统参与并发操作，编程比较复杂，JDK7开始支持。 ","date":"2021-07-04","objectID":"/netty/:2:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.3、BIO基本介绍 Java BIO就是传统的java io编程，其相关的类和接口在java.io BIO(blocking I/O)：同步阻塞，服务器实现模式为一个连接对应一个线程，即客户端有连接请求时服务端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善(实现多个客户连接服务器) ","date":"2021-07-04","objectID":"/netty/:2:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.4、BIO工作机制 服务器端启动一个ServerSocket 客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通信 客户端发出请求后，先咨询服务器是否有线程响应，如果没有则等待，或者被拒绝 如果有响应，客户端线程会等待请求结束后，再继续执行 ","date":"2021-07-04","objectID":"/netty/:2:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.5、BIO应用实例 实例说明 使用BIO模型编写一个服务器端，监听6666端口，当有客户端连接时，就启动一个线程与之通讯 要求使用线程池机制改善，可以连接多个客户端 服务器端可以接受客户端发送的数据(telnet方式即可) package com.clover.bio; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class BIOServer { public static void main(String[] args) throws IOException { // 线程池机制 //思路 //1.创建一个线程池 //2.如果有客户端连接，就创建一个线程，与之通信(单独写一个方法) ExecutorService newCachedThreadPool = Executors.newCachedThreadPool(); // 创建ServerSocket ServerSocket serverSocket = new ServerSocket(6666); System.out.println(\"服务器启动了\"); while(true){ // 监听，等待客户端连接 System.out.println(\"线程信息 id =\" + Thread.currentThread().getId() + \"名字=\" + Thread.currentThread().getName()); System.out.println(\"等待连接.........\"); final Socket socket = serverSocket.accept(); System.out.println(\"连接到一个客户端\"); // 连接到一个客户端就创建一个线程，与之通信(单独写一个方法) newCachedThreadPool.execute(new Runnable() { // 我们可以重写这个方法 @Override public void run() { // 可以和客户端通讯 handler(socket); } }); } } // 编写一个handler方法和客户端通讯 public static void handler(Socket socket){ try { System.out.println(\"线程信息 id =\" + Thread.currentThread().getId() + \"名字=\" + Thread.currentThread().getName()); byte[] bytes = new byte[1024]; // 通过socket获取输入流 InputStream inputStream = socket.getInputStream(); // 循环读取客户端发送的数据 while(true){ System.out.println(\"线程信息 id =\" + Thread.currentThread().getId() + \"名字=\" + Thread.currentThread().getName()); System.out.println(\"read.........\"); int read = inputStream.read(bytes); if(read != -1){ // 不等于-1说明还未读完，还可以继续读取 // 输出客户端发送的数据 System.out.println(new java.lang.String(bytes,0,read)); }else{ break; } } } catch (Exception e) { e.printStackTrace(); } finally { System.out.println(\"关闭和client的连接\"); try { socket.close(); } catch (Exception e) { e.printStackTrace(); } } } } 还可以测试每一次客户端连接后对应的线程是否与它通讯的线程是否一样 这个代码中的accept和read函数会产生阻塞情况 连接过后 有连接的就会卡在read处，但是当你发送数据后又会阻塞再read处，这就会使性能很低 ","date":"2021-07-04","objectID":"/netty/:2:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"2.6、Java BIO问题分析 每个请求都需要创建独立的线程，与对应的客户端进行数据Read，业务处理，数据Write 当并发数较大时，需要创建大量线程来处理连接，系统资源占用比较大 连接建立后，如果当前线程暂时没有数据可读，则线程就会阻塞再Read操作上，造成线程资源浪费 ","date":"2021-07-04","objectID":"/netty/:2:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3、NIO ","date":"2021-07-04","objectID":"/netty/:3:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.1、Java NIO基本介绍 Java NIO全称Java non-blocking IO，是指JDK提供的新API。从JDK1.4开始，Java提供了一系列改进的输入/输出的新特性，被称为NIO(即New IO)，是同步非阻塞的。 NIO相关类都被放在Java.nio包及子包下，并且对原java.io包中的很多类进行改写。 NIO有三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector(选择器) NIO是面向缓冲区，或者面向块编程的。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动，这就增加了处理过程中的灵活性，使用它可以提供非阻塞式的高伸缩性网络。 Java NIO的非阻塞模式，使一个线程从某通道发送请求或者读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取，而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其它的事情。非阻塞写也是如此，一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情 通俗理解：NIO是可以做到用一个线程来处理多个操作的。假设有10000个请求过来，根据实际情况，可以分配50或者100个线程来处理。不像之前的阻塞IO那样，非得分配10000个。 HTTP2.0使用了多路复用技术，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。 ","date":"2021-07-04","objectID":"/netty/:3:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.2、NIO和BIO的比较 BIO是以流的方式处理数据，而NIO以块的方式处理数据，块I/O的效率比流I/O高很多 BIO是阻塞的，NIO则是非阻塞的 BIO基于字节流和字符流进行操作，而NIO基于Channel(通道) 和 Buffer(缓冲区) 进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择器)用于监听多个通道的事件(比如；连接请求，数据到达等)，因此使用单个线程就可以监听多个客户端通道 ","date":"2021-07-04","objectID":"/netty/:3:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.3、NIO三大核心原理示意图 Selector、Channel和Buffer的关系图说明 每个Channel都会对应一个Buffer 每个Selector都对应一个线程，一个线程对应多个Channel(连接) 该图反应了有三个Channel注册到了该Selector(使用程序解释) 程序切换到哪个Channel是由事件决定的，Event就是一个重要的概念 Selector会根据不同的事件，在各个通道上切换 Buffer就是一个内存块，底层是有一个数组 数据的读取写入是通过Buffer，这个和BIO有本质的区别，BIO中要么是输入流，或者是输出流，不能双向，但是NIO的Buffer是可以读也可以写，需要flip方法切换 Channel是双向的，可以返回底层操作系统的情况，比如Linux，底层的操作系统通道就是双向的 ","date":"2021-07-04","objectID":"/netty/:3:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.4、缓冲区(Buffer) 3.4.1、基本介绍 缓冲区(Buffer)：缓冲区本质上是一个可以读写数据的内存块，可以理解成是一个容器对象(含数组)，该对象提供了一组方法，可以更轻松地使用内存块，缓冲区对象内置了一些机制，能够跟踪和记录缓冲区的状态变化情况。Channel提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由Buffer。如图：(后面举例说明) 3.4.2、Buffer类及其子类 在NIO中，Buffer是一个顶层父类，它是一个抽象类，类的层级关系图 Buffer类定义了所有的缓冲区都具有的四个属性来提供关于其所包含的数据元素的信息 Capacity：容量，即可以容纳的最大数据量；在缓冲区创建的时候被设定并且不能改变 Limit：表示缓冲区的当前终点，不能对缓冲区超过极限的位置进行读写操作。且极限是可以修改的 Position：位置，下一个要被读或写的元素的索引，每次读写缓冲区数据时都会改变值，为下次读写做准备 Mark：标记 Buffer类相关方法 3.4.3、ByteBuffer 从前面可以看出对于Java中的基本数据类型(boolean除外)，都有一个Buffer类型与之相对应，最常用的自然是ByteBuffer类(二进制数据)，该类的主要方法如下 ","date":"2021-07-04","objectID":"/netty/:3:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.5、通道(Channel) 3.5.1、基本介绍 NIO的通道类似于流，但是有些区别如下 通道可以同时进行读写，而流只能读或者写 通道可以实现异步读写数据 通道可以从缓冲区读数据，也可以写数据到缓冲区中 BIO中的Stream是单向的，例如FileInputStream对象只能进行读取数据的操作，而NIO中的通道(Channel)是双向的，可以读操作，也可以写操作 Channel在NIO中是一个接口public interface Channel extends Closeable{} 常用的Channel类有：FileChannel、DatagramChannel、ServerSocketChannel和SocketChannel 这里需要注意ServerSocketChannel和SocketChannel两个类 当有一个连接产生的时候，我们Server中的ServerSocketChannel会产生一个与该客户端对应的通道，通道类型为SocketChannel，而其真实的实现类型为SockerChannelImpl，然后再通过该通道与服务器进行通讯 FileChannel用于文件的数据读写，DatagramChannel用于UDP的数据读写，ServerSocketChannel和SocketChannel用于TCP的数据读写 3.5.2、FileChannel类 FileChannel主要用来对本地文件进行IO操作，常见的方法有 public int read (ByteBuffer dst) ，从通道读取数据并放入缓冲区中 public int write(ByteBuffer src) ，把缓冲区的数据写到通道中 public long transferFrom(ReadableByteChannel src,long position,long count) , 从目标通道中复制数据到当前通道 public long transferTo(long position,long count,WriteableByteChannel target) , 把数据从当前通道复制给目标通道 3.5.3、应用实例1-本地文件写数据 实例要求： 使用前面学习后的ByteBuffer(缓冲)和FileChannel(通道)，将\"hello,韋\"写入到file01.txt中 文件不存在就创建 (一个汉字3个字节) package com.clover.nio; import java.io.FileOutputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class NIOFileChannel01 { public static void main(String[] args) throws Exception{ String str = \"hello,韋\"; //创建一个输出流-\u003e然后获取内置channel FileOutputStream fileOutputStream = new FileOutputStream(\"H:\\\\file01.txt\"); //通过FileOutputStream获取对应的FileChannel //这个FileChannel真实类型为FileChannelImpl FileChannel fileChannel = fileOutputStream.getChannel(); //创建一个缓冲区 ByteBuffer ByteBuffer byteBuffer = ByteBuffer.allocate(1024); //将数据放入缓冲区中 byteBuffer.put(str.getBytes()); //数据写入完毕后要将buffer反转 byteBuffer.flip(); // 将缓冲区数据写入fileChannel fileChannel.write(byteBuffer); //因为fileChannel中封装了Java的输出流，最终写入文件中也是通过流写入，所以最后需要关闭 fileOutputStream.close(); } } 3.5.4、应用实例2-本地文件读写数据 实例要求： 使用前面学习后的ByteBuffer(缓冲)和FileChannel(通道)，将file01.txt中的数据读入到程序，并显示再控制台屏幕 假定文件已存在 package com.clover.nio; import java.io.File; import java.io.FileInputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class NIOFileChannel02 { public static void main(String[] args) throws Exception { //创建一个文件的输入流-\u003e然后获取内置channel File file = new File(\"H:\\\\file01.txt\"); FileInputStream fileInputStream = new FileInputStream(file); //通过fileInputStream获取对应的channel FileChannel fileChannel = fileInputStream.getChannel(); //创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); //将通道中的数据向缓冲区中写入 fileChannel.read(byteBuffer); //将byteBuffer的字节数据转成String System.out.println(new String(byteBuffer.array())); fileInputStream.close(); } } 3.5.5、应用实例3-使用一个Buffer完成文件读取、写入 实例要求： 使用FIleChannel(通道)和方法read,write，完成文件的拷贝 拷贝一个文本文件 1.txt，放在项目下即可 package com.clover.nio; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.nio.ByteBuffer; import java.nio.channels.FileChannel; public class NIOFileChannel03 { public static void main(String[] args) throws Exception { // 创建一个文件 File file = new File(\"H:\\\\1.txt\"); FileInputStream fileInputStream = new FileInputStream(file); // 通过文件输入流获取channel FileChannel fileInputStreamChannel = fileInputStream.getChannel(); // 创建一个输出流，读取数据 FileOutputStream fileOutputStream = new FileOutputStream(\"H:\\\\2.txt\"); // 获取对应的channel FileChannel fileOutputStreamChannel = fileOutputStream.getChannel(); // 创建一个缓冲区 ByteBuffer byteBuffer = ByteBuffer.allocate((int) file.length()); while (true){ // 这里有一个重要操作，一定不能忘记 byteBuffer.clear(); // 清空buffer // 将通道数据写入缓冲区 int read = fileInputStreamChannel.read(byteBuffer); if (read == -1){ break; } // buffer写入完数据后要反转为后面从buffer读取数据做准备 byteBuffer.flip(); // 将缓冲区数据读取到通道中 fileOutputStreamChannel.write(byteBuffer); } // 关闭相关的流 fileInputStream.close(); fileOutputStream.close(); } } 3.5.6、应用实例4-拷贝文件transferFrom方法 实例要求： 使用FileChannel(通道)和方法 transferFrom，完成文件的拷贝 拷贝一张图片 package com.clover.nio; import java.io.FileInputStream; import java.io.FileOutputStream; import java.nio.channels.FileChannel; public class NIOFileChannel04 { public static void main(String[] args) ","date":"2021-07-04","objectID":"/netty/:3:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.6、Selector(选择器) 3.6.1、基本介绍 Java的NIO，用非阻塞的IO方式。可以用一个线程，处理多个的客户端连接，就会使用到Selector(选择器) Selector能够检测到多个注册的通道上是否有事件发生(注意：多个Channel以事件的方式可以注册到同一个Selector)，如果有事件发生，便获取事件然后针对每个事件进行相应的处理。这样就可以只用一个单线程去管理多个通道，也就是管理多个连接和请求。 只有在通道真正有读写事件发生时，才会进行读写，就大大的减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程 避免了多线程之间的上下文切换导致的开销 3.6.2、Selector示意图和特点说明 特点再说明： Netty的IO线程NioEventLoop聚合了Selector(选择器，也叫多路复用器),可以同时并发处理成百上千个客户端的连接 当线程从某客户端Socket通道进行读写数据时，若没有数据可读写时，该线程可以进行其它任务。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以单独的线程可以管理多个输入和输出通道 由于读写操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起 一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO，一个连接一个线程模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。 3.6.3、Selector类相关的方法 Selector类是一个抽象类，常用方法和说明如下： public abstract class Selector implements Closeable{ public static Selector open(); // 得到一个选择器对象 public int select(long timeout); // 监控所有注册的通道，当其中有IO操作可以进行时，将对应的SelectionKey加入到内部集合中并返回，参数用来设置超时时间 public Set\u003cSelectionKey\u003e selectedKeys(); // 从内部集合中得到所有的SelectionKey } 注意事项 1. NIO中的ServerSocketChannel功能类似ServerSocket，SocketChannel功能类似Socket 2. Selector相关方法说明 selector.select(); //阻塞 selector.select(1000); // 阻塞1000毫秒，在1000毫秒后返回 selector.wakeup(); // 唤醒selector selector.selectNow(); // 不阻塞，立马返还 ","date":"2021-07-04","objectID":"/netty/:3:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.7、NIO非阻塞网络编程原理分析图 NIO非阻塞网络编程相关的(Selector、SelectionKey、ServerSocketChannel和SocketChannel)关系梳理图 对上图说明： 当客户端连接时，会通过ServerSocketChannel得到SocketChannel Selector进行监听，使用select方法，可以使用阻塞的也可以使用非阻塞的，返回有事件发生的通道的个数 将SocketChannel注册到Selector上，使用register(Selector sel,int ops)，一个selector上可以注册多个SocketChannel 注册后返回一个SelectionKey，会和该Selector关联该key被Selector管理起来，做成一个集合的形式 进一步得到各个SelectionKey(有事件发生) 再通过SelectionKey反向获取SocketChannel，通过channel()方法 可以通过得到的channel，完成业务处理 ","date":"2021-07-04","objectID":"/netty/:3:7","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.8、NIO非阻塞网络编程快速入门 案例要求： 编写一个NIO入门案例，实现服务器端和客户端之间的数据简单通讯(非阻塞) 目的：理解NIO非阻塞网络编程机制 服务器端： package com.clover.nio; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; import java.util.Set; public class NIOServer { public static void main(String[] args) throws Exception{ // 创建ServerSocketChannel -\u003e ServerSocket ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 得到一个Selector对象 Selector selector = Selector.open(); // 绑定一个端口6666，在服务器端监听 serverSocketChannel.socket().bind(new InetSocketAddress(6666)); // 设置为非阻塞 serverSocketChannel.configureBlocking(false); // 把 serverSocketChannel 注册到 selector 关心事件为OP_ACCEPT serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT); // 循环等待客户端连接 while (true){ // 这里我们等待1秒，如果没有事件发生，就返回 if (selector.select(1000) == 0){ // 没有事件发生 System.out.println(\"服务器等待了1秒，无连接\"); continue; } // 如果返回的 \u003e0,就获取到相关的selectionKey集合 // 1.如果返回的 \u003e0,表示已经获取到关注的事件 // 2.selector.selectedKeys() 返回关注事件的集合 // 3.通过 selectionKeys 反向获取通道 Set\u003cSelectionKey\u003e selectionKeys = selector.selectedKeys(); // 遍历\u003cSelectionKey\u003e ，使用迭代器遍历 Iterator\u003cSelectionKey\u003e keyIterator = selectionKeys.iterator(); while (keyIterator.hasNext()){ // 获取到SelectionKey SelectionKey key = keyIterator.next(); //根据key对应的通道发生的事件做相应的处理 if (key.isAcceptable()){ // 如果是 OP_ACCEPT，有新的客户端连接 // 给该客户端生成一个SocketChannel // 这里使用 accept 为什么不会产生阻塞？ 因为你原本的判断就已经判定了它时处于哪一个事件，自然不会在去等待 SocketChannel socketChannel = serverSocketChannel.accept(); System.out.println(\"客户端连接成功 生成了一个 socketChannel \" + socketChannel.hashCode()); socketChannel.configureBlocking(false); // 将 socketChannel 注册到selector，关注事件为 OP_READ，同时给该 socketChannel 关联一个Buffer /* * 这里需要注意： * 如果你在将 socketChannel 注册到selector时，给其关联一个buffer分配空间过大时，在 * 后面使用输出语句进行输出时，没有字节填充时，后面会默认输出乱码 */ socketChannel.register(selector,SelectionKey.OP_READ, ByteBuffer.allocate(9)); } if (key.isReadable()){ // 发生 OP_READ 事件 // 通过key反向获取到对应的channel SocketChannel channel = (SocketChannel)key.channel(); // 获取到该Channel关联的Buffer ByteBuffer buffer = (ByteBuffer)key.attachment(); // 将通道中的数据读取到Buffer channel.read(buffer); System.out.println(\"从客户端发送的数据\" + new String(buffer.array())); } // 手动从集合中移除当前的 SelectionKey ，防止重复操作 keyIterator.remove(); } } } } 客户端： package com.clover.nio; import jdk.nashorn.internal.ir.CallNode; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SocketChannel; public class NIOClient { public static void main(String[] args) throws Exception{ // 得到一个网络通道 SocketChannel socketChannel = SocketChannel.open(); // 设置非阻塞 socketChannel.configureBlocking(false); // 提供服务器端的ip 和 端口 InetSocketAddress inetSocketAddress = new InetSocketAddress(\"127.0.0.1\", 6666); // 连接服务器 if (!socketChannel.connect(inetSocketAddress)){ while (!socketChannel.finishConnect()){ System.out.println(\"因为连接需要事件，客户端不会阻塞，可以做其它工作\"); } } // 如果连接成功，就发送数据‘ String str = \"hello,韋\"; // 使用这种方式就不需要再去指定字节大小了，也不再浪费空间大小 ByteBuffer buffer = ByteBuffer.wrap(str.getBytes()); // 发送数据,将Buffer数据写入channel socketChannel.write(buffer); System.in.read();// 使代码停止在此 } } 总结： 1.服务器端创建serverSocketChannel，并设置监听端口和非阻塞 2.得到一个selector对象，并把serverSocketChannel注册到selector上，并设置关心事件为OP_ACCEPT 3.当客户端有连接产生时，先获取到关注的事件，在通过selector.selectedKeys() 返回关注事件的 集合(即注册到selector上key的集合)，并使用迭代器进行遍历 4.获取selectionKeys集合种的key来判断是什么事件，如果是连接事件，则用accept函数得到socketChannel，并将该 channel注册到selector上，同时设为非阻塞，并从集合种移除当前key，防止重复操作 5.如果监听到有事件发生，如果是读事件，则通过key获取到对应的channel，该channel与注册到selector上的channel是 一样的，读取完数据之后也要进行移除操作，防止重复操作 疑问 为什么进行第一次连接时，服务器端对应的serverSocketChannel注册到selector上得到一个key，而第二个新客户端连接时，与第一次的key一致，不是每次执行完都移除了嘛？ 解答： 因为当有连接事件产生时，监听器会监听到是什么事件，然后通过selector.selectedKeys()返回关注事件的集合(即注册 到selector上key的集合)，进行完连接事件后就会使用remove函数对当前key进行移除，因为使用的hasnext()方法，防止进 行重复操作，因为当前的移除操作执行完毕后，当前该次循环也就结束了，当再次执行连接事件时，又会调用 selector.selectedKeys()函数获取key的集合，所以serverSocketChannel对应的key是一致的 ","date":"2021-07-04","objectID":"/netty/:3:8","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.9、SelectionKey SelectionKey，表示Selector和网络通道的注册关系，共四种： int OP_ACCEPT：有新的网络连接可以accept，值为16 int OP_CONNECT：代表连接已经建立，值为8 int OP_READ：代表读写操作，值为1 int OP_WRITE：代表写操作，值为4 源码中 public static final int OP_READ = 1 « 0; public static final int OP_WRITE = 1 « 2; public static final int OP_CONNECT = 1 « 3; public static final int OP_ACCEPT = 1 « 4; SelectionKey相关方法 public abstract class SelectionKey { public abstract Selector selector();// 得到与之关联的Selector对象 public abstract SelectableChannel channel();//得到与之关联的通道 public final Object attachment();//得到与之关联的共享数据 public abstract SelectionKey interestOps(int ops);//设置或改变监听事件，比如：原本是监听连接事件，你可以将其改为监听读事件，这个根据需求来定 public final boolean isAcceptable();//是否可以accept public final boolean isReadable();//是否可以读 public final boolean isWriteable();//是否可以写 } ","date":"2021-07-04","objectID":"/netty/:3:9","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.10、ServerSocketChannel ServerSocketChannel在服务器端监听新的客户端Socket连接，产生一个SocketChannel 相关方法 public abstract class ServerSocketChannel extends AbstractSelectableChannel implements NetworkChannel{ public static ServerSocketChannel open();//得到一个ServerSocketChannel通道 public final ServerSocketChannel bind(SocketAddress local);//设置服务器端端口号 public final SelectableChannel configureBlocking(boolean block);//设置阻塞或非阻塞模式，取值false表示采用非阻塞模式 public abstract SocketChannel accept();//接受一个连接，返回代表这个连接的通道对象 public final SelectionKey register(Selector sel, int ops);//注册一个选择器并设置监听事件 } ","date":"2021-07-04","objectID":"/netty/:3:10","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.11、SocketChannel SocketChannel，网络IO通道，具体负责进行读写操作。NIO把缓冲区的数据写入通道，或者把通道里的数据读到缓冲区 相关方法 public abstract class SocketChannel extends AbstractSelectableChannel implements ByteChannel, ScatteringByteChannel, GatheringByteChannel, NetworkChannel { public static SocketChannel open();//得到一个Socket Channel通道 public fianl SelectableChannel configureBlocking(boolean block);// 设置阻塞或非阻塞模式，取值false表示采用非阻塞模式 public abstract boolean connect(SocketAddress remote);//连接服务器 public abstract boolean finishConnect();//如果上面的方法连接失败，接下来就要通过该方法完成连接操作 public int write(ByteBuffer src);//往通道里面写数据 public int read(ByteBuffer dst);//从通道里面读取数据 public final SelectionKey register(Selector sel,int ops,Object att);//注册一个选择器并设置监听事件，最后一个参数可以设置共享数据 public final void close();//关闭通道 } ","date":"2021-07-04","objectID":"/netty/:3:11","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.12、NIO网络编程应用实例-群聊系统 实例要求： 编写一个搞NIO群聊系统，实现服务器端和客户端之间的数据简单通讯(非阻塞) 实现多人群聊 服务器端：可以监测用户上线、离线，并实现消息转发功能 客户端：通过Channel可以无阻塞发送消息给其它所有用户，同时可以接受到其它用户发送的消息(由服务器转发得到) 目的：进一步理解NIO非阻塞网络编程 示意图 服务器端： package com.clover.nio.groupchat; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.*; import java.util.Iterator; public class GroupChatServer { // 定义属性 private Selector selector; private ServerSocketChannel listenChannel; private static final int PORT=6667; // 构造器 // 初始化工作 public GroupChatServer(){ try { // 得到选择器 selector = Selector.open(); // 得到ServerSocketChannel listenChannel = ServerSocketChannel.open(); // 绑定端口 listenChannel.socket().bind(new InetSocketAddress(PORT)); // 设置非阻塞模式 listenChannel.configureBlocking(false); // 将该listenChannel 注册到Selector listenChannel.register(selector, SelectionKey.OP_ACCEPT); } catch (IOException e){ e.printStackTrace(); } } // 监听 public void listen(){ try { // 循环处理 while(true){ int count = selector.select(); if(count \u003e 0){ // 有事件处理 // 遍历得到selectionKey集合 Iterator\u003cSelectionKey\u003e iterator = selector.selectedKeys().iterator(); while (iterator.hasNext()){ // 取出selectionKey SelectionKey key = iterator.next(); //根据key对应的通道发生的事件做相应的处理 if(key.isAcceptable()){ SocketChannel sc = listenChannel.accept(); sc.configureBlocking(false); // 将该sc注册到Selector sc.register(selector,SelectionKey.OP_READ); // 输出提示 System.out.println(sc.getRemoteAddress() + \"上线\"); } if (key.isReadable()){// 通道发送read事件，即通道是可读状态 // 处理读事件(专门写方法) readData(key); } // 手动从集合中移除当前的 SelectionKey ，防止重复操作 iterator.remove(); } } else { System.out.println(\"等待......\"); } } } catch (Exception e){ e.printStackTrace(); } finally{ } } // 读取客户端数据 通过对应的key获取到对应的通道 public void readData(SelectionKey key){ // 定义channel属性 SocketChannel channel = null; try { // 得到channel channel = (SocketChannel) key.channel(); // 创建Buffer ByteBuffer buffer = ByteBuffer.allocate(1024);//33 int count = channel.read(buffer); // 根据count的值做处理 if(count \u003e 0){ // 把缓冲区的数据转成字符串 String msg = new String(buffer.array()); // 输出该消息 System.out.println(\"from 客户端：\" + msg); // 向其它的客户端转发消息(去掉自己)，专门写一个方法来处理 sendInfoToOtherClients(msg,channel); } } catch (IOException e){ try { System.out.println(channel.getRemoteAddress() + \" 离线了....\"); // 取消注册 key.cancel(); // 关闭通道 channel.close(); } catch (IOException e1){ e1.printStackTrace(); } } } // 转发消息给其它客户端(通道) public void sendInfoToOtherClients(String msg,SocketChannel self) throws IOException{ System.out.println(\"服务器转发消息中..........\"); // 遍历 所有注册到Selector 上的 SocketChannel，并排除自身 for (SelectionKey key:selector.keys()){ // 通过key得到对应的 SocketChannel Channel targetChannel = key.channel(); // 排除自己 if (targetChannel instanceof SocketChannel \u0026\u0026 targetChannel != self){ // 转型 SocketChannel dest = (SocketChannel)targetChannel; // 将msg存储到buffer ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes()); // 将buffer的数据写入通道 dest.write(buffer); } } } public static void main(String[] args) { // 创建服务器对象 GroupChatServer groupChatServer = new GroupChatServer(); groupChatServer.listen(); } } 客户端： package com.clover.nio.groupchat; import java.io.IOException; import java.net.InetSocketAddress; import java.nio.ByteBuffer; import java.nio.channels.SelectionKey; import java.nio.channels.Selector; import java.nio.channels.SocketChannel; import java.util.Iterator; import java.util.Scanner; public class GroupChatClient { // 定义相关的属性 private final String HOST = \"127.0.0.1\"; // 服务器的IP private final int PORT = 6667; private Selector selector; private SocketChannel socketChannel; private String username; // 构造器,完成初始化工作 public GroupChatClient() throws IOException { selector = Selector.open(); // 连接服务器 socketChannel = SocketChannel.open(new InetSocketAddress(HOST,PORT)); // 设置非阻塞 socketChannel.configureBlocking(false); // 将channel注册到selector socketChannel.register(selector, SelectionKey.OP_READ); // 得到username username = socketChannel.getLocalAddress().toString(); System.out.println(username + \" is ok.....\"); } // 向服务器发送消息 public void sendInfo(Str","date":"2021-07-04","objectID":"/netty/:3:12","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.13、NIO与零拷贝 3.13.1、零拷贝基本介绍 零拷贝是网络编程的关键，很多性能优化都离不开。 在Java程序中，常用的零拷贝有mmap(内存映射)和sendFile。那么，他们在OS里面，到底是怎么样的一个设计？我们分析mmap和sendFile这两个零拷贝 另外我们看下NIO中如何使用零拷贝 3.13.2、传统IO 3.13.3、mmap优化 mmap通过内存映射，将文件映射到内核缓冲区，同时，用户空间可以共享内核空间的数据。这样，在进行网络传输时，就可以减少内核空间到用户控件的拷贝次数 mmap示意图 3.13.4、sendFile优化 Linux2.1版本提供了sendFile函数，其基本原理如下：数据根本不经过用户态，直接从内核缓冲区进入到Socket Buffer，同时，由于和用户态完全无关，就减少了一次上下文切换 示意图和小结 提示：零拷贝从操作系统角度看是没有CPU拷贝 Linux在2.4版本中，做了一些修改，避免了从内核缓冲区拷贝到Socket buffer的操作，直接拷贝到协议栈，从而再一次减少了数据拷贝，具体如下图 注意：这里其实有一次CPU拷贝kernel buffer -\u003e socket buffer，但是，拷贝的信息很少，比如length，offset，消耗低，可以忽略不计 3.13.5、零拷贝的再次理解 我们说零拷贝是从操作系统的角度来说的。因为内核缓冲器之间，没有数据是重复的(只有kernel buffer 有一份数据) 零拷贝不仅仅带来更少的数据复制，还能带来其它的性能又是，例如更少的上下文切换，更少的CPU缓存伪共享以及无CPU校验和计算 3.13.6、mmap和sendFile的区别 mmap适合小数据量读写，sendFile适合大文件传输 mmap需要4次上下文切换，3次数据拷贝；sendFile需要3次上下文切换，最少2次数据拷贝 sendFile可以利用DMA方式，减少CPU拷贝，mmap则不能(必须从内核拷贝到Socket缓冲区) ","date":"2021-07-04","objectID":"/netty/:3:13","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.14、零拷贝实例 案例要求： 使用传统的IO方法传递一个大文件 使用NIO零拷贝方式传递(transferTo)一个大文件 看看两种传递方式耗时时间分别是多少 3.14.1、传统IO方式 服务器端： package com.clover.nio.zerocopy; import java.io.DataInputStream; import java.net.ServerSocket; import java.net.Socket; public class OldIOServer { public static void main(String[] args) throws Exception { ServerSocket serverSocket = new ServerSocket(7001); while (true) { Socket socket = serverSocket.accept(); DataInputStream dataInputStream = new DataInputStream(socket.getInputStream()); try { byte[] byteArray = new byte[4096]; while (true) { int readCount = dataInputStream.read(byteArray, 0, byteArray.length); if (-1 == readCount) { break; } } } catch (Exception ex) { ex.printStackTrace(); } } } } 客户端： package com.clover.nio.zerocopy; import java.io.DataOutputStream; import java.io.FileInputStream; import java.io.InputStream; import java.net.Socket; public class OldIOClient { public static void main(String[] args) throws Exception { Socket socket = new Socket(\"localhost\", 7001); String fileName = \"protoc-3.6.1-win32.zip\"; InputStream inputStream = new FileInputStream(fileName); DataOutputStream dataOutputStream = new DataOutputStream(socket.getOutputStream()); byte[] buffer = new byte[4096]; long readCount; long total = 0; long startTime = System.currentTimeMillis(); while ((readCount = inputStream.read(buffer)) \u003e= 0) { total += readCount; dataOutputStream.write(buffer); } System.out.println(\"发送总字节数： \" + total + \", 耗时： \" + (System.currentTimeMillis() - startTime)); dataOutputStream.close(); socket.close(); inputStream.close(); } } 结果图： 3.14.2、transferTo 服务器端： package com.clover.nio.zerocopy; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.nio.ByteBuffer; import java.nio.channels.ServerSocketChannel; import java.nio.channels.SocketChannel; public class NewIOServer { public static void main(String[] args) throws Exception{ ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); InetSocketAddress inetSocketAddress = new InetSocketAddress(7001); ServerSocket serverSocket = serverSocketChannel.socket(); serverSocket.bind(inetSocketAddress); //创建Buffer ByteBuffer buffer = ByteBuffer.allocate(4096); while (true){ SocketChannel socketChannel = serverSocketChannel.accept(); int readCount = 0; while (-1 != readCount){ try { readCount = socketChannel.read(buffer); } catch (Exception e){ e.printStackTrace(); } // 将buffer倒带，因为这个buffer这次使用后下次还需使用 buffer.rewind();// 使 position = 0 mark=-1 作废 } } } } 客户端： package com.clover.nio.zerocopy; import java.io.FileInputStream; import java.net.InetSocketAddress; import java.nio.channels.FileChannel; import java.nio.channels.SocketChannel; public class NewIOClient { public static void main(String[] args) throws Exception{ SocketChannel socketChannel = SocketChannel.open(); socketChannel.connect(new InetSocketAddress(\"localhost\",7001)); String filename = \"protoc-3.6.1-win32.zip\"; // 得到一个文件channel FileChannel fileChannel = new FileInputStream(filename).getChannel(); // 准备发送 long startTime = System.currentTimeMillis(); // 在Linux下，一个transferTo 方法就可以完成传输 // 在windows下，一次调用transferTo只能发送8M文件，就需要分段传输文件，而且要注意传输位置 long transferCount = fileChannel.transferTo(0, fileChannel.size(), socketChannel); System.out.println(\"发送的总的字节数 =\" + transferCount + \" 耗时：\"+(System.currentTimeMillis()-startTime)); // 关闭通道 fileChannel.close(); } } 结果图： ","date":"2021-07-04","objectID":"/netty/:3:14","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.15、Java AIO基本介绍 JDK7引入了Asynchronous I/O，即AIO。在进行I/O编程中，常用到两种模式：Reactor和Proactor。Java 的NIO就是Reactor，当有时间触发时，服务器端得到通知，进行相应的处理 AIO即NIO2.0，叫做异步不阻塞的IO。即AIO引入异步通道的概念，采用了Proactor模式，简化了程序编写，有效的请求才启动线程，它的特点是先由操作系统完成后才通知服务端程序启动线程区处理，一般适用于连接数较多且连接时间较长的应用 目前AIO还没有广泛应用，Netty也是基于NIO，而不是AIO，因此我们就不详解AIO了，有兴趣的同学可以参考Java新一代网络编程模型AIO原理及Linux系统AIO介绍 ","date":"2021-07-04","objectID":"/netty/:3:15","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"3.16、BIO、NIO、AIO对比表 举例说明 同步阻塞：到理发店理发，就一直等理发师，知道轮到自己理发 同步非阻塞：到理发店理发，发现前面有其它人理发，给理发师说下，先干其它事情，一会过来看是否轮到自己 异步非阻塞：给理发师打电话，让理发师上门服务，自己干其它事情，理发师自己来家给你理发 ","date":"2021-07-04","objectID":"/netty/:3:16","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"4、Netty概述 ","date":"2021-07-04","objectID":"/netty/:4:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"4.1、原生NIO存在的问题 NIO的类库和API复杂，使用麻烦：需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等 需要具备其它的额外技能：要熟悉Java多线程编程，因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能编写出高质量的NIO程序 开发工作量和难度都非常大：例如客户端面临断连重连、网络闪断、半包读写、失败缓存、网络拥塞和异常流的处理等等 JDK NIO的BUG：例如臭名昭著的 Epoll Bug，它会导致Selector空轮询，最终导致CPU100%。直到JDK 1.7 版本该问题仍旧存在，没有被根本解决 ","date":"2021-07-04","objectID":"/netty/:4:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"4.2、Netty官网说明 Netty官网 Netty is an asynchronous event-driven network application framework for rapid development of maintainable high performance protocol servers \u0026 clients. ","date":"2021-07-04","objectID":"/netty/:4:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"4.3、Netty的优点 Netty对JDK自带的NIO的API进行了封装，解决了上述问题 设计优雅：适用于各种传输类型的统一API阻塞和非阻塞Socket；基于灵活且可扩展的事件模型，可以清晰的分离关注点；高度可定制的线程模型，单线程，一个或多个线程池 使用方便：详细记录的Javadoc，用户指南和实例；没有其它依赖项，JDK 5(Netty 3.x)或6 (Netty 4.x)就足够了 高性能、吞吐量更高：延迟耕地；减少资源消耗；最小化不必要的内存复制 安全：完整的SSL/TLS和StartTLS支持 社区活跃、不断更新、版本迭代周期端，发现的Bug可以被及时修复，同时，更多的性功能会被加入 ","date":"2021-07-04","objectID":"/netty/:4:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"4.4、版本说明 netty版本分别为netty3.x、netty4.x和netty5.x 因为netty5出现重大Bug，已经被官网废弃了，目前推荐使用的是Netty4.x的稳定版本 目前在官网可下载的版本netty3.x、netty4.0.x和netty4.1.x Netty下载地址 ","date":"2021-07-04","objectID":"/netty/:4:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5、Netty高性能框架设计 ","date":"2021-07-04","objectID":"/netty/:5:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.1、线程模型基本介绍 不同的线程模式，对程序的性能有很大影响，为了搞清楚Netty线程模式，我们来系统的讲解下各个线程模式，最后看看Netty线程模型有什么优越性 目前存在的线程模型有：传统阻塞I/O服务模型、Reactor模式 根据Reactor的数量和处理资源池线程数量的不同，有三种典型的实现 单Reactor 单线程 单Reactor 多线程 主从Reactor 多线程 Netty线程模式(Netty主要基于主从Reactor多线程模型做了一定的改进，其中主从Reactor多线程模型有多个Reactor) ","date":"2021-07-04","objectID":"/netty/:5:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.2、传统阻塞I/O服务模型 5.2.1、工作原理图 黄色的框表示对象，蓝色的框表示线程，白色的框表示方法(API) 5.2.2、模型特点 采用阻塞IO模式获取输入的数据 每个连接都需要独立的线程完成数据的输入，业务处理，数据返回 5.2.3、问题分析 当并发数很大，就会创建大量的线程，占用很大系统资源 连接创建后，如果当前线程暂时没有数可读，该线程会阻塞在read操作，造成线程资源浪费 ","date":"2021-07-04","objectID":"/netty/:5:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.3、Reactor模式 5.3.1、针对传统阻塞I/O服务模型的2个缺点，解决方案 基于I/O复用模型：多个连接公用一个阻塞对象，应用程序只需在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理 Reactor 对应的叫法：1、反应器模式 2、分发者模式(Dispatcher) 3、通知者模式(notifier) 基于线程池复用线程资源：不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理，一个线程可以处理多个连接的业务 I/O复用结合线程池，就是Reactor模式基本设计思想，如图： 1. Reactor模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动) 2. 服务器端程序处理传入的多个请求，并将他们同步分派到相应的处理线程，因此Reactor模式也叫Dispatcher模式 3. Reactor模式使用IO复用监听，收到事件后，分发给某个线程(进程)，这点就是网络服务器高并发处理关键 5.3.2、Reactor模式中核心组成： Reactor：Reactor在一个单独的线程中运行，负责监听和分发事件，分发给适当的处理程序来对IO事件做出反应。它就像公司的电话接线员，它接听来自客户的电话并将线路转移到适当的联系人 Handlers：处理程序执行I/O事件要完成的实际事件，类似于客户想要与之交谈的公司中的实际官员。Reactor通过调度适当的处理程序来响应I/O事件，处理程序执行非阻塞操作 5.3.3、Reactor模式分类： 根据Reactor的数量和处理资源池线程数量的不同，有三种典型的实现 单Reactor 单线程 单Reactor 多线程 主从Reactor 多线程 ","date":"2021-07-04","objectID":"/netty/:5:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.4、单Reactor 单线程 前面所写的NIO群聊系统就是一个单Reactor 单线程模式 5.4.1、方案说明 Select是前面I/O复用模型介绍的标准网络编程API，可以实现应用程序通过一个阻塞对象监听多路连接请求 Reactor对象通过Select监听客户端请求事件，收到事件后通过Dispatch进行分发 如果是建立连接请求事件，则由Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理连接完成后的后续业务处理 如果不是建立连接事件，则Reactor会分发调用对应的Handler来响应 Handler会完成Read-\u003e业务处理-\u003eSend的完整业务流程 结合实例；服务器端用一个线程通过多路复用搞定所有的IO操作(包括连接、读、写等)，编码简单，清晰明了，但是如果客户端连接数量较多，将无法支撑，前面的NIO群聊系统就属于这种类型 5.4.2、方案优缺点分析 优点：模型简单，没有多线程、进行通信、竞争的问题，全部都在一个线程中完成 缺点：性能问题，只有一个线程，无法完全发挥多核CPU的性能。Handler在处理某个连接上的业务时，整个进程无法处理其它连接事件，很容易导致性能瓶颈 缺点：可靠性问题，线程意外终止，过着进入死循环，会导致整个系统通信模块不可以，不能接收和处理外部消息，造成节点故障 使用场景：客户端的数量有限，业务处理非常快速，比如Redis在业务处理的时间复杂度O(1)的情况 ","date":"2021-07-04","objectID":"/netty/:5:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.5、单Reactor 多线程 工作原理示意图： 5.5.1、方案说明： Reactor对象通过select监控客户端请求事件，收到事件后，通过Dispatch进行分发 如果是建立连接请求，则由Acceptor通过Accept处理连接请求，然后创建一个Handler对象处理完成连接后的各种事件 如果不是连接请求，则由Reactor分发调用连接对应的Handler来处理 Handler只负责响应事件，不做具体的业务处理，通过read读取数据后，会分发给后面的worker线程池的某个线程处理业务 worker线程池会分配独立的线程完成真正的业务，并将结果返回给handler handler收到响应后，通过send将结果返回给client 5.5.2、方案优缺点分析： 优点：可以充分的利用多核CPU的处理能力 缺点：多线程数据共享和访问比较复杂，Reactor处理所有事件的监听和响应，在单线程运行，在高并发场景容易出现性能瓶颈 ","date":"2021-07-04","objectID":"/netty/:5:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.6、主从Reactor 多线程 工作原理示意图： 5.6.1、方案说明： Reactor主线程MainReactor对象通过select监听事件，收到事件后，通过Acceptor处理连接事件 当Acceptor处理连接事件后，MainReactor将连接分配给SubReactor SubReactor将连接加入到连接队列进行监听，并创建handler进行各种事件处理 当有新的事件发生时，SubReactor就会调用对应的handler处理 handler通过read读取数据，分发给后面的worker线程池处理 worker线程池分配独立worker线程进行业务处理，并返回结果 handler收到响应结果后，再通过send将结果返回给client Reactor主线程可以对应多个Reactor子线程，即MainReactor可以关联多个SubReactor 5.6.2、方案优缺点说明 1.优点：父线程与子线程的数据交互简单职责明确，父线程只需要接收新连接，子线程完成后续的业务处理 2.优点：父线程与子线程的数据交互简单，Reactor主线程只需要把新连接传给子线程，子线程无需返回数据 3.缺点：编程复杂度较高 ","date":"2021-07-04","objectID":"/netty/:5:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.7、Reactor模式小结 1. 单Reactor 单线程，前台接待员和服务员是同一个人，全程为顾客服务 2. 单Reactor 多线程，1个前台接待员，多个服务员，接待员只负责接待 3. 主从Reactor 多线程，一个礼仪，多个前台接待员，多个服务生，礼仪负责将顾客领进门，然后交给接待员接待，服务员负责服务 Reactor模式具有以下优点： 响应快，不必为单个同步事件所阻塞，因为它有多个SubReactor，这个阻塞了，它也可以通过下一个SubReactor来进行处理，虽然Reactor本身依然是同步的 可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销 扩展性好，可以方便的通过增加Reactor实例个数来充分利用CPU资源 复用性好，Reactor模型本身与具体事件处理逻辑无关，具有很高的复用性？？？？？？ ","date":"2021-07-04","objectID":"/netty/:5:7","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.8、Netty模型 5.8.1、工作原理示意图1-简单版 BossGroup线程维护Selector，只关注Accept 当接收到Accept事件后，获取对应的SockerChannel，进一步封装成NIOSocketChannel并注册到WorkerGroup线程(事件循环)，并进行维护 当WorkerGroup线程监听到注册到selector中的通道发生自己感兴趣的事件后，就进行处理(由handler处理)，注意：handler已经加入到通道中了 5.8.2、工作原理示意图2-进阶版 这里就很像我们之前的主从Reactor，BossGroup中有多个MainReactor 5.8.3、工作原理示意图3-详细版 Netty抽象出两组线程池BossGroup：专门负责接收客户端的连接，WorkGroup：专门负责网络的读写 BossGroup和WorkGroup类型都是NioEventLoopGroup NioEventLoopGroup相当于一个事件循环组，这个组中含有多个事件循环，每一个事件循环是NioEventLoop NioEventLoop表示一个不断循环执行处理任务的线程，每个NioEventLoop都有一个Selector，用于监听绑定在其上的socket的网络通讯 NioEventLoopGroup可以有多个线程，即可以含有多个NioEventLoop 每个Boss NioEventLoop循环执行的步骤有3步 轮询accept事件 处理accept事件，与client建立连接，生成NioSocketChannel，并将其注册到某个WorkerNioEventLoop上的Selector 处理任务队列的任务，即runAllTasks 每个WorkerNioEventLoop循环执行的步骤 轮询read，write事件 处理I/O事件，即read、write事件，在对应的NioSocketChannel上处理 处理任务队列的任务，即runAllTasks 每个WorkerNioEventLoop处理业务时，会使用pipeline(管道)，pipeline中包含了channel，即通过pipeline可以获取到对应通道,管道中维护了很多的处理器 5.8.4、Netty快速入门实例-TCP服务 实例要求：使用IDEA创建Netty项目 Netty服务器在6668端口监听，客户端能发送消息给服务器\"hello,服务器\" 服务器可以回复消息给客户端\"hello,客户器\" 目的：对Netty线程模型有一个初步认识 说明：创建Maven项目，并引入Netty包 Bootstrap执行流程 ChannelFuture 在Netty中的所有的I/O操作都是异步执行的，这就意味着任何一个I/O操作会立刻返 回，不保证在调用结束的时候操作会执行完成。因此，会返回一个ChannelFuture的实例，通过这个实 例可以获取当前I/O操作的状态。 当我们要关闭 channel 时，可以调用 `channel.close()` 方法进行关闭。但是该方法也是一个异步方法。 真正的关闭操作并不是在调用该方法的线程中执行的，而是在 NIO 线程中执行真正的关闭操作 服务器端： package com.clover.netty.simple; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; public class NettyServer { public static void main(String[] args) throws Exception{ /* * 说明 * 1.创建两个线程组 bossGroup 和 workerGroup * 2.bossGroup 只是处理连接请求，真正的和客户端业务处理，会交给 workerGroup 完成 * 3.两个线程组都是无线循环 */ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { // 创建服务器的启动对象，配置参数 ServerBootstrap bootstrap = new ServerBootstrap(); // 使用链式编程来进行设置 bootstrap.group(bossGroup,workerGroup)// 设置两个线程组 .channel(NioServerSocketChannel.class)// 使用NioSocketChannel作为服务器的通道实现类型 .option(ChannelOption.SO_BACKLOG,128)// 设置线程队列等待连接个数 .childOption(ChannelOption.SO_KEEPALIVE,true)// 设置保持活动连接状态 .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { // 创建一个通道初始化对象(匿名对象) // 向workerGroup中EventLoop所关联的通道对应的pipeline设置处理器 @Override protected void initChannel(SocketChannel ch) throws Exception { ch.pipeline().addLast(new NettyServerHandler()); } });// 给我们的workerGroup的 EventLoop对应的管道设置处理器 System.out.println(\"服务器 is ready\"); /* * ChannelFuture 在Netty中的所有的I/O操作都是异步执行的，这就意味着任何一个I/O操作会立刻返回，不保证 * 在调用结束的时候操作会执行完成。因此，会返回一个ChannelFuture的实例，通过这个实例可以获取当前I/O操 * 作的状态。 */ // 绑定一个端口，并且同步，生成了一个ChannelFuture 对象 // 启动服务器(并绑定端口) // 为什么使用同步？因为Netty是基于异步操作的，如果不使用同步，可能服务器还未启动就执行下面的语句了，就会产生异常 ChannelFuture cf = bootstrap.bind(6668).sync(); // 对关闭通道进行监听(只有当你有一个关闭通道这样的事件发生时，才会去进行处理) // 这里为什么也需要使用同步？因为不适用同步，他就会跳过这个语句直接执行finally中的语句关闭线程组了 // closeFuture().sync() 不是用于关闭 Channel ，而是允许你阻塞直到 Channel 关闭，然后执行一些额外的操作 // 它有一个监听的作用，当通道关闭的时候，它会返回一个 ChannelFuture,这个里面包含了IO操作的状态 cf.channel().closeFuture().sync(); } finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 服务器端Handler package com.clover.netty.simple; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.util.CharsetUtil; /* * 说明 * 1.我们自定义一个Handler需要继承netty规定好的某个HandlerAdapter(规范) * 2.这时我们自定义一个Handler，才能称之为一个handler */ public class NettyServerHandler extends ChannelInboundHandlerAdapter { /* * 读取数据(这里我们可以读取客户端发送的数据) * 1.ChannelHandlerContext ctx：上下文对象，含有管道pipeline(业务逻辑处理)，通道channel(数据读写处理)，地址 * 2.Object msg：就是客户端发送的数据，默认时Object类型 */ @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Except","date":"2021-07-04","objectID":"/netty/:5:8","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.9、异步模型 5.9.1、基本介绍 异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者 Netty中的IO操作是异步的，包括Bind、Write、Connect等操作会简单的返回一个ChannelFuture 调用者并不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果 Netty的异步模型是建立在future和callback之上的，callback就是回调。重点说Future，它的核心思想是：假设一个方法fun，计算过程可能非常耗时，等待fun返回显然不合适。那么可以在调用fun 的时候，立马返回一个Future，后续可以通过Future去监控方法fun的处理过程(即：Future-Listener机制) 5.9.2、Future说明 表示异步的执行结果，可以通过它提供的方法来检测执行是否完成 ChannelFuture是一个接口：public interface ChannelFuture ,我们可以添加监听器，当监听的事件发生时，就会通知到监听器 案例说明 5.9.3、工作原理示意图 说明: 在使用Netty进行编程时，拦截操作和转换出入站数据只需要提供 callback 或利用 future 即可。这使得链式操作简单、高效，并有利于编写可重用的、通用的代码。 Netty框架的目标就是让你的业务逻辑从网络基础应用编码中分离出来、解脱出来 5.9.4、Future-Listener机制 举例说明： 演示：绑定端口是异步操作，当绑定操作处理完，将会调用相应的监听器处理逻辑 cf.addListener(new ChannelFutureListener() { @Override public void operationComplete(ChannelFuture future) throws Exception { if(future.isSuccess()){ System.out.println(\"监听端口 6668成功\"); } else { System.out.println(\"监听端口 6668失败\"); } } }); 小结：相比传统阻塞I/O，执行I/O操作后线程会被阻塞住，直到操作完成；异步处理的好处是不会造成 线程阻塞，线程在I/O操作期间可以执行别的程序，在高并发情况下会更稳定和更高的吞吐量 ","date":"2021-07-04","objectID":"/netty/:5:9","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"5.10、快速入门实例-HTTP服务 服务器端 package com.clover.netty.http; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; public class TestServer { public static void main(String[] args) throws Exception{ EventLoopGroup bossGroup = new NioEventLoopGroup(); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new TestServerInitializer()); // 注意：谷歌浏览器使用6668端口可能无法访问，可能存在安全验证，换一个端口就好 ChannelFuture channelFuture = serverBootstrap.bind(15989).sync(); channelFuture.channel().closeFuture().sync(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 向管道加入处理器 package com.clover.netty.http; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; import io.netty.handler.codec.http.HttpServerCodec; public class TestServerInitializer extends ChannelInitializer\u003cSocketChannel\u003e { @Override protected void initChannel(SocketChannel ch) throws Exception { // 向管道加入处理器 // 得到管道 ChannelPipeline pipeline = ch.pipeline(); // 加入一个netty提供的httpServerCodec(编解码器) /* * HttpServerCodec说明 * 1.HttpServerCodec 是netty提供处理Http的 编-解码器 */ pipeline.addLast(\"MyHttpServerCodec\",new HttpServerCodec()); // 2.增加一个自定的handler pipeline.addLast(\"MyTestHttpServerHandler\",new TestHttpServerHandler()); } } 自定义handler package com.clover.netty.http; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.*; import io.netty.util.CharsetUtil; import java.net.URI; import java.nio.charset.Charset; /* * 说明 * 1.SimpleChannelInboundHandler 是 ChannelInboundHandlerAdapter的子类 * 2.HttpObject 客户端和服务器端相互通讯的数据被封装成HttpObject */ public class TestHttpServerHandler extends SimpleChannelInboundHandler\u003cHttpObject\u003e { // channelRead0读取客户端数据 @Override protected void channelRead0(ChannelHandlerContext ctx, HttpObject msg) throws Exception { // 判断msg 是不是 httprequest请求 if( msg instanceof HttpRequest){ System.out.println(\"pipeline hascode =\" + ctx.pipeline().hashCode()+ \" TestHttpServerHandler hascode =\" +this.hashCode()); System.out.println(\"msg 类型=\" + msg.getClass()); System.out.println(\"客户端地址\" + ctx.channel().remoteAddress()); // 将msg转化为HttpRequest HttpRequest httpRequest = (HttpRequest) msg; //获取uri，过滤指定资源 URI uri = new URI(httpRequest.uri()); if(\"/favicon.ico\".equals(uri.getPath())){ System.out.println(\"请求了 favicon.ico，不做响应\"); return; } // 回复信息给浏览器,需要满足http协议 ByteBuf content = Unpooled.copiedBuffer(\"hello，我是服务器\", CharsetUtil.UTF_8); // 构造一个http的响应，即httpResponse FullHttpResponse response = new DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content); /* * 注意：如果中文乱码，则需要在 CONTENT_TYPE 中，修改为text/plain;charset=utf-8，或者直接将CharsetUtil.UTF_8改为UTF_16 */ response.headers().set(HttpHeaderNames.CONTENT_TYPE,\"text/plain;charset=utf-8\"); response.headers().set(HttpHeaderNames.CONTENT_LENGTH,content.readableBytes()); // 将构建好的response返回 ctx.writeAndFlush(response); } } } http不是一个长连接，用完即断掉 当你有多个浏览器连接服务器时，每个连接对应的pipeline和handler都是唯一的、不一样的，不是公用一个pipeline和handler 浏览器刷新时也会产生一个新的pipeline和handler，这是因为http协议原因所导致的，与TCP协议还是有区别的 ","date":"2021-07-04","objectID":"/netty/:5:10","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6、核心模块组件 ","date":"2021-07-04","objectID":"/netty/:6:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.1、Bootstrap、ServerBootstrap Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件，Netty中Bootstrap 类是客户端程序的启动引导类，ServerBootstrap是服务端启动引导类 常见的方法有 public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于服务器端，用来设置两个 EventLoop public B group(EventLoopGroup group) ，该方法用于客户端，用来设置一个 EventLoop public B channel(Class\u003c\u003e channelClass)，该方法用来设置一个服务器端的通道实现 public \u003c\u003e B option(ChannelOption\u003c\u003e option, T value)，用来给 ServerChannel 添加配置 public \u003c\u003e ServerBootstrap childOption(ChannelOption\u003c\u003e childOption, T value)，用来给接收到的通道添加配置 public ServerBootstrap childHandler(ChannelHandler childHandler)，该方法用来设置业务处理类(自定义的 handler) public ChannelFuture bind(int inetPort) ，该方法用于服务器端，用来设置占用的端口号 public ChannelFuture connect(String inetHost, int inetPort) ，该方法用于客户端，用来连接服务器端 ","date":"2021-07-04","objectID":"/netty/:6:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.2、Future、ChannelFuture Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事件 常见的方法有 Channel channel()，返回当前正在进行 IO 操作的通道 ChannelFuture sync()，等待同步操作执行完毕 ","date":"2021-07-04","objectID":"/netty/:6:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.3、Channel Netty 网络通信的组件，能够用于执行网络 I/O 操作 通过Channel 可获得当前网络连接的通道的状态 通过Channel 可获得 网络连接的配置参数 （例如接收缓冲区大小） Channel 提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成 调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 监控I/O 操作成功、失败或取消时回调通知调用方 支持关联 I/O 操作与对应的处理程序 不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型: NioSocketChannel，异步的客户端 TCP Socket 连接。 NioServerSocketChannel，异步的服务器端 TCP Socket 连接。 NioDatagram Channel，异步的 UDP 连接。 NioSctpChannel，异步的客户端 Sctp 连接。 NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件 IO。 ","date":"2021-07-04","objectID":"/netty/:6:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.4、Selector Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单地使用一个线程高效地管理多个 Channel ","date":"2021-07-04","objectID":"/netty/:6:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.5、ChannelHandler 及其实现类 ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序 ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间，可以继承它的子类 ChannelHandler 及其实现类一览图 ChannelInboundHandler 用于处理入站 I/O 事件 ChannelOutboundHandler 用于处理出站 I/O 操作 适配器 ChannelInboundHandlerAdapter 用于处理入站 I/O 事件 ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作 ChannelDuplexHandler 用于处理入站和出站事件 我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter，然后通过重写相应方法实现业务逻辑，我们接下来看看一般都需要重写哪些方 public class Channel InboundHandlerAdapter extends Channel HandlerAdapter implements Channel InboundHandler { public Channel InboundHandlerAdapter() { } public void channelRegistered(ChannelHandlerContext ctx) throws Exception { ctx.fireChannelRegistered(); } public void channelUnregistered(ChannelHandlerContext ctx) throws Exception { ctx.fireChannelUnregistered(); } //通道就绪事件 public void channelActive(ChannelHandlerContext ctx) throws Exception { ctx.fireChannelActive(); } public void channelInactive(ChannelHandlerContext ctx) throws Exception { ctx.fireChannelInactive(); } //通道读取数据事件 public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { ctx.fireChannelRead(msg); } //数据读取完毕事件 public void channelReadComplete(ChannelHandlerContext ctx, Object msg) throws Exception { ctx.fireChannelRead(msg); } //数据读取完毕事件 public void channelReadComplete(ChannelHandlerContext ctx, Object msg) throws Exception { ctx.fireChannelRead(msg); } public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { ctx.fireUserEventTriggered(evt); } public void channelWritabilityChanged(ChannelHandlerContext ctx) throws Exception { ctx.fireChannelWritabilityChanged(msg); } //通道发生异常事件 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.fireExceptionCaught(msg); } ","date":"2021-07-04","objectID":"/netty/:6:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.6、Pipeline和ChannelPipeline ChannelPipeline 是一个重点： ChannelPipeline 是一个 Handler 的集合，它负责处理和拦截 inbound 或者 outbound 的事件和操作，相当于一个贯穿 Netty 的链。(也可以这样理解：ChannelPipeline 是保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作) ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以及 Channel 中各个的 ChannelHandler 如何相互交互 在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下 一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler 入站事件和出站事件在一个双向链表中，入站事件会从链表 head 往后传递到最后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰 常用方法 Channel Pipeline addFirst(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的第一个位置 Channel Pipeline addLast(ChannelHandler… handlers)，把一个业务处理类（handler）添加到链中的最后一个位置 ","date":"2021-07-04","objectID":"/netty/:6:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.7、ChannelHandlerContext 保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象 即 ChannelHandlerContext 中包含一个具体的事件处理器 ChannelHandler ， 同时ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler进行调用 常用方法 ChannelFuture close()，关闭通道 ChannelOutboundInvoker flush()，刷新 ChannelFuture writeAndFlush(Object msg) ， 将数据写到 ChannelPipeline 中当前ChannelHandler 的下一个 ChannelHandler 开始处理 (出站) ","date":"2021-07-04","objectID":"/netty/:6:7","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.8、ChannelOption Netty 在创建 Channel 实例后,一般都需要设置 ChannelOption 参数 ChannelOption 参数如下: ChannelOption.SO_BACKLOG 对应TCP/IP协议 listen 函数中的 backlog 参数，用来初始化服务器可连接队列大小。服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接。多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，backlog参数指定了队列的大小 ChannelOption.SO_KEEPALIVE 一直保持连接活动状态 ","date":"2021-07-04","objectID":"/netty/:6:8","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.9、EventLoopGroup 和其实现类 NioEventLoopGroup EventLoopGroup 是一组 EventLoop 的抽象，Netty为了更好的利用多核 CPU 资源，一般会有多个 EventLoop 同时工作，每个 EventLoop 维护着一个Selector实例 EventLoopGroup 提供 next 接口，可以从组里面按照一定规则获取其中一个 EventLoop来处理任务。在 Netty 服务器端编程中，我们一般都需要提供两个 EventLoopGroup，例如：BossEventLoopGroup 和 WorkerEventLoopGroup 通常一个服务端口即一个 ServerSocketChannel 对应一个 Selector 和一个 EventLoop 线程。BossEventLoopGroup 负责接收客户端的连接并将 SocketChannel 交给 WorkerEventLoopGroup 来进行 IO 处理，如下图所示 BossEventLoopGroup 通常是一个单线程的 EventLoop，EventLoop 维护着一个注册了ServerSocketChannel 的 Selector 实例，BossEventLoop 不断轮询Selector 将连接事件分离出来 通常是OP_ACCEPT 事件，然后将接收到的 SocketChannel 交给 WorkerEventLoopGroup WorkerEventLoopGroup 会由 next 选择其中一个 EventLoop来将这个SocketChannel 注册到其维护的 Selector 并对其后续的 IO 事件进行处理 常用方法 public NioEventLoopGroup()，构造方法 public Future\u003c\u003e shutdownGracefully()，断开连接，关闭线程 ","date":"2021-07-04","objectID":"/netty/:6:9","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.10、Unpooled类 Netty 提供一个专门用来操作缓冲区(即Netty的数据容器)的工具类 常用方法如下所示 //通过给定的数据和字符编码返回一个 ByteBuf 对象（类似于 NIO 中的 ByteBuffer 但有区别） public static ByteBuf copiedBuffer(CharSequence string, Charset charset) 举例说明Unpooled 获取 Netty的数据容器ByteBuf 的基本使用 (案例说明) 实例代码一 package com.clover.netty.buf; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; public class NettyByteBuf01 { public static void main(String[] args) { // 先创建一个ByteBuf /* * 说明 * 1.创建对象，该对象包含一个数组array，是一个byte[10]类型的数组 * 2.在netty的buffer中，不需要使用flip反转 * 底层维护了 readerIndex 和 writerIndex * 3.通过 readerIndex 和 writerIndex 和 capacity ，将buffer分成三个区域 * 0---readerIndex，已经读取的区域 * readerIndex --- writerIndex，可以读取的区域 * writerIndex --- 0，可写的区域 */ ByteBuf buf = Unpooled.buffer(10); for (int i = 0; i \u003c 10; i++){ buf.writeByte(i); } System.out.println(\"capacity=\" + buf.capacity()); // 输出 // for (int i = 0; i \u003c buf.capacity(); i++){ // // 这种方法是通过下标获取对应的值，不会使readerIndex改变值 // System.out.println(buf.getByte(i)); // } // 改变readerIndex的输出方式 for (int i = 0;i \u003c buf.capacity(); i++) { System.out.println(buf.readByte()); } } } 实例代码二 package com.clover.netty.buf; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.util.CharsetUtil; import java.nio.charset.Charset; public class NettyByteBuf02 { public static void main(String[] args) { //创建ByteBuf /* * 说明 * 第一个参数代表写入内容，第二个代表内容的字符集编码 */ ByteBuf buf = Unpooled.copiedBuffer(\"hello,world!\", Charset.forName(\"utf-8\")); // 使用相关的方法 if (buf.hasArray()){ // 获取buf的数组 byte[] content = buf.array(); System.out.println(new String(content,CharsetUtil.UTF_8)); System.out.println(\"bytebuf=\" + buf); // 获取数组位移偏移量 System.out.println(buf.arrayOffset());// 0 System.out.println(buf.readerIndex());// 0 System.out.println(buf.writerIndex());// 12 System.out.println(buf.capacity());// 36 //System.out.println(buf.readByte());// 104 这是h代表的ASCII码 System.out.println(buf.getByte(0));// 104 这是h代表的ASCII码 int len = buf.readableBytes();// 获取可读字节数 System.out.println(\"len=\" + len);// 如果在前面没有使用readbyte读取数据，则不会对可读字节产生影响，如果使用就会有影响 // 使用for循环取出各个字节 for (int i = 0; i \u003c len; i++) { System.out.println((char) buf.getByte(i)); } // 按照某个范围读取 System.out.println(buf.getCharSequence(0,4,Charset.forName(\"utf-8\"))); System.out.println(buf.getCharSequence(4,6,Charset.forName(\"utf-8\"))); } } } ","date":"2021-07-04","objectID":"/netty/:6:10","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.11、群聊系统升级 编写一个 Netty 群聊系统，实现服务器端和客户端之间的数据简单通讯（非阻塞） 实现多人群聊 服务器端：可以监测用户上线，离线，并实现消息转发功能 客户端：通过channel 可以无阻塞发送消息给其它所有用户，同时可以接受其它用户发送的消息(由服务器转发得到) 目的：进一步理解Netty非阻塞网络编程机制 服务器端： package com.clover.netty.groupchat; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.*; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; public class GroupChatServer { // 监听端口 private int port; public GroupChatServer(int port){ this.port = port; } public void run() throws Exception{ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap bootstrap = new ServerBootstrap(); bootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG,128) .childOption(ChannelOption.SO_KEEPALIVE,true) .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override protected void initChannel(SocketChannel ch) throws Exception { // 获取到pipeline ChannelPipeline pipeline = ch.pipeline(); // 向pipeline中加入解码器 pipeline.addLast(\"decoder\",new StringDecoder()); // 向pipeline中加入编码器 pipeline.addLast(\"encoder\",new StringEncoder()); // 加入自己的业务处理handler pipeline.addLast(new GroupChatServerHandler()); } }); System.out.println(\"netty 服务器启动\"); ChannelFuture channelFuture = bootstrap.bind(port).sync(); // 监听关闭事件 channelFuture.channel().closeFuture().sync(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } public static void main(String[] args) throws Exception { new GroupChatServer(7000).run(); } } 服务器端handler： package com.clover.netty.groupchat; import io.netty.channel.Channel; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.channel.group.ChannelGroup; import io.netty.channel.group.DefaultChannelGroup; import io.netty.util.concurrent.GlobalEventExecutor; import java.text.SimpleDateFormat; import java.util.Date; public class GroupChatServerHandler extends SimpleChannelInboundHandler\u003cString\u003e { // 定义一个channel组，管理所有的channel // GlobalEventExecutor.INSTANCE 是全局的事件执行器，是一个单例 private static ChannelGroup channelGroup= new DefaultChannelGroup(GlobalEventExecutor.INSTANCE); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");// 输出接收消息时的时间 // handlerAdded表示连接建立，一旦连接，第一个被执行 // 将当前channel加入到channelGroup @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception { Channel channel = ctx.channel(); /* * 将该客户端加入聊天的信息推送给其它在线的客户端 * 该方法会将channelGroup中所有的channel遍历一遍，并发送消息，我们不需要自己遍历 */ channelGroup.writeAndFlush(\"[客户端]\" + channel.remoteAddress() + \" 加入聊天\" + sdf.format(new Date()) + \"\\n\"); channelGroup.add(channel); } // 表示断开连接了,将xxx客户离开信息推送给当前在线的客户 // 只要触发了handlerRemoved函数就会自动在channelGroup中移除自己，不需要自己手动去清除 @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { Channel channel = ctx.channel(); channelGroup.writeAndFlush(\"[客户端]\" + channel.remoteAddress() + \"离开了\\n\"); System.out.println(\"channelGroup size =\" + channelGroup.size()); } // 表示channel处于活动状态，可以提示xx上线 @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { System.out.println(ctx.channel().remoteAddress()+ \"上线了~\"); } // 表示channel处于非活动状态，可以提示xx离线 @Override public void channelInactive(ChannelHandlerContext ctx) throws Exception { System.out.println(ctx.channel().remoteAddress()+ \"离线了~\"); } // 读取数据 @Override protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception { // 获取到当前的channel Channel channel = ctx.channel(); // 这个时候我们需要遍历channelGroup，根据不同的情况回送不同的消息，主要是为了剔除自己 channelGroup.forEach( ch -\u003e{ // 不是当前的channel，就直接转发消息 if (channel !=ch){ // 将当前channel通道的信息转发给ch，即channelGroup中遍历出来的某一个channel ch.writeAndFlush(\"[客户]\" + channel.remoteAddress() + \"发送了消息：\" + msg + \"\\n\"); } else { ch.writeAndFlush(\"[自己]发送了消息\" + msg + \"\\n\"); }","date":"2021-07-04","objectID":"/netty/:6:11","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.12、Netty心跳检测机制案例 实例要求： 编写一个 Netty心跳检测机制案例, 当服务器超过3秒没有读时，就提示读空闲 当服务器超过5秒没有写操作时，就提示写空闲 实现当服务器超过7秒没有读或者写操作时，就提示读写空闲 package com.clover.netty.heartbeat; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; import io.netty.handler.timeout.IdleStateHandler; import java.util.concurrent.TimeUnit; public class MyServer { public static void main(String[] args) throws Exception{ // 创建两个线程组 NioEventLoopGroup bossGroup = new NioEventLoopGroup(1); NioEventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) // 在我们的bossGroup中增加一个日志处理器 .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 加入一个netty提供的处理器 IdleStateHandler /* * 说明 * 1.IdleStateHandler 是netty提供的处理空闲状态的处理器 * 2.long readerIdleTime : 表示多长时间没有读，就会发送一个心跳检测包检测是否连接 * 3.long writerIdleTime : 表示多长时间没有写，就会发送一个心跳检测包检测是否连接 * 4.long allIdleTime : 表示多长时间没有读写，就会发送一个心跳检测包检测是否连接 * 5.当IdleStateHandler触发后，就会传递给换到的下一个handler去处理，通过调用(触发)下一个handler的userEventTriggered * 在该方法中去处理IdleStateHandler(读空闲，写空闲，读写空闲) * 6.如果是0表示不检测，所以如果全是0，则相当于没添加这个 IdleStateHandler，连接是个普通的短连接。 */ pipeline.addLast(new IdleStateHandler(3,5,7, TimeUnit.SECONDS)); // 加入一个对空闲检测进一步处理的handler(自定义) pipeline.addLast(new MyServerHandler()); } }); ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); } finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } package com.clover.netty.heartbeat; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.handler.timeout.IdleStateEvent; public class MyServerHandler extends ChannelInboundHandlerAdapter { /* * @param ctx 上下文 * @param evt 事件 * @throws Exception */ @Override public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception { if (evt instanceof IdleStateEvent){ // 将evt向下转型 IdleStateEvent IdleStateEvent event = (IdleStateEvent) evt; String eventType = null; switch (event.state()){ case READER_IDLE: eventType = \"读空闲\"; break; case WRITER_IDLE: eventType = \"写空闲\"; break; case ALL_IDLE: eventType = \"读写空闲\"; break; } System.out.println(ctx.channel().remoteAddress() + \"---超时事件---\" + eventType); System.out.println(\"服务器开始做相应的处理\"); // 如果发生空闲，我们关闭通道，结果显示就只会显示一次空闲后就不在显示了 ctx.channel().close(); } } } ","date":"2021-07-04","objectID":"/netty/:6:12","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"6.13、Netty 通过WebSocket编程实现服务器和客户端长连接 实例要求： Http协议是无状态的, 浏览器和服务器间的请求响应一次，下一次会重新创建连接 要求：实现基于webSocket的长连接的全双工的交互 改变Http协议多次请求的约束，实现长连接了， 服务器可以发送消息给浏览器 客户端浏览器和服务器端会相互感知，比如服务器关闭了，浏览器会感知，同样浏览器关闭了，服务器会感知 运行界面如下 服务器端： package com.clover.netty.websocket; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.http.HttpObjectAggregator; import io.netty.handler.codec.http.HttpServerCodec; import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; import io.netty.handler.stream.ChunkedWriteHandler; public class MyServer { public static void main(String[] args) throws Exception{ // 创建两个线程组 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); // 因为基于http协议，使用http的编码和解码器 pipeline.addLast(new HttpServerCodec()); // 是以块方式写，添加ChunkedWriteHandler处理器 pipeline.addLast(new ChunkedWriteHandler()); /* * 说明 * 1.http数据在传输过程中是分段，HttpObjectAggregator，作用就是可将多个段聚合 * 2.这就是为什么，当浏览器发送大量数据时，就会发出多次http请求 */ pipeline.addLast(new HttpObjectAggregator(8192)); /* * 说明 * 1.对应的websocket，它的数据是以 帧(frame) 形式传递 * 2.可以看到WebSocketFrame 下面有六个子类 * 3.浏览器请求时 ws://localhost:7000/xxx 表示请求的qurl * 4.WebSocketServerProtocolHandler 核心功能是将http协议升级为ws协议，即保持长连接 * 5.是通过一个 状态码 101 */ pipeline.addLast(new WebSocketServerProtocolHandler(\"/hello\")); // 自定义的handler，处理业务逻辑 pipeline.addLast(new MyTextWebSocketFrameHandler()); } }); ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); channelFuture.channel().closeFuture().sync(); } finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 对应的handler： package com.clover.netty.websocket; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import io.netty.handler.codec.http.websocketx.TextWebSocketFrame; import java.time.LocalDateTime; // 这里 TextWebSocketFrame 类型，表示一个文本帧(frame) public class MyTextWebSocketFrameHandler extends SimpleChannelInboundHandler\u003cTextWebSocketFrame\u003e { @Override protected void channelRead0(ChannelHandlerContext ctx, TextWebSocketFrame msg) throws Exception { System.out.println(\"服务器收到消息：\" + msg.text()); // 回复浏览器消息 ctx.channel().writeAndFlush(new TextWebSocketFrame(\"服务器时间：\" + LocalDateTime.now() + \" \" + msg.text())); } // 当web客户端连接后，就会触发这个方法 @Override public void handlerAdded(ChannelHandlerContext ctx) throws Exception { // id 表示唯一的值，LongText 这个值是唯一的，ShortText 这个值不是唯一的 System.out.println(\"handlerAdded 被调用了\" + ctx.channel().id().asLongText()); System.out.println(\"handlerAdded 被调用了\" + ctx.channel().id().asShortText()); } @Override public void handlerRemoved(ChannelHandlerContext ctx) throws Exception { System.out.println(\"handlerRemoved 被调用了\" + ctx.channel().id().asLongText()); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { System.out.println(\"异常发生\" + cause.getMessage()); ctx.close();// 关闭连接 } } 客户端： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript\u003e var socket; // 判断当前浏览器是否支持websocket if (window.WebSocket){ socket = new WebSocket(\"ws://localhost:7000/hello\"); socket.onmessage = function (ev) { var rt = document.getElementById(\"responseText\"); rt.value = rt.value + \"\\n\" + ev.data; }; // 相当于连接开启","date":"2021-07-04","objectID":"/netty/:6:13","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7、Google Protobuf ","date":"2021-07-04","objectID":"/netty/:7:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7.1、编码和解码的基本介绍 编写网络应用程序时，因为数据在网络种传输的都是二进制字节码数据，在发送数据时就需要编码，接收数据时就需要解码 codec(编解码器)的组成部分有两个：decoder(解码器)和encoder(编码器)。encoder负责把业务数据转换成字节码数据，decoder负责把字节码数据转换成业务数据 ","date":"2021-07-04","objectID":"/netty/:7:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7.2、Netty 本身的编码解码的机制和问题分析 Netty 自身提供了一些 codec(编解码器) Netty 提供的编码器 StringEncoder，对字符串数据进行编码 ObjectEncoder，对 Java 对象进行编码 Netty 提供的解码器 StringDecoder, 对字符串数据进行解码 ObjectDecoder，对 Java 对象进行解码 Netty 本身自带的 ObjectDecoder 和 ObjectEncoder 可以用来实现 POJO 对象或各种业务对象的编码和解码，底层使用的仍是 Java 序列化技术 , 而Java 序列化技术本身效率就不高，存在如下问题 无法跨语言 序列化后的体积太大，是二进制编码的 5 倍多 序列化性能太低 =\u003e 引出新的解决方案[Google的Protobuf] ","date":"2021-07-04","objectID":"/netty/:7:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7.3、Protobuf 7.3.1、Protobuf基本介绍和使用示意图 Protobuf 是 Google 发布的开源项目，全称 Google Protocol Buffers，是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC(远程过程调用 remote procedure call)数据交换格式。 目前很多公司 http+json -\u003e tcp+protobuf 参考文档:语言指南 Protobuf 是以 message 的方式来管理数据的 支持跨平台、跨语言，即客户端和服务器端可以是不同的语言编写的 (支持目前绝大多数语言，例如 C++、C#、Java、python 等) 高性能，高可靠性 使用 protobuf 编译器能自动生成代码，Protobuf 是将类的定义使用.proto文件进行描述。说明，在idea 中编写 .proto 文件时，会自动提示是否下载 .ptotot 编写插件. 可以让语法高亮 然后通过 protoc.exe 编译器根据.proto 自动生成.java 文件 protobuf 使用示意图 ","date":"2021-07-04","objectID":"/netty/:7:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7.4、Protobuf快速入门实例1 编写程序，使用Protobuf完成如下功能 客户端可以发送一个Student PoJo 对象到服务器 (通过 Protobuf 编码) 服务端能接收Student PoJo 对象，并显示信息(通过 Protobuf 解码) ProtoBuf： syntax = \"proto3\";// 版本 option java_outer_classname = \"StudentPOJO\";// 生成的外部类名，同时也是文件名 // protobuf使用message管理数据 message Student{ // 会在StudentPOJO外部类中生成一个内部类Student，它是真正发送的POJO对象 int32 id =1; // Student类中有一个属性 名字为 id ，类型为int32(protobuf类型)，1表示属性序号，不是值 string name =2; } ProtoBuf生成的xxx.java： package com.clover.netty.codec; // Generated by the protocol buffer compiler. DO NOT EDIT! // source: Student.proto public final class StudentPOJO { private StudentPOJO() {} public static void registerAllExtensions( com.google.protobuf.ExtensionRegistryLite registry) { } public static void registerAllExtensions( com.google.protobuf.ExtensionRegistry registry) { registerAllExtensions( (com.google.protobuf.ExtensionRegistryLite) registry); } public interface StudentOrBuilder extends // @@protoc_insertion_point(interface_extends:Student) com.google.protobuf.MessageOrBuilder { /** * \u003cpre\u003e * 会在StudentPOJO外部类中生成一个内部类Student，它是真正发送的POJO对象 * \u003c/pre\u003e * * \u003ccode\u003eint32 id = 1;\u003c/code\u003e * @return The id. */ int getId(); /** * \u003ccode\u003estring name = 2;\u003c/code\u003e * @return The name. */ java.lang.String getName(); /** * \u003ccode\u003estring name = 2;\u003c/code\u003e * @return The bytes for name. */ com.google.protobuf.ByteString getNameBytes(); } /** * \u003cpre\u003e * protobuf使用message管理数据 * \u003c/pre\u003e * * Protobuf type {@code Student} */ public static final class Student extends com.google.protobuf.GeneratedMessageV3 implements // @@protoc_insertion_point(message_implements:Student) StudentOrBuilder { private static final long serialVersionUID = 0L; // Use Student.newBuilder() to construct. private Student(com.google.protobuf.GeneratedMessageV3.Builder\u003c?\u003e builder) { super(builder); } private Student() { name_ = \"\"; } @java.lang.Override @SuppressWarnings({\"unused\"}) protected java.lang.Object newInstance( UnusedPrivateParameter unused) { return new Student(); } @java.lang.Override public final com.google.protobuf.UnknownFieldSet getUnknownFields() { return this.unknownFields; } private Student( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException { this(); if (extensionRegistry == null) { throw new java.lang.NullPointerException(); } com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(); try { boolean done = false; while (!done) { int tag = input.readTag(); switch (tag) { case 0: done = true; break; case 8: { id_ = input.readInt32(); break; } case 18: { java.lang.String s = input.readStringRequireUtf8(); name_ = s; break; } default: { if (!parseUnknownField( input, unknownFields, extensionRegistry, tag)) { done = true; } break; } } } } catch (com.google.protobuf.InvalidProtocolBufferException e) { throw e.setUnfinishedMessage(this); } catch (java.io.IOException e) { throw new com.google.protobuf.InvalidProtocolBufferException( e).setUnfinishedMessage(this); } finally { this.unknownFields = unknownFields.build(); makeExtensionsImmutable(); } } public static final com.google.protobuf.Descriptors.Descriptor getDescriptor() { return StudentPOJO.internal_static_Student_descriptor; } @java.lang.Override protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable internalGetFieldAccessorTable() { return StudentPOJO.internal_static_Student_fieldAccessorTable .ensureFieldAccessorsInitialized( StudentPOJO.Student.class, StudentPOJO.Student.Builder.class); } public static final int ID_FIELD_NUMBER = 1; private int id_; /** * \u003cpre\u003e * 会在StudentPOJO外部类中生成一个内部类Student，它时真正发送的POJO对象 * \u003c/pre\u003e * * \u003ccode\u003eint32 id = 1;\u003c/code\u003e * @return The id. */ @java.lang.Override public int getId() { return id_; } public static final int NAME_FIELD_NUMBER = 2; private volatile java.lang.Object name_; /** * \u003ccode\u003estring name = 2;\u003c/code\u003e * @return The name. */ @java.lang.Override public java.lang.String getName() { java.l","date":"2021-07-04","objectID":"/netty/:7:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"7.5、Protobuf快速入门实例2 编写程序，使用Protobuf完成如下功能 客户端可以随机发送Student PoJo/ Worker PoJo 对象到服务器 (通过 Protobuf 编码) 服务端能接收Student PoJo/ Worker PoJo 对象(需要判断是哪种类型)，并显示信息(通过 Protobuf 解码) ProtoBuf： syntax = \"proto3\"; option optimize_for = SPEED; // 加快解析 option java_package = \"com.clover.netty.codec2\";// 指定生成到哪个包下 option java_outer_classname = \"MyDataInfo\"; // 指定外部类名称 // protobuf 可以使用message管理其它的message message MyMessage{ // 定义一个枚举类型 enum DateType { StudentType = 0;// 在proto3中，要求enmu下属性的编号从0开始 WorkerType = 1; } // 用data_type来标识传的是哪一个枚举类型 DateType data_type = 1; // 表示每次枚举类型最多只能出现Student、Worker中的一个，节省空间 oneof dataBody { Student student = 2; Worker worker = 3; } } message Student{ int32 id = 1;// Student类的属性 string name =2;// Student类的属性 } message Worker{ string name = 1; int32 age = 2; } ProtoBuf生成的xxx.java： // Generated by the protocol buffer compiler. DO NOT EDIT! // source: Student.proto package com.clover.netty.codec2; public final class MyDataInfo { private MyDataInfo() {} public static void registerAllExtensions( com.google.protobuf.ExtensionRegistryLite registry) { } public static void registerAllExtensions( com.google.protobuf.ExtensionRegistry registry) { registerAllExtensions( (com.google.protobuf.ExtensionRegistryLite) registry); } public interface MyMessageOrBuilder extends // @@protoc_insertion_point(interface_extends:MyMessage) com.google.protobuf.MessageOrBuilder { /** * \u003cpre\u003e * 用data_type来标识传的是哪一个枚举类型 * \u003c/pre\u003e * * \u003ccode\u003e.MyMessage.DateType data_type = 1;\u003c/code\u003e * @return The enum numeric value on the wire for dataType. */ int getDataTypeValue(); /** * \u003cpre\u003e * 用data_type来标识传的是哪一个枚举类型 * \u003c/pre\u003e * * \u003ccode\u003e.MyMessage.DateType data_type = 1;\u003c/code\u003e * @return The dataType. */ com.clover.netty.codec2.MyDataInfo.MyMessage.DateType getDataType(); /** * \u003ccode\u003e.Student student = 2;\u003c/code\u003e * @return Whether the student field is set. */ boolean hasStudent(); /** * \u003ccode\u003e.Student student = 2;\u003c/code\u003e * @return The student. */ com.clover.netty.codec2.MyDataInfo.Student getStudent(); /** * \u003ccode\u003e.Student student = 2;\u003c/code\u003e */ com.clover.netty.codec2.MyDataInfo.StudentOrBuilder getStudentOrBuilder(); /** * \u003ccode\u003e.Worker worker = 3;\u003c/code\u003e * @return Whether the worker field is set. */ boolean hasWorker(); /** * \u003ccode\u003e.Worker worker = 3;\u003c/code\u003e * @return The worker. */ com.clover.netty.codec2.MyDataInfo.Worker getWorker(); /** * \u003ccode\u003e.Worker worker = 3;\u003c/code\u003e */ com.clover.netty.codec2.MyDataInfo.WorkerOrBuilder getWorkerOrBuilder(); public com.clover.netty.codec2.MyDataInfo.MyMessage.DataBodyCase getDataBodyCase(); } /** * \u003cpre\u003e * protobuf 可以使用message管理其它的message * \u003c/pre\u003e * * Protobuf type {@code MyMessage} */ public static final class MyMessage extends com.google.protobuf.GeneratedMessageV3 implements // @@protoc_insertion_point(message_implements:MyMessage) MyMessageOrBuilder { private static final long serialVersionUID = 0L; // Use MyMessage.newBuilder() to construct. private MyMessage(com.google.protobuf.GeneratedMessageV3.Builder\u003c?\u003e builder) { super(builder); } private MyMessage() { dataType_ = 0; } @java.lang.Override @SuppressWarnings({\"unused\"}) protected java.lang.Object newInstance( UnusedPrivateParameter unused) { return new MyMessage(); } @java.lang.Override public final com.google.protobuf.UnknownFieldSet getUnknownFields() { return this.unknownFields; } private MyMessage( com.google.protobuf.CodedInputStream input, com.google.protobuf.ExtensionRegistryLite extensionRegistry) throws com.google.protobuf.InvalidProtocolBufferException { this(); if (extensionRegistry == null) { throw new java.lang.NullPointerException(); } com.google.protobuf.UnknownFieldSet.Builder unknownFields = com.google.protobuf.UnknownFieldSet.newBuilder(); try { boolean done = false; while (!done) { int tag = input.readTag(); switch (tag) { case 0: done = true; break; case 8: { int rawValue = input.readEnum(); dataType_ = rawValue; break; } case 18: { com.clover.netty.codec2.MyDataInfo.Student.Builder subBuilder = null; if (dataBodyCase_ == 2) { subBuilder = ((com.","date":"2021-07-04","objectID":"/netty/:7:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8、Netty编解码器和handler的调用机制 ","date":"2021-07-04","objectID":"/netty/:8:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.1、基本说明 netty的组件设计：Netty的主要组件有Channel、EventLoop、ChannelFuture、ChannelHandler、ChannelPipe等 ChannelHandler充当了处理入站和出站数据的应用程序逻辑的容器。例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据会被业务逻辑处理。当要给客户端发送响应时，也可以从ChannelInboundHandler冲刷数据。业务逻辑通常写在一个或者多个ChannelInboundHandler中。ChannelOutboundHandler原理一样，只不过它是用来处理出站数据的 ChannelPipeline提供了ChannelHandler链的容器。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler，并被这些Handler处理，反之则称为入站的 从不同角度来看，说法不是一样的 出站对应编码，入站对应解码 出站对应写，入站对应读 ","date":"2021-07-04","objectID":"/netty/:8:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.2、编码解码器 当Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节 Netty提供一系列实用的编解码器，他们都实现了ChannelInboundHadnler或者ChannelOutboundHandler接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler ","date":"2021-07-04","objectID":"/netty/:8:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.3、解码器-ByteToMessageDecoder 关系继承图 由于不可能知道远程节点是否会一次性发送一个完整的信息，tcp有可能出现粘包拆包的问题，这个类会对入站数据进行缓冲，直到它准备好被处理 一个关于ByteToMessageDecoder实例分析 public class ToIntegerDecoder extends ByteToMessageDecoder { @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception { if (in.readableBytes() \u003e= 4) { out.add(in.readInt()); } } } 说明： 1、这个例子，每次入站从ByteBuf中读取4字节，将其解码为一个int，然后将它添加到下一个List中。当没有更多元素可以 被添加到该List中时，它的内容将会被发送给下一个ChannelInboundHandler。int在被添加到List中时，会被自动装箱为 Integer。在调用readInt()方法前必须验证所输入的ByteBuf是否具有足够的数据 2、 decode 执行分析图 [示意图] ","date":"2021-07-04","objectID":"/netty/:8:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.4、Netty的handler链的调用机制 实例要求: 使用自定义的编码器和解码器来说明Netty的handler 调用机制，客户端发送long -\u003e 服务器，服务端发送long -\u003e 客户端 案例演示 结论 不论解码器handler 还是 编码器handler 即接收的消息类型必须与待处理的消息类型一致，否则该handler不会被执行 在解码器进行数据解码时，需要判断缓存区(ByteBuf)的数据是否足够，否则接收到的结果会与期望结果不一致 服务器端： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; public class MyServer { public static void main(String[] args) throws Exception{ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());// 自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(11864).sync(); channelFuture.channel().closeFuture().sync(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 服务器端自定义初始化类： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; public class MyServerInitializer extends ChannelInitializer\u003cSocketChannel\u003e { @Override protected void initChannel(SocketChannel ch) throws Exception { // 获取到pipeline ChannelPipeline pipeline = ch.pipeline(); // 加入相关的handler // 入栈的handler进行解码 MyByteToLongDecoder pipeline.addLast(\"decoder\",new MyByteToLongDecoder2()); // 这是一个出站的编码器(出战handler) pipeline.addLast(\"encoder\",new MyLongToByteEncoder()); // 加入自定义handler pipeline.addLast(new MyServerHandler()); } } 解码器： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.ByteToMessageDecoder; import java.util.List; public class MyByteToLongDecoder extends ByteToMessageDecoder { /* * decode 会根据接收的数据，被调用多次，直到没有新的元素被添加到list * 或者是ByteBuf 没有更多的可读字节为止 * 如果list out不为空，就会将list的内容传递给下一个channelinboundhandler处理，该处理器的方法也会被调用多次 * * ctx 上下文集合 * in 入栈的Bytebuf * out List集合，将解码后的数据传给下一个handler */ @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception { System.out.println(\"MyByteToLongDecoder 被调用\"); // 因为 long 8个字节,需要判断有8个字节才能读取一个long if (in.readableBytes() \u003e=8){ out.add(in.readLong()); } } } 服务器端自定义handler： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; public class MyServerHandler extends SimpleChannelInboundHandler\u003cLong\u003e { @Override protected void channelRead0(ChannelHandlerContext ctx, Long msg) throws Exception { System.out.println(\"从客户端：\" + ctx.channel().remoteAddress() + \"读取到long\" + msg); // 给客户端回送数据 ctx.writeAndFlush(98765L); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } 客户端： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; public class MyClient { public static void main(String[] args) throws Exception{ EventLoopGroup group = new NioEventLoopGroup(); try{ Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer());// 自定义一个初始化类 ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 11864).sync(); channelFuture.channel().closeFuture().sync(); } finally{ group.shutdownGracefully(); } } } 客户端自定义初始化类： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.net","date":"2021-07-04","objectID":"/netty/:8:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.5、解码器-ReplayingDecoder public abstract class ReplayingDecoder\u003c S \u003e extends ByteToMessageDecoder ReplayingDecoder扩展了ByteToMessageDecoder类，使用这个类，我们不必调用readableBytes()方法。参数S指定了用户状态管理的类型，其中Void代表不需要状态管理 应用实例：使用ReplayingDecoder 编写解码器，对前面的案例进行简化 [案例演示] ReplayingDecoder使用方便，但它也有一些局限性： 并不是所有的 ByteBuf 操作都被支持，如果调用了一个不被支持的方法，将会抛出一个 UnsupportedOperationException ReplayingDecoder 在某些情况下可能稍慢于 ByteToMessageDecoder，例如网络缓慢并且消息格式复杂时，消息会被拆成了多个碎片，速度变慢 案例演示： package com.clover.netty.inboundhandlerandoutboundhandler; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.ReplayingDecoder; import java.util.List; public class MyByteToLongDecoder2 extends ReplayingDecoder\u003cVoid\u003e { @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception { System.out.println(\"MyByteToLongDecoder 被调用\"); // 在ReplayingDecoder 中不需要判断数据是否足够获取，内部会进行处理判断 out.add(in.readLong()); } } ","date":"2021-07-04","objectID":"/netty/:8:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"8.6、其它编解码器 LineBasedFrameDecoder：这个类在Netty内部也有使用，它使用行尾控制字符（\\n或者\\r\\n）作为分隔符来解析数据 DelimiterBasedFrameDecoder：使用自定义的特殊字符作为消息的分隔符 HttpObjectDecoder：一个HTTP数据的解码器 LengthFieldBasedFrameDecoder：通过指定长度来标识整包消息，这样就可以自动的处理黏包和半包消息 ","date":"2021-07-04","objectID":"/netty/:8:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"9、TCP 粘包和拆包 及解决方案 ","date":"2021-07-04","objectID":"/netty/:9:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"9.1、TCP 粘包和拆包基本介绍 TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有一一成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的 由于TCP无消息保护边界, 需要在接收端处理消息边界问题，也就是我们所说的粘包、拆包问题, 看一张图 TCP粘包、拆包图解 假设客户端分别发送了两个数据包D1和D2给服务端，由于服务端一次读取到字节数是不定的，故可能存在以下四种情况： 服务端分两次读取到了两个独立的数据包分别是D1和D2，没有粘包和拆包 服务端一次接受到了两个数据包，D1和D2粘合在一起，称之为TCP粘包 服务端分两次读取到了数据包，第一次读取到了完整的D1包和D2包的部分内容，第二次读取到了D2包的剩余内容，这称之为TCP拆包 服务端分两次读取到了数据包，第一次读取到了D1包的部分内容D1_1，第二次读取到了D1包的剩余部分内容D1_2和完整的D2包。 ","date":"2021-07-04","objectID":"/netty/:9:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"9.2、TCP粘包和拆包案例 在编写Netty 程序时，如果没有做处理，就会发生粘包和拆包的问题 具体案例： 服务端： package com.clover.netty.tcp; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; public class MyServer { public static void main(String[] args) throws Exception{ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());// 自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(11864).sync(); channelFuture.channel().closeFuture().sync(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 服务端初始化类： package com.clover.netty.tcp; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; public class MyServerInitializer extends ChannelInitializer\u003cSocketChannel\u003e { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyServerHandler()); } } 服务器端自定义handler： package com.clover.netty.tcp; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import java.nio.charset.Charset; import java.util.UUID; public class MyServerHandler extends SimpleChannelInboundHandler\u003cByteBuf\u003e { private int count; @Override protected void channelRead0(ChannelHandlerContext ctx, ByteBuf msg) throws Exception { // 将msg转换为一个字节数组 byte[] buf = new byte[msg.readableBytes()]; msg.readBytes(buf); // 将buf转成字符串 String message = new String(buf, Charset.forName(\"utf-8\")); System.out.println(\"服务器接收到数据 \" + message); System.out.println(\"服务器端接收到消息量=\" + (++this.count)); // 服务器回送数据给客户端,回送一个随机Id ByteBuf responseByteBuf = Unpooled.copiedBuffer(UUID.randomUUID().toString() + \" \", Charset.forName(\"utf-8\")); ctx.writeAndFlush(responseByteBuf); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } 客户端： package com.clover.netty.tcp; import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioSocketChannel; public class MyClient { public static void main(String[] args) throws Exception{ EventLoopGroup group = new NioEventLoopGroup(); try{ Bootstrap bootstrap = new Bootstrap(); bootstrap.group(group) .channel(NioSocketChannel.class) .handler(new MyClientInitializer());// 自定义一个初始化类 ChannelFuture channelFuture = bootstrap.connect(\"localhost\", 11864).sync(); channelFuture.channel().closeFuture().sync(); } finally{ group.shutdownGracefully(); } } } 客户端初始化类： package com.clover.netty.tcp; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; public class MyClientInitializer extends ChannelInitializer\u003cSocketChannel\u003e { @Override protected void initChannel(SocketChannel ch) throws Exception { // 获取pipeline ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyClientHandler()); } } 客户端端自定义handler： package com.clover.netty.tcp; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import java.nio.charset.Charset; public class MyClientHandler extends SimpleChannelInboundHandler\u003cByteBuf\u003e { private int count; @Override public void channelActive(ChannelHandlerContext ctx) throws Exception { // 使用客户端发送10条数据，hello，server 编号 for (int i = 0; i \u003c 10; i++){ ByteBuf buf = Unpooled.copiedBuffer(\"hello,server\" + i, Charset.for","date":"2021-07-04","objectID":"/netty/:9:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"9.3、TCP粘包和拆包解决方案 使用自定义协议 + 编解码器 来解决 关键就是要解决 服务器端每次读取数据长度的问题, 这个问题解决，就不会出现服务器多读或少读数据的问题，从而避免的TCP 粘包、拆包 看一个具体的实例: 要求客户端发送 5 个 Message 对象, 客户端每次发送一个 Message 对象 服务器端每次接收一个Message, 分5次进行解码， 每读取到 一个Message , 会回复一个Message 对象 给客户端 协议类： package com.clover.netty.protocoltcp; // 协议包 public class MessageProtocol { private int len;// 定义长度，关键 private byte[] content;// 要发送的内容 public int getLen() { return len; } public void setLen(int len) { this.len = len; } public byte[] getContent() { return content; } public void setContent(byte[] content) { this.content = content; } } 服务端： package com.clover.netty.protocoltcp; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.nio.NioServerSocketChannel; public class MyServer { public static void main(String[] args) throws Exception{ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new MyServerInitializer());// 自定义一个初始化类 ChannelFuture channelFuture = serverBootstrap.bind(11864).sync(); channelFuture.channel().closeFuture().sync(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 服务端初始化类： package com.clover.netty.protocoltcp; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.socket.SocketChannel; public class MyServerInitializer extends ChannelInitializer\u003cSocketChannel\u003e { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new MyMessageEncoder());// 编码器 pipeline.addLast(new MyMessageDecoder());// 解码器 pipeline.addLast(new MyServerHandler()); } } 解码器： package com.clover.netty.protocoltcp; import io.netty.buffer.ByteBuf; import io.netty.channel.ChannelHandlerContext; import io.netty.handler.codec.ReplayingDecoder; import java.util.List; public class MyMessageDecoder extends ReplayingDecoder\u003cVoid\u003e { @Override protected void decode(ChannelHandlerContext ctx, ByteBuf in, List\u003cObject\u003e out) throws Exception { System.out.println(\"MyMessageDecoder decode方法被调用\"); // 这里需要将得到的二进制字节码进行转换，转换为MessageProtocol数据包(对象) int length = in.readInt(); // 通过得到字节的长度来获取到对应的内容 byte[] content = new byte[length]; in.readBytes(content); // 封装成MessageProtocol对象，放入list中，传递给下一个handler进行业务处理 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(length); messageProtocol.setContent(content); out.add(messageProtocol); } } 服务器端自定义handler： package com.clover.netty.protocoltcp; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.SimpleChannelInboundHandler; import java.nio.charset.Charset; import java.util.UUID; // 处理业务的handler public class MyServerHandler extends SimpleChannelInboundHandler\u003cMessageProtocol\u003e { private int count; @Override protected void channelRead0(ChannelHandlerContext ctx, MessageProtocol msg) throws Exception { // 接收到数据并处理 int len = msg.getLen(); byte[] content = msg.getContent(); System.out.println(\"服务端接收到信息如下：\"); System.out.println(\"长度 =\" + len); System.out.println(\"内容 =\" + new String(content,Charset.forName(\"utf-8\"))); System.out.println(\"服务器接收到消息包数量 =\" + (++this.count)); // 回复消息 String responseContent = UUID.randomUUID().toString(); byte[] responseContentBytes = responseContent.getBytes(\"utf-8\"); int responseLength = responseContent.getBytes(Charset.forName(\"utf-8\")).length; // 构建一个协议包 MessageProtocol messageProtocol = new MessageProtocol(); messageProtocol.setLen(responseLength); messageProtocol.setContent(responseContentBytes); ctx.writeAndFlush(messageProtocol); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { cause.printStackTrace(); ctx.close(); } } 客户端： package com.clover.netty.protocoltcp;","date":"2021-07-04","objectID":"/netty/:9:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10、Netty核心源码剖析 ","date":"2021-07-04","objectID":"/netty/:10:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.1、基本说明 只有看过Netty源码，才能说是真的掌握了Netty框架 在 io.netty.example 包下，有很多Netty源码案例，可以用来分析 ","date":"2021-07-04","objectID":"/netty/:10:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.2、Netty 启动过程源码剖析 10.2.1、源码剖析目的 用源码分析的方式走一下 Netty （服务器）的启动过程，更好的理解Netty 的整体设计和运行机制 10.2.2、源码剖析 说明： 源码需要剖析到Netty 调用doBind方法， 追踪到 NioServerSocketChannel的doBind 并且要Debug 程序到 NioEventLoop类 的run代码 ，无限循环，在服务器端运行 10.2.3、源码剖析过程 1、demo源码的基本理解 /* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */ package com.clover.netty.source.echo; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.*; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.logging.LogLevel; import io.netty.handler.logging.LoggingHandler; import io.netty.handler.ssl.SslContext; import io.netty.handler.ssl.SslContextBuilder; import io.netty.handler.ssl.util.SelfSignedCertificate; /** * Echoes back any received data from a client. */ public final class EchoServer { static final boolean SSL = System.getProperty(\"ssl\") != null; static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8007\")); public static void main(String[] args) throws Exception { // Configure SSL. final SslContext sslCtx; if (SSL) { SelfSignedCertificate ssc = new SelfSignedCertificate(); sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build(); } else { sslCtx = null; } // Configure the server. EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try { ServerBootstrap b = new ServerBootstrap(); b.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .option(ChannelOption.SO_BACKLOG, 100) .handler(new LoggingHandler(LogLevel.INFO)) .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override public void initChannel(SocketChannel ch) throws Exception { ChannelPipeline p = ch.pipeline(); if (sslCtx != null) { p.addLast(sslCtx.newHandler(ch.alloc())); } //p.addLast(new LoggingHandler(LogLevel.INFO)); p.addLast(new EchoServerHandler()); } }); // Start the server. ChannelFuture f = b.bind(PORT).sync(); // Wait until the server socket is closed. f.channel().closeFuture().sync(); } finally { // Shut down all event loops to terminate all threads. bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } 说明： 1.先看启动类：main方法中，首先创建了关于SSL的配置类 2.重点分析创建的两个EventLoopGroup对象 EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); 1.这两个对象是整个Netty的核心对象，可以说，整个Netty的运作都依赖于他们。bossGroup用于接收TCP请求，它会将 请求交给workerGroup，workerGroup会获取到真正的连接，然后和连接进行通信，比如读写解码编码等操作 2.EventLoopGroup是事件循环组(线程组) 含有多个EventLoop，可以注册channel， 用于在事件循环中去进行选择(和选择器相关) [debug查看] 3.new NioEventLoopGroup(1);这个1表示bossGroup事件组有一个线程你可以指定，如果new NioEventLoopGroup(); 不给参数，会有默认个线程cpu核数*2，即可以充分利用多核的优势 DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt( \"io.netty.eventLoopThreads\", NettyRuntime.availableProcessors() * 2)); 4.会创建EventExecutor数组 children = new EventExecutor[nThreads]; [debug查看] 5.每个元素的类型就是NioEventLoop，NioEventLoop 实现了 EventLoop 接口和 Executor 接口 6.try代码块中创建了一个ServerBootstrap对象，它是一个引导类，用于启动服务器和引导整个程序的初始化 (看下源码 allow easy bootstrap of {@link ServerChannel})，它和ServerChannel关联，而ServerChannel继承了 Channel，有一些remoteAddress等 [debug查看] 随后，变量b调用了group方法将两个group放入自己的字段中， 用于后期引导使用 7.然后添加了一个channel，其中一个参数是Class对象，引导类将通过这个Class对象反射创建ChannelFactory。 然后添加了一些TCP参数。[说明：Channel的创建在bind方法，可以Debug下bind， 会找到channel = channelFactory.newChannel();] 8.再添加了一个服务器专属的日志处理器handler 9.再添加一个SocketChannel(不是ServerSock","date":"2021-07-04","objectID":"/netty/:10:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.3、Netty接收请求过程源码剖析 10.3.1、源码剖析目的 服务区启动后肯定要接受客户端请求并返回客户端想要的信息，下面源码分析Netty在启动之后是如何接受客户端请求的 在 io.netty.example下 10.3.2、源码剖析 从之前服务器启动的源码中，我们得知，服务器最终注册了一个Accept事件等待客户端连接。我们也知道，NioServerSockerChannel 将自己注册到了boss 单例线程池(reactor线程)上，也就是EventLoop 简单说下EventLoop的逻辑 EventLoop的作用是一个死循环，该循环中做三件事情 有条件的等待nio事件 处理nio事件 处理消息队列中的任务 仍用前面的项目来分析：进入到NioEventLoop 源码中后，在 private void processSelectedKey(SelectionKey k,AbstractNioChannel ch) 方法开始调试 最终我们要分析到AbstractNioChannel 的 doBeginRead 方法，当到这个方法时，针对于这个客户端的连接就完成了，接下来就可以监听读事件了 源码分析过程 1、断点位置 NioEventLoop 的如下方法 processSelectedKey if ((readyOps \u0026 (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) { unsafe.read(); // 断点位置 } 2、在浏览器输入ip+端口号，进行连接，即客户端发出请求 3、从断点我们可以看到，readyOps 是16，也就是 Accept 事件，说明浏览器请求已经进来了 4、这个 unsafe 是 boss 线程中 NioServerSocketChannel 继承了 AbstractNioMessageChannel 类中内部类 NioMessageUnsafe 对象，进入到 AbstractNioMessageChannel 类的内部类 NioMessageUnsafe 的read 方法中 5、read 方法代码分析 @Override public void read() { assert eventLoop().inEventLoop(); final ChannelConfig config = config(); final ChannelPipeline pipeline = pipeline(); final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle(); allocHandle.reset(config); boolean closed = false; Throwable exception = null; try { try { do { int localRead = doReadMessages(readBuf); if (localRead == 0) { break; } if (localRead \u003c 0) { closed = true; break; } allocHandle.incMessagesRead(localRead); } while (allocHandle.continueReading()); } catch (Throwable t) { exception = t; } int size = readBuf.size(); for (int i = 0; i \u003c size; i ++) { readPending = false; pipeline.fireChannelRead(readBuf.get(i)); } readBuf.clear(); allocHandle.readComplete(); pipeline.fireChannelReadComplete(); if (exception != null) { closed = closeOnReadError(exception); pipeline.fireExceptionCaught(exception); } if (closed) { inputShutdown = true; if (isOpen()) { close(voidPromise()); } } } finally { // Check if there is a readPending which was not processed yet. // This could be for two reasons: // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method // // See https://github.com/netty/netty/issues/2254 if (!readPending \u0026\u0026 !config.isAutoRead()) { removeReadOp(); } } } 说明： 1、assert eventLoop().inEventLoop(); 检查该 eventloop线程是否是当前线程 2、执行 doReadMessages 方法，并传入一个 readBuf 变量，这个变量是一个 List，也就是容器 3、循环容器，执行 pipeline.fireChannelRead(readBuf.get(i)); 4、doReadMessages 是读取 boss 线程中 NioServerSockerChannel 接收到的请求。并把这些请求放进容器 5、循环遍历容器中的所有请求，调用 pipeline 的 fireChannelRead 方法，用于处理这些接受的请求或者其它事件， 在 read 方法中，循环调用 ServerSocket 的 pipeline 的 fireChannelRead 方法，开始执行管道中 handler 的 ChannelRead 方法进入 6、追踪 doReadMessages 方法 @Override protected int doReadMessages(List\u003cObject\u003e buf) throws Exception { SocketChannel ch = SocketUtils.accept(javaChannel()); try { if (ch != null) { buf.add(new NioSocketChannel(this, ch)); return 1; } } catch (Throwable t) { logger.warn(\"Failed to create a new channel from an accepted socket.\", t); try { ch.close(); } catch (Throwable t2) { logger.warn(\"Failed to close a socket.\", t2); } } return 0; } 说明： 1、通过 SocketUtils 工具类，调用 NioServerSockerChannel 内部封装的 serverSocketChannel 的 accept 方法，这是 NIO 做法 2、获取到了一个 JDK 的 SocketChannel ，然后，使用 NioSocketChannel 进行封装。最后添加到容器中 3、这样容器 buf 中就有了 NioSocketChannel 7、回到 read 方法，继续分析 循环执行 pipeline.fireChannelRead 方法 前面分析 doReadMessage 方法的作用是通过 ServerSocket 的 accept 方法获取到TCP连接，然后封装成 Netty 的 NioSocketChannel 对象。最后添加到 容器中 在 read 方法中，循环调用 ServerSocket 中 pipeline 的 fireChannelRead 方法，开始执行管道中 handler 的ChannelRead 方法 经过debug多次，可以看到会反复执行多个 handler 的 ChannelRead ，我们知道， pipeline 里面有四个 handler ，分别是 Head，LoggingHandler，ServerBootstrapAcceptor，Tail 重点查看 ServerBootstrapAcceptor 。debug之后，断点会进入到 ServerBootstrapAcceptor中来，查看 ServerBootstrapAcceptor 的 channelRead 方法(要多次debug) channelRead方法 @Override @SuppressWarnings(\"unchecked\") public void channelRead(ChannelHandlerContext ctx, Object msg) { final Channel child =","date":"2021-07-04","objectID":"/netty/:10:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.4、Pipeline Handler HandlerContext创建源码剖析 10.4.1、源码剖析目的 Netty 中的 ChannelPipeline 、 ChannelHandler 和 ChannelHandlerContext 是非常核心的组件, 我们从源码来分析Netty 是如何设计这三个核心组件的，并分析是如何创建和协调工作的 10.4.2、源码剖析 1、ChannelPipeline 、 ChannelHandler 和 ChannelHandlerContext 介绍 1.1 三者关系 1、每当 ServerSocket 创建一个新的连接，就会创建一个 Socket，对应的就是目标客户端 2、每一个新创建的 Socket 都将会分配一个全新的 ChannelPipeline (以下简称 pipeline) 3、每一个 ChannelPipeline 内部都含有多个 ChannelHandlerContext (以下简称 Context) 4、他们一起组成了双向链表，这些 Context 用于包装我们调用 addLast 方法时添加的 ChannelHandler (以下简称handler) 1、上图中：ChannelSocket 和 ChannelPipeline 是一对一的关联关系，而 pipeline 内部的多个 Context 形成了链表， Context 只是对 Handler 的封装 2、当一个请求进来的时候，会进入 Socket 对应的pipeline，并经过 pipeline 所有的 handler 对，就是设计模式中的过滤器模式 2、ChannelPipeline 作用及设计 1、pipeline 的接口设计 该接口继承了 inBound、outBound、Iterable 接口，表示它可以调用数据出站的方法和入站的方法，同时也能遍历内部的链表，它的几个代表性的方法，基本上都是针对 handler 链表的插入、追加、删除、替换操作，类似是一个 LinkeList。同时，也能返回 channel (也就是socket) 对上图的解释和说明 这是一个 handler 的 list，handler 用于处理或拦截入站事件和出站事件，pipeline 实现了过滤器的高级形式，方便用户控制事件如何处理以及 handler 在 pipeline 中如何交互 上图描述了一个典型的 handler 在 pipeline 中处理I/O 事件的方式，IO 事件由 inboundHandler 或者 outboundHandler 处理，并通过调用 ChannelHandlerContext.fireChannelRead 方法转发给其最近的处理程序 入站事件由入站处理程序以自下而上的方向处理，如图所示，入站处理程序通常处理由图底部的 IO 线程生成入站数据，入站数据通常从如 SocketChannel.read(ByteBuffer) 获取 通常一个 pipeline 有多个 handler，例如，一个典型的服务器在每个通道的管道中都会有以下处理程序 协议解码器 – 将二进制数据转换为Java对象 协议编码器 – 将Java对象转换为二进制数据 业务逻辑处理程序 – 执行实际业务逻辑 你的业务程序不能将线程阻塞，会影响 IO 速度，进而影响整个 Netty 程序的性能。如果你的业务程序很快，就可以放在 IO 线程中，反之，你需要异步执行，如之前的3中Task；或者在添加 handler 的时候添加一个线程池，例如 pipeline.addLast(group,“handler”,new MyBusinessLogicHandler()) 3、 ChannelHandler 作用及设计 public interface ChannelHandler { // 当 ChannelHandler 添加 pipeline 时被调用 void handlerAdded(ChannelHandlerContext ctx) throws Exception; // 当 从pipeline 中移除时调用 void handlerRemoved(ChannelHandlerContext ctx) throws Exception; // 当处理过程中在 pipeline 发生异常时调用 @Deprecated void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception; } ChannelHandler 的作用就是处理 IO 事件或拦截 IO 事件，并将其转发给下一个处理程序 ChannelHandler。Handler 处理 事件时分入站和出站的，两个方向的操作都是不同的，因此，Netty 定义了两个子接口继承 ChannelHandler 1、ChannelInboundHandler 入站事件接口 channelActive 用于当 Channel 处于活动状态时被调用 channelRead 当从 channel 读取数据时被调用 程序员需要重写一些方法，当发生关注的事件，需要在方法中实现我们的业务逻辑，因此当事件发生时，Netty 会回调对应的方法 2、ChannelOutboundHandler 出战事件接口 bind 方法，当请求将 channel 绑定到本地地址时调用 close 方法，当请求关闭 channel 时调用 出站操作都是一些连接和写出数据类似的方法 3、ChannelDuplexHandler ChannelDuplexHandler 间接实现了入站接口并直接实现了出战接口 是一个通用的能够同时处理入站事件和出站事件的类 现实中尽量不要使用 ChannelDuplexHandler 因为它既可读也可写，容易弄混淆 4、ChannelHandlerContext ChannelHandlerContext 继承了出站方法调用接口和入站方法调用接口 ChannelOutboundInvoker 和 ChannelInboundInvoker 结构 这两个 invoker 就是针对入站或出站方法来的，就是在入站或出站 handler 的外层再包装一层，达到再方法前后拦截并做一些特定操作的目的 ChannelHandlerContext 结构 ChannelHandlerContext 不仅仅是继承了他们两个的方法，同时也定义了一些自己的方法 这些方法能够获取 Context 上下文环境中对应的 channel、executor、handler、pipeline、内存分配器、关联的 handler 是否被删除 Context 就是包装了 handler 相关的一切，以方便 Context 可以再pipeline 方便的操作 handler 5、ChannelPipeline 、 ChannelHandler 和 ChannelHandlerContext 创建过程 分为三步骤来看创建过程 任何一个 ChannelSocket 创建的同时都会创建一个 pipeline 当用户或系统内部调用 pipeline 的 add*** 方法添加 handler 时，都会创建一个包装这个 handler 的Context 这些 Context 在 pipeline 中组成了双向链表 Socket 创建的时候创建 pipeline // 在 SocketChannel 的抽象父类 AbstractChannel 的构造方法中 protected AbstractChannel(Channel parent) { this.parent = parent; id = newId(); unsafe = newUnsafe(); pipeline = newChannelPipeline(); } // Debug后，代码会执行到这里，继续追踪 protected DefaultChannelPipeline(Channel channel) { this.channel = ObjectUtil.checkNotNull(channel, \"channel\"); succeededFuture = new SucceededChannelFuture(channel, null); voidPromise = new VoidChannelPromise(channel, true); tail = new TailContext(this); head = new HeadContext(this); head.next = tail; tail.prev = head; } 说明： 1、将 channel 赋值给 channel 字段，用于 pipeline 操作 channel 2、创建一个 future 和 promise，用于异步回调 3、创建一个 inbound 的 tailContext，创建一个既是 inbound 类型又是 outbound 类型的 headContext 4、最后，将两个 Context 互相连接，形成双向链表 在 add— 添加处理器的时候创建 Context—- 查看 DefaultChannelPipeline 的 addLast 方法如何创建的 Context @Override public final ChannelPipeline addLast(EventExecutorGroup ","date":"2021-07-04","objectID":"/netty/:10:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.5、ChannelPipeline 调度 handler 的源码剖析 10.5.1、源码剖析的目的 当一个请求进来的时候，ChannelPipeline 是如何调用内部的这些 handle 的呢？ 首先，当一个请求进来的时候，会第一个调用 pipeline 的相关方法，如果是入站事件，这些方法由 fire 开头，表示管道的流动，让后面的 handler 继续处理 10.5.2、源码剖析 当浏览器输入 http://localhost:8007/，可以看到会执行的handler 在 Debug 时，可以将断点下在 DefaultChannelPipeline类 @Override public final ChannelPipeline fireChannelActive() { AbstractChannelHandlerContext.invokeChannelActive(head); return this; } 10.5.3、源码分析 pipeline 的 inbound 的 fire 方法实现 @Override public final ChannelPipeline fireChannelActive() { AbstractChannelHandlerContext.invokeChannelActive(head); return this; } @Override public final ChannelPipeline fireChannelInactive() { AbstractChannelHandlerContext.invokeChannelInactive(head); return this; } @Override public final ChannelPipeline fireExceptionCaught(Throwable cause) { AbstractChannelHandlerContext.invokeExceptionCaught(head, cause); return this; } @Override public final ChannelPipeline fireUserEventTriggered(Object event) { AbstractChannelHandlerContext.invokeUserEventTriggered(head, event); return this; } @Override public final ChannelPipeline fireChannelRead(Object msg) { AbstractChannelHandlerContext.invokeChannelRead(head, msg); return this; } @Override public final ChannelPipeline fireChannelReadComplete() { AbstractChannelHandlerContext.invokeChannelReadComplete(head); return this; } @Override public final ChannelPipeline fireChannelWritabilityChanged() { AbstractChannelHandlerContext.invokeChannelWritabilityChanged(head); return this; } 说明： 1、这些方法都是 inbound 方法，也就是入站事件，调用静态方法传入也是 inbound 类型的 head handler。 2、这些静态方法则会调用 head 的 ChannelInboundInvoker 接口的方法，然后调用 handler 的真正方法 pipeline 的 outbound 的 fire 方法实现 @Override public final ChannelFuture bind(SocketAddress localAddress) { return tail.bind(localAddress); } @Override public final ChannelFuture connect(SocketAddress remoteAddress) { return tail.connect(remoteAddress); } @Override public final ChannelFuture connect(SocketAddress remoteAddress, SocketAddress localAddress) { return tail.connect(remoteAddress, localAddress); } @Override public final ChannelFuture disconnect() { return tail.disconnect(); } @Override public final ChannelFuture close() { return tail.close(); } @Override public final ChannelFuture deregister() { return tail.deregister(); } @Override public final ChannelPipeline flush() { tail.flush(); return this; } @Override public final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) { return tail.bind(localAddress, promise); } @Override public final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) { return tail.connect(remoteAddress, promise); } @Override public final ChannelFuture connect( SocketAddress remoteAddress, SocketAddress localAddress, ChannelPromise promise) { return tail.connect(remoteAddress, localAddress, promise); } @Override public final ChannelFuture disconnect(ChannelPromise promise) { return tail.disconnect(promise); } 说明： 1、这些都是出站的实现，但是调用的是 outbound 类型的 tail handler 来进行处理的，因为这些都是 outbound 事件 2、出站是 tail 开始，入站从 head 开始。因为出站是从内部向外面写，从 tail 开始，能够让前面的 handler 进行处理， 防止 handler 被遗漏，比如编码。反之，入站当然是从 head 往内部输入，让后面的 handler 能够处理这些输入的数据。 比如解码。因此虽然 head 也实现了 outbound 接口，单不是从 head 开始执行出站任务 说明： 1、pipeline 首先会调用 Context 的静态方法 fireXXX，并传入 Context 2、然后，静态方法调用 Context 的 invoker 方法，而 invoker 方法内部会调用该 Context 所包含的 Handler 的真正 XXX 方法，调用结束后，如果还需要继续往后传递，就调用 Context 的 fireXXX2 方法，循环往复 10.5.4、Channel Pipeline 调度 handler 梳理 Context 包装 handler，多个 Context 在 pipeline 中形成了双向链表，入站方向叫 inbound，由 head 节点开始，出站方法叫 outbound ，由 tail 节点开始 而节点中间的传递通过 AbstractChannelHandlerContext 类内部的 fire 系列方法，找到当前节点的下一个节点不断的循环传播。是一个过滤器形式完成对handler 的调度 ","date":"2021-07-04","objectID":"/netty/:10:5","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.6、Netty 心跳(heartbeat)服务源码剖析 源码剖析目的 Netty 作为一个网络框架，提供了诸多功能，比如编码解码等，Netty 还提供了非常重要的一个服务—–心跳机制heartbeat。通过心跳检查对方是否有效，这是 RPC 框架中是必不可少的功能。下面我们分析一下Netty内部心跳服务源码实现 源码剖析 Netty 提供了 IdleStateHandler ，ReadTimeoutHandler，WriteTimeoutHandler 三个Handler 检测连接的有效性，重点分析 IdleStateHandler 10.6.1、IdleStateHandler 分析 4 个属性 private final boolean observeOutput; // 是否考虑出站时比较慢的情况。默认值是false private final long readerIdleTimeNanos; // 读事件空闲时间，0 代表禁用事件 private final long writerIdleTimeNanos; // 写事件空闲事件，0 代表禁用事件 private final long allIdleTimeNanos; // 读或写空闲事件，0 代表禁用事件 handlerAdded 方法；当该 handler 被添加到 pipeline 中时，则调用 initialize 方法 private void initialize(ChannelHandlerContext ctx) { // Avoid the case where destroy() is called before scheduling timeouts. // See: https://github.com/netty/netty/issues/143 switch (state) { case 1: case 2: return; } state = 1; // 重要方法！！！！！ initOutputChanged(ctx); lastReadTime = lastWriteTime = ticksInNanos(); if (readerIdleTimeNanos \u003e 0) { // 这里的 schedule 方法会调用 eventLoop 的 schedule 方法，将定时任务添加进队列任务中 readerIdleTimeout = schedule(ctx, new ReaderIdleTimeoutTask(ctx), readerIdleTimeNanos, TimeUnit.NANOSECONDS); } if (writerIdleTimeNanos \u003e 0) { writerIdleTimeout = schedule(ctx, new WriterIdleTimeoutTask(ctx), writerIdleTimeNanos, TimeUnit.NANOSECONDS); } if (allIdleTimeNanos \u003e 0) { allIdleTimeout = schedule(ctx, new AllIdleTimeoutTask(ctx), allIdleTimeNanos, TimeUnit.NANOSECONDS); } } 说明： 只要给定的参数大于 0 ，就创建一个定时任务，每个事件都创建。同时，将 state 状态设置为 1，防止重复初始化，调用 initOutputChanged 方法，初始化“监控出站数据属性” 该内部类的 3 个定时任务类 这三个定时任务分别对应 读、写、读或者写 事件，共有一个父类(AbstractIdleTask)。这个父类提供了一个模板方法 private abstract static class AbstractIdleTask implements Runnable { private final ChannelHandlerContext ctx; AbstractIdleTask(ChannelHandlerContext ctx) { this.ctx = ctx; } @Override public void run() { if (!ctx.channel().isOpen()) { return; } run(ctx); } protected abstract void run(ChannelHandlerContext ctx); } 说明：当通道关闭了，就不执行任务了，反之，执行子类的 run 方法 读事件的 run 方法(即 ReadIdleTimeoutTask 的run 方法)分析 private final class ReaderIdleTimeoutTask extends AbstractIdleTask { ReaderIdleTimeoutTask(ChannelHandlerContext ctx) { super(ctx); } @Override protected void run(ChannelHandlerContext ctx) { long nextDelay = readerIdleTimeNanos; if (!reading) { // ticksInNanos()：当前时间 // lastReadTime：上次最后1次读的时间 // nextDelay：设置的超时时间 nextDelay -= ticksInNanos() - lastReadTime; } if (nextDelay \u003c= 0) { // Reader is idle - set a new timeout and notify the callback. // 用于取消任务 promise readerIdleTimeout = schedule(ctx, this, readerIdleTimeNanos, TimeUnit.NANOSECONDS); boolean first = firstReaderIdleEvent; firstReaderIdleEvent = false; try { // 再次提交任务 IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first); channelIdle(ctx, event); } catch (Throwable t) { ctx.fireExceptionCaught(t); } } else { // Read occurred before the timeout - set a new timeout with shorter delay. readerIdleTimeout = schedule(ctx, this, nextDelay, TimeUnit.NANOSECONDS); } } } 说明： 1、得到用户设置的超时事件 2、如果读取操作结束了(执行了 channelReadComplete 方法设置)，就用设置时间-(给定时间-上次最后一次读的 时间的结果)，如果小于 0 ，就触发事件。反之，继续放入队列。间隔时间是新的计算时间 3、触发的逻辑是：首先将任务再次放到队列，时间是设置的超时时间，返回一个 promise 对象，用于做取消操作， 然后，设置 first 属性为 false，表示下一次读取不再是第一次了，这个属性在 channelRead 方法会被改成 true 4、创建一个 IdleStateEvent 类型的写事件对象，将次对象传递给用户的 UserEventTriggered 方法，完成触发事件操作 5、总的来说，每次读取操作都会记录一个时间，定时任务时间到了，会计算当前时间和最后一次读的时间的间隔，如果 时间间隔超过了设置的时间，就触发 UserEventTriggered 方法（前面写心跳机制案例时提到过的自定义handler名） 写事件的 run 方法(即 WriterIdleTimeoutTask 的run 方法)分析 private final class WriterIdleTimeoutTask extends AbstractIdleTask { WriterIdleTimeoutTask(ChannelHandlerContext ctx) { super(ctx); } @Override protected void run(ChannelHandlerContext ctx) { long lastWriteTime = IdleStateHandler.this.lastWriteTime; long nextDelay = writerIdleTimeNanos - (ticksInNanos() - lastWriteTime); if (nextDelay \u003c= 0) { // Writer is idle - set a new timeout and notify the callback. writerIdleTimeout = schedule(ctx, this, writerIdleTimeNanos, TimeUnit.NANOSECONDS); boolean first = firstWriterIdleEvent; firstWriterIdleEvent = false; try { // 不同点！！！！！ if (hasOut","date":"2021-07-04","objectID":"/netty/:10:6","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.7、Netty 核心组件 EventLoop 源码剖析 10.7.1、源码剖析 EventLoop 介绍 NioEventLoop 的继承图 说明： 1、ScheduledExecutorService 接口表示是一个定时任务接口，EventLoop可以接受定时任务。 2、EventLoop 接口:Netty接口文档说明该接口作用:一旦 Channel 注册了，就处理该Channel对应的所有I/O操作 3、SingleThreadEventExecutor 表示这是一个单个线程的线程池 4、EventLoop是一个单例的线程池，里面含有一个死循环的线程不断的做着3件事情:监听端口，处理端口 事件，处理队列事件。每个 EventLoop都可以绑定多个Channel，而每个Channel 始终只能由一个EventLoop 来处理 NioEventLoop 的使用 - execute 方法 execute 源码解析 在 EventLoop 的使用，一般就是 eventloop.execute(task)，看看 execute 方法的实现(在 SingleThreadEventExecutor 类中) @Override public void execute(Runnable task) { if (task == null) { throw new NullPointerException(\"task\"); } boolean inEventLoop = inEventLoop(); if (inEventLoop) { addTask(task); } else { startThread(); addTask(task); if (isShutdown() \u0026\u0026 removeTask(task)) { reject(); } } if (!addTaskWakesUp \u0026\u0026 wakesUpForTask(task)) { wakeup(inEventLoop); } } 说明 1、首先判断该 EventLoop 的线程是否是当前线程，如果是，直接添加到任务队列中去，如果不是，则尝试启动线程（但 由于线程是单个的，因此只能启动一次），随后再将任务添加到队列中去。 2、如果线程已经停止，并且删除任务失败，则执行拒绝策略，默认是抛出异常。 3、如果 addTaskWakesUp 是false，并且任务不是 NonWakeupRunnable 类型的，就尝试唤醒 selector 。这个时候， 阻塞在 selector 的线程就会立即返回 4、可以下断点来追踪 debug addTask 和 offerTask protected void addTask(Runnable task) { if (task == null) { throw new NullPointerException(\"task\"); } if (!offerTask(task)) { reject(task); } } final boolean offerTask(Runnable task) { if (isShutdown()) { reject(); } return taskQueue.offer(task); } NioEventLoop 的父类 SingleThreadEventExecutor 的 startThread 方法 当执行 execute 方法的时候,如果当前线程不是 EventLoop 所属线程,则尝试启动线程,也就是 starThread 方法，dubug 代码如下: private void startThread() { if (state == ST_NOT_STARTED) { if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) { try { doStartThread(); } catch (Throwable cause) { STATE_UPDATER.set(this, ST_NOT_STARTED); PlatformDependent.throwException(cause); } } } } 说明： 该方法首先判断是否启动过了，保证 EventLoop 只有一个线程，如果没有启动过，则尝试使用 Cas 将 state 状态改为 ST_STARTED，也就是已启动。然后调用doStartThread 方法。如果失败，则进行回滚 private void doStartThread() { assert thread == null; executor.execute(new Runnable() { @Override public void run() { thread = Thread.currentThread(); if (interrupted) { thread.interrupt(); } boolean success = false; updateLastExecutionTime(); try { SingleThreadEventExecutor.this.run(); success = true; } catch (Throwable t) { logger.warn(\"Unexpected exception from an event executor: \", t); } finally { for (;;) { int oldState = state; if (oldState \u003e= ST_SHUTTING_DOWN || STATE_UPDATER.compareAndSet( SingleThreadEventExecutor.this, oldState, ST_SHUTTING_DOWN)) { break; } } // Check if confirmShutdown() was called at the end of the loop. if (success \u0026\u0026 gracefulShutdownStartTime == 0) { logger.error(\"Buggy \" + EventExecutor.class.getSimpleName() + \" implementation; \" + SingleThreadEventExecutor.class.getSimpleName() + \".confirmShutdown() must be called \" + \"before run() implementation terminates.\"); } try { // Run all remaining tasks and shutdown hooks. for (;;) { if (confirmShutdown()) { break; } } } finally { try { cleanup(); } finally { STATE_UPDATER.set(SingleThreadEventExecutor.this, ST_TERMINATED); threadLock.release(); if (!taskQueue.isEmpty()) { logger.warn( \"An event executor terminated with \" + \"non-empty task queue (\" + taskQueue.size() + ')'); } terminationFuture.setSuccess(null); } } } } }); } 说明： 1、首先调用executor 的execute方法，这个executor 就是在创建Event LoopGroup 的时候创建的 ThreadPerTaskExecutor类。该execute方法会将Runnable包装成Netty的 FastThreadLocalThread。 2、任务中，首先判断线程中断状态，然后设置最后一次的执行时间 3、执行当前NioEventLoop 的 run方法，注意:这个方法是个死循环，是整个EventLoop 的核心 4、在finally 块中，使用CAS 不断修改 state 状态，改成ST_SHUTTING_DOWN。也就是当线程Loop 结束的时候。关闭 线程。最后还要死循环确认是否关闭，否则不会 break。然后，执行 cleanup操作，更新状态为 ST_TERMINATED， 并释放当前线程锁。如果任务队列不是空，则打印队列中还有多少个未完成的任务。并回调terminationFuture方法。 5、其实最核心的就是 Event Loop自身的run方法。再继续深入run方法 EventLoop 中的 Loop 是靠 run 实现的，我们分析下 run 方法（该方法在 NioEventLoop） @Override protected void run() { for (;;) { try { switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) { case SelectStrategy.CONTINUE: continue; case SelectStrategy.SELECT: select(wakenUp.getAndSet(false)); // 'wakenUp.","date":"2021-07-04","objectID":"/netty/:10:7","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"10.8、Handler 中加入线程池和 Context 中添加线程池的源码剖析 10.8.1、源码剖析目的 在Netty中做耗时的，不可预料的操作，比如数据库，网络请求，会严重影响Netty对Socket 的处理速度。 而解决方法就是将耗时任务添加到异步线程池中。但就添加线程池这步操作来讲，可以有2种方式，而且这2种方式实现的区别也蛮大的 处理耗时业务的第一种方式—handler中加入线程池 处理耗时业务的第二种方式—Context中添加线程池 我们就来分析下两种方式 10.8.2、第一种方式 /* * Copyright 2012 The Netty Project * * The Netty Project licenses this file to you under the Apache License, * version 2.0 (the \"License\"); you may not use this file except in compliance * with the License. You may obtain a copy of the License at: * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the * License for the specific language governing permissions and limitations * under the License. */ package com.clover.netty.source.echo2; import io.netty.buffer.ByteBuf; import io.netty.buffer.Unpooled; import io.netty.channel.ChannelHandler.Sharable; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; import io.netty.util.CharsetUtil; import io.netty.util.concurrent.DefaultEventExecutorGroup; import io.netty.util.concurrent.EventExecutorGroup; import java.util.concurrent.Callable; /** * Handler implementation for the echo server. */ @Sharable public class EchoServerHandler extends ChannelInboundHandlerAdapter { static final EventExecutorGroup group = new DefaultEventExecutorGroup(16); @Override public void channelRead(ChannelHandlerContext ctx, Object msg) { System.out.println(\"EchoServerHandler 的线程是 =\" + Thread.currentThread().getName()); // 将任务提交到 group 线程池 group.submit(new Callable\u003cObject\u003e() { @Override public Object call() throws Exception { ByteBuf buf = (ByteBuf) msg; byte[] bytes = new byte[buf.readableBytes()]; buf.readBytes(bytes); String s = new String(bytes, \"UTF-8\"); Thread.sleep(3 * 1000); System.out.println(\"EchoServerHandler 中 group.submit 的线程是 =\" + Thread.currentThread().getName()); System.out.println(\"s =\" + s); ctx.writeAndFlush(Unpooled.copiedBuffer((\"hello,clover\").getBytes())); return null; } }); // 普通方式 ByteBuf buf = (ByteBuf) msg; byte[] bytes = new byte[buf.readableBytes()]; buf.readBytes(bytes); String s = new String(bytes, \"UTF-8\"); Thread.sleep(3 * 1000); System.out.println(\"EchoServerHandler 中 普通方式 的线程是 =\" + Thread.currentThread().getName()); ctx.writeAndFlush(Unpooled.copiedBuffer((\"hello,clover\").getBytes())); System.out.println(\"go on\"); } @Override public void channelReadComplete(ChannelHandlerContext ctx) { ctx.flush(); } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) { // Close the connection when an exception is raised. cause.printStackTrace(); ctx.close(); } } 说明： 1、在 channelRead 方法，模拟了一个耗时 10 秒的操作，这里，将这个任务提交到了一个自定义的业务线程池中，这样就 不会阻塞 Netty 的 IO 线程 2、当你运行多个 group.submit 方法时，在 group 线程池中也会使用多个 线程，而不是共用一个线程，而 handler 是共 用一个线程 这样处理后，整个程序的逻辑图 说明： 解释一下上图，当 IO 线程轮询到一个 socket 事件，然后，IO 线程开始处理，当走到耗时 handler 的时候，将耗时任务交给业务线程池 当耗时任务执行完毕再执行 pipeline write 方法的时候，(代码中使用的是 context 的 write方法，上图画的是执行 pipeline 方法，是一个意思)会将这个任务交给IO线程 10.8.3、write 方法的源码(在 AbstractChannelHandlerContext 类) private void write(Object msg, boolean flush, ChannelPromise promise) { AbstractChannelHandlerContext next = findContextOutbound(); final Object m = pipeline.touch(msg, next); EventExecutor executor = next.executor(); // 重点！！！！！！！ if (executor.inEventLoop()) { if (flush) { next.invokeWriteAndFlush(m, promise); } else { next.invokeWrite(m, promise); } } else { AbstractWriteTask task; if (flush) { task = WriteAndFlushTask.newInstance(next, m, promise); } else { task = WriteTask.newInstance(next, m, promise); } // 重点！！！！！！！ safeExecute(executor, task, promise, m); } } 说明： 1、当判定下个 outbound 的 executor 线程不是当前线程的时候，会将当前的工作封装成task ,然后放入mpsc队列中，等 待IO任务执行完毕后执行队列中的任务。 2、这里可以Debug 来验证(提醒:Debug时，服务器端Debug ,客户端Run 的方式)，当我们使用了 group.submit(new Callable\u003cObject\u003e()在 handler中加入线程池，就会进入到 safeExecute(executor;task","date":"2021-07-04","objectID":"/netty/:10:8","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"11、用 Netty 自己实现 dubbo RPC ","date":"2021-07-04","objectID":"/netty/:11:0","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"11.1、RPC 基本介绍 RPC（Remote Procedure Call）— 远程过程调用，是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程 两个或多个应用程序都分布在不同的服务器上，它们之间的调用都像是本地方法调用一样(如图) 常见的 RPC 框架有: 比较知名的如阿里的Dubbo、google的g RPC、Go语言的rpcx、Apache的thrift， Spring 旗下的 Spring Cloud ","date":"2021-07-04","objectID":"/netty/:11:1","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"11.2、RPC调用流程 术语说明：在RPC中，Client 叫服务消费者，Server 叫服务提供者 服务消费方(client)以本地调用方式调用服务 client stub 接收到调用后负责将方法、参数等封装成能够进行网络传输的消息体 client stub 将消息进行编码并发送到服务端 server stub 收到消息后进行解码 server stub 根据解码结果调用本地的服务 本地服务执行并将结果返回给 server stub server stub 将返回导入结果进行编码并发送至消费方 client stub 接收到消息并进行解码 服务消费方(client)得到结果 小结：RPC 的目标就是将 2-8 这些步骤都封装起来，用户无需关心这些细节，可以像调 用本地方法一样即可完成远程服务调用 ","date":"2021-07-04","objectID":"/netty/:11:2","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"11.3、自己实现 dubbo RPC (基于 Netty) 11.3.1、需求说明 dubbo 底层使用了 Netty 作为网络通讯框架，要求用 Netty 实现一个简单的 RPC 框架 模仿 dubbo，消费者和提供者约定接口和协议，消费者远程调用提供者的服务，提供者返回一个字符串，消费者打印提供者返回的数据。底层网络通信使用 Netty 4.1.20 11.3.2、设计说明 创建一个接口，定义抽象方法。用于消费者和提供者之间的约定 创建一个提供者，该类需要监听消费者的请求，并按照约定返回数据 创建一个消费者，该类需要透明的调用自己不存在的方法，内部需要使用 Netty 请求提供者返回数据 这个里面的难点在于代理对象的创建 ","date":"2021-07-04","objectID":"/netty/:11:3","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Netty"],"content":"11.4、代码实现 公共接口 package com.clover.netty.dubborpc.publicinterface; // 这个是接口，是 服务提供方 和 消费者方 都需要的 public interface HelloService { String hello(String msg); } 服务提供方实现接口 package com.clover.netty.dubborpc.provider; import com.clover.netty.dubborpc.publicinterface.HelloService; public class HelloServiceImpl implements HelloService { // 如果你想在此统计客户端发送了多少次消息，你可以设置一个变量，但是你不设置为静态变量是无法统计到的 // 因为它每次都是调用的一个新的 HelloServiceImpl 对象，并不是每次使用的是同一个 // 当有消费方调用该方法时，就返回一个结果 @Override public String hello(String msg) { System.out.println(\"收到客户端消息：\" + msg); // 根据 msg 返回不同的结果 if (msg != null){ return \"你好客户端，我已经收到你的消息 [\" + msg +\"]\"; } else { return \"你好客户端，我已经收到你的消息 \"; } } } 服务提供方(服务器端)启动类 package com.clover.netty.dubborpc.provider; import com.clover.netty.dubborpc.netty.NettyServer; // ServerBootstrap 会启动一个服务提供者，就是 NettyServer public class ServerBootstrap { public static void main(String[] args) { NettyServer.startServer(\"127.0.0.1\",7000); } } NettyServer package com.clover.netty.dubborpc.netty; import io.netty.bootstrap.ServerBootstrap; import io.netty.channel.ChannelFuture; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelPipeline; import io.netty.channel.EventLoopGroup; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioServerSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; public class NettyServer { public static void startServer(String hostName,int port){ startServer0(hostName, port); } public static void startServer0(String hostname,int port){ EventLoopGroup bossGroup = new NioEventLoopGroup(1); EventLoopGroup workerGroup = new NioEventLoopGroup(); try{ ServerBootstrap serverBootstrap = new ServerBootstrap(); serverBootstrap.group(bossGroup,workerGroup) .channel(NioServerSocketChannel.class) .childHandler(new ChannelInitializer\u003cSocketChannel\u003e() { @Override protected void initChannel(SocketChannel ch) throws Exception { ChannelPipeline pipeline = ch.pipeline(); pipeline.addLast(new StringDecoder()); pipeline.addLast(new StringEncoder()); pipeline.addLast(new NettyServerHandler()); } }); ChannelFuture channelFuture = serverBootstrap.bind(7000).sync(); System.out.println(\"服务提供方开始提供服务\"); channelFuture.channel().closeFuture().sync(); }catch (Exception e){ e.printStackTrace(); }finally{ bossGroup.shutdownGracefully(); workerGroup.shutdownGracefully(); } } } NettyServerHandler package com.clover.netty.dubborpc.netty; import com.clover.netty.dubborpc.provider.HelloServiceImpl; import io.netty.channel.ChannelHandlerContext; import io.netty.channel.ChannelInboundHandlerAdapter; public class NettyServerHandler extends ChannelInboundHandlerAdapter { @Override public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception { // 获取客户端发送的消息，并调用服务 System.out.println(\"msg =\" + msg); // 客户端在调用服务器的 api 时，我们需要定义一个协议 // 比如我们要求 每次发送消息时都必须以某个字符串开头 \"CloverFelix#hello#xxxx\" if (msg.toString().startsWith(\"CloverFelix#hello#\")){ String result = new HelloServiceImpl().hello(msg.toString().substring(msg.toString().lastIndexOf(\"#\") + 1)); ctx.writeAndFlush(result); } } @Override public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception { ctx.channel().close(); } } NettyCLient package com.clover.netty.dubborpc.netty; import io.netty.bootstrap.Bootstrap; import io.netty.channel.ChannelInitializer; import io.netty.channel.ChannelOption; import io.netty.channel.ChannelPipeline; import io.netty.channel.nio.NioEventLoopGroup; import io.netty.channel.socket.SocketChannel; import io.netty.channel.socket.nio.NioSocketChannel; import io.netty.handler.codec.string.StringDecoder; import io.netty.handler.codec.string.StringEncoder; import java.lang.reflect.Proxy; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; public class NettyClient { // 创建线程池 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().av","date":"2021-07-04","objectID":"/netty/:11:4","tags":["Netty"],"title":"Netty","uri":"/netty/"},{"categories":["Spring"],"content":"spring","date":"2021-07-04","objectID":"/spring/","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.Spring ","date":"2021-07-04","objectID":"/spring/:1:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.1 简介 下载spring所有版本信息的地址入口：https://docs.spring.io/spring-framework/docs/4.3.9.RELEASE/spring-framework-reference/ 下载spring所有版本信息的地址：http://repo.spring.io/release/org/springframework/spring github：https://github.com/spring-projects/spring-framework 导入spring-webmvc，可以快速一次性导入所有java包） \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.2.0.RELEASE\u003c/version\u003e \u003c/dependency\u003e 导入spring web jdbc \u003c!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.3.3\u003c/version\u003e \u003c/dependency\u003e ","date":"2021-07-04","objectID":"/spring/:1:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.2 优点 开源的免费容器 轻量级，非入侵式的框架（引入不会对原来的代码产生任何影响） 控制反转(IOC)，面向切面编程(AOP) 支持事务的处理，对框架整合的支持 spring就是一个轻量级的控制反转和面向切面编程的框架 ","date":"2021-07-04","objectID":"/spring/:1:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.3 组成 ","date":"2021-07-04","objectID":"/spring/:1:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"1.4 学习路线 SpringBoot 一个快速开发的脚手架 基于SpringBoot可以快速的开发单个微服务 约定大于配置 要先学Spring和SpringMVC SpringCloud 基于SpringBoot实现的 ","date":"2021-07-04","objectID":"/spring/:1:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"2.坑 多态父类实现子类独有的方法需要向下强转 public static void main(String[] args){} 可以由快捷键psvm加回车打出来 无参构造函数，只要一new就会执行 只要有new一定要写在main方法里 ","date":"2021-07-04","objectID":"/spring/:2:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.IOC DI ","date":"2021-07-04","objectID":"/spring/:3:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.1 理论推导（依赖注入：set注入） //利用set进行动态实现值的注入 private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } 之前程序是主动创建对象！控制权在程序员手上 使用set注入后，程序不再具有主动性，而是变成了被动的接受对象 这种思想从本质上解决了问题，我们程序员不用再去管理对象的创建了 ","date":"2021-07-04","objectID":"/spring/:3:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.2 IOC本质 是一种通过描述（XML或注解）并通过第三方生产或获取特定对象的方式，在spring中实现控制反转的是Ioc容器，其实现方法是依赖注入（DI） ","date":"2021-07-04","objectID":"/spring/:3:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.3 IOC容器(控制反转) 配置文件 xml中的bean标签就是一个对象，把类用bean标签添加在配置文件中，就相当于：类名 变量名=new 类名()，而标签中的id就是变量名，class就等于new的对象。所以myHello就是一个Hello类对象。这里的对象是由spring创建的，而不是java new出来的。 property相当于给对象中的基本数据类型的属性设置一个值（注意！！！，类中一定要有：set属性名(参数类型 参数值){this.属性名=参数值} 这个方法 \u003cbean id=\"myHello\" class=\"com.kua.pojo.Hello\"\u003e \u003cproperty name=\"str\" value=\"spring\"/\u003e \u003c/bean\u003e property如果要给对象中的对象数据设置值，那就是\u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e其中name表示对象属性名，表示引用spring中创建好的对象 \u003cbean id=\"myServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"\u003e \u003cproperty name=\"userDao\" ref=\"mySql\"/\u003e \u003c/bean\u003e 初始化时，先读取配置文件，获得spring的上下文对象（固定语句不可变） ApplicationContext context=new ClassPathXmlApplicationContext(\"bean.xml\");//这里的bean.xml是配置文件名 通过上下文对象context的getBean方法从Ioc容器中直接取出对象 Hello myHello=(Hello)context.getBean(\"hello\"); ","date":"2021-07-04","objectID":"/spring/:3:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.4 IOC综合 控制：谁来控制对象的创建，传统的应用程序是由程序本身来控制创建的，使用Spring后，对象是由Spring创建的 反转：程序本身不创建对象，而变成被动的接收对象 依赖注入：利用set方法进行注入 IOC编程思想：由主动编程，变成被动接收，对象由Spring来创建，管理，装配 ","date":"2021-07-04","objectID":"/spring/:3:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.5 IOC创建对象的方式（依赖注入：构造器注入） 使用构造器方式注入可以不写set 使用无参构造创建对象（默认的） 如果要用有参构造函数创建对象 方式一：下标赋值 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg index=\"0\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e index表示参数的下标，value表示给参数赋值 方式二：匹配参数类型（不建议使用） \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg type=\"java.lang.String\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e 注意：基本类型可以直接写，但是引用类型如：String得写全名 方式三：直接通过参数名 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\"\u003e \u003cconstructor-arg name=\"name\" value=\"renzuoweishihanhan\"/\u003e \u003c/bean\u003e ","date":"2021-07-04","objectID":"/spring/:3:5","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"3.6 IOC初始化对象的时间 在new ClassPathXmlApplicationContext，即加载完配置文件后就已经初始化好了所有bean对象，然后你需要getBean谁就取谁 ","date":"2021-07-04","objectID":"/spring/:3:6","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"4.Spring配置 ","date":"2021-07-04","objectID":"/spring/:4:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"4.1 Spring配置 alias，给bean对象取别名（一对一） 给容器中的东西取别名 \u003calias name=\"user\" alias=\"user2\"/\u003e bean配置 id：bean的唯一标识符 class：bean对象所对应的全限定名（包+类） name：给bean对象取别名，可以同时取多个别名，中间可以用逗号、空格、分号隔开 import：一般用于团队开发使用，他可以将多个文件导入合并为一个 用import可以导入这个模块的其他bean文件，合并为一个总的，然后通过总的xml文件可以取到所有导入的bean里面的东西，如果不同bean中有相同的配置，但是配置的值不同，则下面的xml文件会覆盖上面的 ","date":"2021-07-04","objectID":"/spring/:4:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"5.DI依赖注入之set注入 ","date":"2021-07-04","objectID":"/spring/:5:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"5.1、依赖注入之set注入 依赖：bean对象的创建依赖于容器 注入：bean对象的所有属性值由容器注入 复杂类型： public class Address { private String address; public String getAddress() { return address; } public void setAddress(String address) { this.address = address; } } 真实测试对象： public class Student { private String name; private Address address; private String[] books; private List\u003cString\u003e hobbies; private Map\u003cString,String\u003e card; private Set\u003cString\u003e games; private String wife; private Properties info; } bean4.xml \u003cbean id=\"adress\" class=\"com.kuang.pojo.Address\"/\u003e \u003cbean id=\"student\" class=\"com.kuang.pojo.Student\"\u003e \u003c!-- 普通值注入,value--\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c!-- bean注入，ref--\u003e \u003cproperty name=\"address\" ref=\"adress\"/\u003e \u003c!-- 数组注入--\u003e \u003cproperty name=\"books\"\u003e \u003carray\u003e \u003cvalue\u003e西游记\u003c/value\u003e \u003cvalue\u003e水浒传\u003c/value\u003e \u003cvalue\u003e红楼梦\u003c/value\u003e \u003c/array\u003e \u003c/property\u003e \u003c!-- List注入--\u003e \u003cproperty name=\"hobbies\"\u003e \u003clist\u003e \u003cvalue\u003e打篮球\u003c/value\u003e \u003cvalue\u003e看剧\u003c/value\u003e \u003cvalue\u003e敲代码\u003c/value\u003e \u003c/list\u003e \u003c/property\u003e \u003c!-- Map注入--\u003e \u003cproperty name=\"card\"\u003e \u003cmap\u003e \u003centry key=\"学号\" value=\"2918378\"/\u003e \u003centry key=\"身份证\" value=\"2917321\"/\u003e \u003c/map\u003e \u003c/property\u003e \u003c!-- Set注入--\u003e \u003cproperty name=\"games\"\u003e \u003cset\u003e \u003cvalue\u003elol\u003c/value\u003e \u003cvalue\u003e找你妹\u003c/value\u003e \u003c/set\u003e \u003c/property\u003e \u003c!-- null--\u003e \u003cproperty name=\"wife\"\u003e \u003cnull/\u003e \u003c/property\u003e \u003c!-- Properties配置类型--\u003e \u003cproperty name=\"info\"\u003e \u003cprops\u003e \u003cprop key=\"学号\"\u003e21342\u003c/prop\u003e \u003cprop key=\"性别\"\u003e女\u003c/prop\u003e \u003c/props\u003e \u003c/property\u003e \u003c/bean\u003e 测试类： ApplicationContext context=new ClassPathXmlApplicationContext(\"bean4.xml\"); Student student=(Student) context.getBean(\"student\"); System.out.println(student.toString()); ","date":"2021-07-04","objectID":"/spring/:5:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"6.导入test测试包（junit） ","date":"2021-07-04","objectID":"/spring/:6:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"6.1、导入test测试包 \u003cdependency\u003e \u003cgroupId\u003eorg.junit.vintage\u003c/groupId\u003e \u003cartifactId\u003ejunit-vintage-engine\u003c/artifactId\u003e \u003cversion\u003e5.7.1\u003c/version\u003e \u003cscope\u003etest\u003c/scope\u003e \u003c/dependency\u003e 然后在测试类中@Test，这样在测试类中写出的方法，会自动被执行 ","date":"2021-07-04","objectID":"/spring/:6:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"7.c命名和p命名空间注入 ","date":"2021-07-04","objectID":"/spring/:7:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"7.1、命名空间 p命名空间的注入，可以直接注入属性的值：property（本质还是set注入） 前提： 导入约束xmlns:p=“http://www.springframework.org/schema/p\" 要有set方法 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" p:age=\"18\" p:name=\"yzq\"/\u003e 可以直接在bean标签内注入属性的值 如果是注入对象则： 导入junit，并在测试文件中@Test（插曲） c命名空间（本质是构造器注入） 前提： 导入约束 xmlns:c=\"http://www.springframework.org/schema/c\" 要有set方法 必须要有无参构造函数和有参构造函数两种 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\"/\u003e 测试： @Test public void test2(){ ApplicationContext context=new ClassPathXmlApplicationContext(\"beans4.xml\"); User user=context.getBean(\"user\",User.class); System.out.println(user); }; ","date":"2021-07-04","objectID":"/spring/:7:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"8.Bean Scopes（bean作用域） ","date":"2021-07-04","objectID":"/spring/:8:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"8.1、bean作用域 单例模式singleton（Spring默认机制） 对象只有一个，不管从相同的bean对象中getBean多少个对象，都是表示同一个对象，如下：输出true 用法：在bean的后面加上scope=“singleton”，也可以不加，因为这种作用域是spring默认的 \u003cbean id=\"user\" class=\"com.kuang.pojo.User\" c:age=\"18\" c:name=\"nihao\" scope=\"singleton\"/\u003e User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 原型模式prototype 用法：scope=“prototype” 每次从容器中get时都会产生新对象，每个对象都不一样 User user=context.getBean(\"user\",User.class); User user1=context.getBean(\"user\",User.class); System.out.println(user==user1); 输入false 其他四个只能在web开发中使用 ","date":"2021-07-04","objectID":"/spring/:8:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"9.bean的自动装配（Autowired） ","date":"2021-07-04","objectID":"/spring/:9:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"9.1、bean自动装配 Spring会在上下文中自动寻找，并自动给bean装配属性，只针对bean对象 在Spring中有三种装配方式： 在xml中显示的配置 在java中显示的配置 隐式的自动装配bean（重要） 自动装配就是：可以不用在bean中自己手动装备bean对象的对象属性，也就是不用property来为对象中的对象引用赋值，但是只针对对象属性 用法：用autowired=““实现 People.java public void setName() { this.name = name; } public void setCat(Cat cat) { this.cat = cat; } public void setDog(Dog dog) { this.dog = dog; } bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byName\"\u003e \u003cproperty name=\"name\" value=\"yzq\"/\u003e \u003c/bean\u003e byName表示在容器上下文中查找和自己set方法后面的值对应的beanid，弊端：名字必须相同 byType表示在容器上下文中查找和自己set方法中对象类型相同的对应的beanid，都可以省略id。弊 端：容器中所有bean的class唯一，即只有一个对象，如下就会报错 \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\" autowire=\"byType\"\u003e ","date":"2021-07-04","objectID":"/spring/:9:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.使用注解实现自动装配 ","date":"2021-07-04","objectID":"/spring/:10:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.1 @Autowired 可以删掉set方法，但是需要get方法！！！ 前提：只针对bean对象，通过byType方式实现，如果有多个对象，就通过byName方式实现 导入约束 xmlns:context=\"http://www.springframework.org/schema/context\" 配置注解的支持 \u003c!--所有注解驱动--\u003e \u003ccontext:annotation-config/\u003e 容器中和.java中的名字要相同 使用： 在配置文件中注入所有你要自动装配的对象，然后直接在属性上面或者set方法上面使用@Autowired bean5.xml \u003cbean id=\"cat\" class=\"com.kuang.pojo.Cat\"/\u003e \u003cbean id=\"dog\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"people\" class=\"com.kuang.pojo.People\"/\u003e People.java @Autowired private Cat cat; @Autowired private Dog dog; 也可以放在set方法上面 ","date":"2021-07-04","objectID":"/spring/:10:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.2 @Nullable(拓展) 如果显示定义@Autowired的require属性为false，那么那个对象的属性值为null也不会报错（但是完全没有定义，只有声明，就会报错） 与这有相同效果的是@Nullable，用法：在构造函数的形参前面 public People(@Nullable String name) { this.name = name; } ","date":"2021-07-04","objectID":"/spring/:10:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.3 @Qualifier 当容器中和.java中的对象名字和类型都不匹配时，这时@Autowired就没办法用，但如果又想要自动匹配，就可以使用@Qualifier(value=”\")实现名字匹配 \u003cbean id=\"dog2\" class=\"com.kuang.pojo.Dog\"/\u003e \u003cbean id=\"dog1\" class=\"com.kuang.pojo.Dog\"/\u003e @Autowired @Qualifier(value=\"dog1\") private Dog dog; 但是可能在运行前要去maven里clean一下，再运行 ","date":"2021-07-04","objectID":"/spring/:10:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.4 @Resource 以上三种都是Spring注解，这一个是java注解 @Resource与@Autowired用法一样，但是@Resource先通过byName，再通过byType 当名字和类型都不匹配时：加一个name属性可以指定名字匹配 @Resource(name=””) ","date":"2021-07-04","objectID":"/spring/:10:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.5 @Component 见11的第2条的方法二 ","date":"2021-07-04","objectID":"/spring/:10:5","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"10.6 @Scope 见11的第5条 ","date":"2021-07-04","objectID":"/spring/:10:6","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"11.使用注解开发 在Spring4之后，要使用注解开发，必须保证aop的包导入，所以出错时检查这个包有没有问题 导入约束 增加支持 bean 属性如何注入（开启注解的支持） 方法一： 注解驱动 \u003ccontext:annotation-config/\u003e 方法二： 指定包中的全部注解都生效 \u003ccontext:component-scan base-package=\"com.kuang.pojo\"/\u003e 用@Component注解： 放在类上面，表示 这个类被Spring管理了，就是一个bean，而@Value就相当于bean中的property，给属性（这里的属性，不只是对象，还包含基本数据类型的属性）注入值，@Value也可以放在set方法上面 //相当于在配置文件中 //\u003cbean id=\"user\" class=\"com.kuang.pojo.User\" /\u003e @Component public class User { @Value(\"yzq\") private String name; } 衍生的注解 @Component有几个衍生注解，在web开发中，会按照mvc三层架构分层 poji层：@Component dao层：@Repository service层：@Service controller层：@Controller 这四个注解功能一样，都是讲某个类注入到容器中 自动装配置 以上所有注解 作用域 也可以使用注解：@Scope(“作用域类型”)，也是放在类上面的 @Component @Scope(\"prototype\") public class User{ } 小结 xml和注解： xml更加万能，适用于任何场所|维护简单方便 注解：不是自己的类使用不了，维护复杂，因为每个不同的类的注解是独立的 xml与注解最佳实践 xml用来管理bean 注解只负责完成属性的注入 注意：一定要开启注解的支持 ","date":"2021-07-04","objectID":"/spring/:11:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.使用java方式配置Spring ","date":"2021-07-04","objectID":"/spring/:12:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.1 用@Configuration配置过程 写一个类作为配置类，将@Configuration放在类上面，@Bean放在一个返回类的方法里面 @Configuration代表最这是一个配置类，和之前的bean.xml是一样的，本身也会被spring容器托管，注册到容器中，因为他本来就是一个@Component @Bean代表bean，哪个类的bean就写一个返回类的方法，然后bean的id就是方法的方法名 配置类： @Configuration public class myConfig { @Bean public User getUser(){ //返回要注入到bean中的对象 return new User(); } } 给bean中的属性注入值 @Value(\"yzq\") private String name; public String getName() { return name; } 测试类：注意是用的AnnotationConfigApplicationContext实现类，因为没有配置文件xml了，完全是用java+注解配置的，实参是写的配置类，bean的id名是配置类中的方法名 ApplicationContext context = new AnnotationConfigApplicationContext(myConfig.class); User getUser=(User) context.getBean(\"getUser\"); System.out.println(getUser.getName()); ","date":"2021-07-04","objectID":"/spring/:12:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"12.2 @Configuration扫描 也可以显示的扫描包 @Configuration //包中所有注解都生效 @ComponentScan(\"com.kuang.pojo\") public class myConfig { @Bean public User getUser(){ return new User(); } } 因为肯定有多个bean，所以就根据几个bean创建几个java配置类，然后每个类上面都加上@Configuration，代表这是一个配置类但是要把这么多bean整合到一起，就要使用@Import(其他配置类名.class) ","date":"2021-07-04","objectID":"/spring/:12:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.代理模式 ","date":"2021-07-04","objectID":"/spring/:13:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.1 代理模式 ​ 为什么学习代理模式？ ​ 因为这是SpringAOP的底层 ","date":"2021-07-04","objectID":"/spring/:13:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.2 静态代理 角色分析： 抽象角色（租房）：一般会使用接口或者抽象类来解决 public interface rent { public void rent(); } 真实角色（房东）：被代理的角色 public void rent(){ System.out.println(\"房东要出租房子\"); }; 代理角色（中介）：代理真实角色，代理真实角色后，一般会做一些附属操作（代理角色自己的方法） public class Proxy { public Host host; public Proxy() { } public Proxy(Host host) { this.host = host; } public void rent(){ host.rent(); hetong(); see(); fee(); } public void hetong(){ System.out.println(\"中介带你签合同\"); } public void see(){ System.out.println(\"中介带你看房\"); } public void fee(){ System.out.println(\"中介带你付费\"); } } 客户（我）：访问代理对象的人 public class Client { public static void main(String[] args) { //房东只租房子 Host host =new Host(); //代理出来租房子还有一些附属操作 Proxy proxy=new Proxy(host); //不用面对房东，直接找中介即可 proxy.rent(); } } 好处： 可以使真实角色操作更纯粹，不用去关注一些公共的业务 公共也就交给代理角色！实现了业务的分工 公共业务发生拓展时，方便集中管理 缺点： 一个真实角色就会产生一个代理角色，代码量会翻倍，开发效率低 ","date":"2021-07-04","objectID":"/spring/:13:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.3 静态代理再理解 抽象角色 public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色，实现增删改查四个方法 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 代理角色：现有客户需要在每次实现什么方法的时候，能够输出实现了什么方法，称为日志功能，这个时候如果去在真实角色的代码里面添加，就违反了”改动原有代码，在公司中是大忌“，所以这时候就需要代理去实现 public class UserServiceProxy { private UserServiceImpl userServiceImpl; public void setUserServiceImpl(UserServiceImpl userServiceImpl) { this.userServiceImpl = userServiceImpl; } public void add(){ log(\"add\"); userServiceImpl.add(); } public void delete(){ log(\"delete\"); userServiceImpl.delete(); } public void update(){ log(\"update\"); userServiceImpl.update(); } public void query(){ log(\"query\"); userServiceImpl.query(); } public void log(String a){ System.out.println(\"实现了\"+a+\"方法\"); } } 客户：只需要跟代理角色接触，让代理角色去调用真实角色的各种方法 public class Client { public static void main(String[] args) { UserServiceImpl userServiceImpl=new UserServiceImpl(); UserServiceProxy userServiceProxy=new UserServiceProxy(); userServiceProxy.setUserServiceImpl(userServiceImpl); userServiceProxy.add(); } } ","date":"2021-07-04","objectID":"/spring/:13:3","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.4 聊聊AOP AOP实现机制，就是不改变原有代码，增加代理角色，面向切面编程 ","date":"2021-07-04","objectID":"/spring/:13:4","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"13.5 动态代理详解 动态代理和静态代理角色一样 动态代理的代理类是动态生成的，不是我们直接写好的 动态代理分为两大类：基于接口的动态代理，基于类的动态代理 基于接口：JDK的动态代理 基于类：cglib java字节码实现（现在用的多的）：javassist，javassist是一个开源的分析、编辑和创建java字节码的类库 前提：了解两个类 Proxy类：生成动态代理实例的，提供动态代理类和实例的静态方法 InvocationHandle：调用处理程序并返回一个结果的（调用处理程序实现的接口） 接口： public interface UserService { public void add(); public void delete(); public void update(); public void query(); } 真实角色： public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); }; public void delete(){ System.out.println(\"删\"); }; public void update(){ System.out.println(\"改\"); }; public void query(){ System.out.println(\"查\"); }; } 创建代理对象的类，ProxyInvocationHandle.java： //使用这个类动态生成代理类，这个类本身不是代理类，只是处理代理过程的一个类 public class ProxyInvocationHandle implements InvocationHandler { //设置被代理的接口 //实际上就是设置实现接口的真实角色对象 public Object target; public void setTarget(Object target) { this.target = target; } //生成得到代理类 public Object getProxy(){ //参数1：实现接口的真实类的位置 //参数2：真实类 //参数3：通过什么调用的 return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this); } @Override //处理代理实例，并返回结果，这个invoke方法是通过反射自动调用的，在getProxy时传了一个this，里面调用了invoke。每次当代理对象调用方法时都会经过这个方法，这个方法包含了所有代理对象需要处理的业务 //参数1：动态生成的代理对象的实例 //参数2：接口的方法，和真实角色接口方法一致 //代表调用接口方法对应的Object参数数组 public Object invoke(Object o, Method method, Object[] objects) throws Throwable { //因为method是接口的方法，所以getName就可以得到方法名 log(method.getName()); Object result=method.invoke(target,objects); return result; } //如果想要增加代理类自己的方法，就直接在下面写，下面是一个实现日志功能的方法 public void log(String msg){ System.out.println(\"实现了\"+msg+\"方法\"); } } 客户： public class Client { public static void main(String[] args) { //真实角色 UserServiceImpl userService=new UserServiceImpl(); //处理和生成代理角色的类 ProxyInvocationHandle pih=new ProxyInvocationHandle(); //设置要代理的对象，实际上就是真实角色对象 pih.setTarget(userService); //生成代理类,要强转成接口类型，因为动态代理的是接口 UserService proxy=(UserService) pih.getProxy(); //现在就可以让代理类处理业务了 proxy.add(); } } 输出： 好处： 静态代理的优点全有 一个动态代理类代理的是一个接口，一般就是对应的一些业务 一个动态代理类可以代理多个类，只要实现了同一个接口就可以 ","date":"2021-07-04","objectID":"/spring/:13:5","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.AOP ","date":"2021-07-04","objectID":"/spring/:14:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.1 了解 面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的技术，在不改变原来代码的基础上实现动态的增强 ","date":"2021-07-04","objectID":"/spring/:14:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"14.2 使用Spring实现Aop 前提：使用AOP织入，需要导入一个依赖包 \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.4\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 14.2.1 方法一：使用原生Spring API接口（JDK）默认 此方法特点是，切入一个方法就要对应一个类 UserService接口 public interface UserService { public void add(); public void delete(); public void update(); public void search(); } UserServiceImpl实现类 public class UserServiceImpl implements UserService{ public void add(){ System.out.println(\"增\"); } public void delete(){ System.out.println(\"删\"); } public void update(){ System.out.println(\"改\"); } public void search(){ System.out.println(\"查\"); } } Log类：实现日志功能 public class Log implements MethodBeforeAdvice { @Override //参数method：要执行的目标对象的方法 //参数args：参数 //参数target：目标对象 public void before(Method method, Object[] args, Object target) throws Throwable { System.out.println(target.getClass().getName()+\"类,实现了\"+method.getName()+\"方法\"); } } AfterLog类：实现方法执行后，得知返回值功能 public class AfterLog implements AfterReturningAdvice { @Override //参数returnValue:返回值 public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(\"执行了\"+method.getName()+\"方法，返回结果为：\"+returnValue); } } bean9.xml配置类 切入点表示要切入到哪里去，即实现接口的类中的方法要在哪里执行 执行环绕：表示把自定义类与切入点连接起来，对应起来，表示自定义类中的方法在对应的切入点处执行 \u003c!-- 注册bean--\u003e \u003cbean id=\"log\" class=\"com.kuang.log.Log\"/\u003e \u003cbean id=\"afterLog\" class=\"com.kuang.log.AfterLog\"/\u003e \u003cbean id=\"userServiceImpl\" class=\"com.kuang.service.UserServiceImpl\"/\u003e \u003c!-- 方法一:使用原生Spring API接口--\u003e \u003c!-- 配置aop：要在上面导入aop约束--\u003e \u003caop:config\u003e \u003c!-- 切入点:expression=\"execution(修饰符，返回值，类名，方法名，参数)\"--\u003e \u003c!-- * 代表任意修饰符返回值--\u003e \u003c!-- com.kuang.service.UserServiceImpl.* 表示这个类下的所有方法--\u003e \u003c!-- com.kuang.service.UserServiceImpl.*(..) 表示所有方法，(..)代表方法的任意参数--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 执行环绕增加:表示把log,afterLog类切入到上面切入点的所有方法中--\u003e \u003caop:advisor advice-ref=\"log\" pointcut-ref=\"pointcut\"/\u003e \u003caop:advisor advice-ref=\"afterLog\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:config\u003e 测试类Test9.java public class Test9 { public static void main(String[] args) { ApplicationContext context=new ClassPathXmlApplicationContext(\"bean9.xml\"); // 因为动态代理代理的是接口 UserService userService=(UserService) context.getBean(\"userServiceImpl\"); userService.add(); } } 14.2.2 方法二：使用自定义类（CGLIB） 此方法的特点是：切入的所有方法都存在于一个类中，切入 多少个方法就对应多少个函数 切面表示引用哪个类，即哪个类里面有自定义的特定功能的方法，它就是一个类。切面中还要还要定义切入点（切面要引用到哪里去）和通知（是要切入切面类中的哪个方法，且切入到哪里去） 自定义切面类 public class DivPointCut { public void before(){ System.out.println(\"函数执行之前\"); } public void after(){ System.out.println(\"函数执行之后\"); } } bean9.xml \u003c!-- 方法二:使用自定义类--\u003e \u003c!-- 注入自定义切面类--\u003e \u003cbean id=\"divPointCut\" class=\"com.kuang.divPointCut.DivPointCut\"/\u003e \u003caop:config\u003e \u003c!-- 自定义切面,ref要引用的类--\u003e \u003caop:aspect ref=\"divPointCut\"\u003e \u003c!-- 切入点--\u003e \u003caop:pointcut id=\"pointcut\" expression=\"execution(* com.kuang.service.UserServiceImpl.*(..))\"/\u003e \u003c!-- 通知:即自定义切面中的方法,且要指定在哪里调用--\u003e \u003caop:before method=\"before\" pointcut-ref=\"pointcut\"/\u003e \u003caop:after method=\"after\" pointcut-ref=\"pointcut\"/\u003e \u003c/aop:aspect\u003e \u003c/aop:config\u003e 14.2.3 方法三：注解实现 与方法二原理一模一样，只是将xml换成注解 AnnotationPointCut自定义切面类： 注意选的是上面那个Before注解 //此注解表示这个类是一个切面 @Aspect public class AnnotationPointCut { //此注解表示这个方法是一个通知,切入点就写在@Before内 @Before(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void before(){ System.out.println(\"函数执行前\"); } @After(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") public void after(){ System.out.println(\"函数执行后\"); } @Around(\"execution(* com.kuang.service.UserServiceImpl.*(..))\") //这里的joinPoint是指连接点,和切入点类似,但是它可以从切入地方拿东西，是必要的参数 //记得一定要抛出异常 public void around(ProceedingJoinPoint jp) throws Throwable{ System.out.println(\"环绕前\"); //代表执行方法 Object proceed=jp.proceed(); System.out.println(\"环绕后\"); //连接点还可以获得签名(实际上就是执行了哪个方法)等信息 Signature signature=jp.getSignature(); System.out.println(\"签名:\"+signature); } } 配置文件 \u003c!-- 方法三:使用注解--\u003e \u003c!-- 注入自定义切面--\u003e \u003cbean id=\"annotationPointCut\" class=\"com.kuang.divPointCut.AnnotationPointCut\"/\u003e \u003c!-- 注解支持--\u003e \u003caop:aspectj-autop","date":"2021-07-04","objectID":"/spring/:14:2","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"15.整合mybatis ","date":"2021-07-04","objectID":"/spring/:15:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"15.1 回顾Mybatis Mybatis过程： 导入相关jar包 junit \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e mysql \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e mybatis \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e spring-webmvc \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-webmvc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e spring-jdbc \u003c!-- spring操作数据库的话,需要一个spring-jdbc--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework\u003c/groupId\u003e \u003cartifactId\u003espring-jdbc\u003c/artifactId\u003e \u003cversion\u003e5.1.9.RELEASE\u003c/version\u003e \u003c/dependency\u003e aspectjweaver：aop必导的包 \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.8.13\u003c/version\u003e \u003c/dependency\u003e mybatis-spring \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis-spring\u003c/artifactId\u003e \u003cversion\u003e2.0.2\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://127.0.0.1:3306/nfmall?useUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"uchr@123\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 测试 看到视频23的15:00 ","date":"2021-07-04","objectID":"/spring/:15:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"16.声明式事务 ","date":"2021-07-04","objectID":"/spring/:16:0","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["Spring"],"content":"16.1 回顾事务 把一组业务当成一个业务来做，要么都成功要么都失败 涉及到数据的一致性问题 确保完整性和一致性 事务ACID原则 原子性：确保事务要么都成功要么都失败 一致性：事务完成后，要么都提交，要么就都不行，资源状态都要保持一致性 隔离性：多个业务操作同一个资源，防止数据损坏 持久性：事务一旦提交，无论系统发生什么问题，结果都不会被影响，被持久化的写到存储器中 ","date":"2021-07-04","objectID":"/spring/:16:1","tags":["Spring"],"title":"Spring","uri":"/spring/"},{"categories":["SpringBoot"],"content":"springboot","date":"2021-07-04","objectID":"/springboot/","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"SpringBoot原理探讨 创建一个Controller时，让其返回一个字符串，有两种方式 1、使用@RestController注解 2、使用RequestMapping+ResponseBody注解 pom.xml spring-boot-dependencies：核心依赖在父工程中 我们在写或者引入一些Springboot依赖的时候，不需要指定版本，就因为有这些版本仓库 启动器 \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter\u003c/artifactId\u003e \u003c/dependency\u003e 启动器：说白了就是SpringBoot的启动场景 比如说spring-boot-starte-web，他就会帮我们自动导入web环境所有的依赖！ springboot会将所有的功能场景，都变成一个个的启动器 我们要使用什么功能，就只需要找到对应的启动器就可以了start 主程序 // @SpringBootApplication ：标注这这个类是一个SpringBoot的应用 启动类下的所有资源被导入 @SpringBootApplication public class DemoApplication { public static void main(String[] args) { // 将Springboot启动 SpringApplication.run(DemoApplication.class, args); } } 注解 @SpringBootConfiguration ： springboot的配置 @Configuration ：spring的配置类 @Component ：说明这也是一个spring的组件 @EnableAutoConfiguration ：自动配置 @AutoConfigurationPackage ：自动配置包 @Import(AutoConfigurationPackages.Registrar.class) ：自动配置包注册 @Import(AutoConfigurationImportSelector.class) ：自动配置导入选择 @SpringBootApplication 集成了所有注解，当它启动的时候，它所集成的资源都会被导入 META-INF/spring.factories：自动配置的核心文件 Properties properties = PropertiesLoaderUtils.loadProperties(resource) //所有资源加载到配置类中！ 所以，自动配置真正实现是从classpath中搜寻所有的/META-INF/spring.factories配置文件，并将其中对应的org.springframework.boot.autoconfigure.包下的配置项，通过反射实例化为对应标注了@Configuration的JavaConfig形式的IOC容器配置类，然后将这些都汇总成为一个实例并加载到IOC容器中 结论：springboot所有的自动配置都是在启动的时候扫描并加载：`spring.factories`所有的的自动配置类都在这里，但是不 一定生效，要判断条件是否成立，只要导入了对应的start就有对应的启动器了，有了启动器，我们自动装配就会生效，然后 就配置成功！ 1、springboot在启动的时候，从类路径下/META-INF/spring.factories获取指定的值 2、将这些自动配置的类导入容器，自动配置就会生效，帮我进行自动配置 3、以前我们需要自动配置的东西，现在springboot帮我们做了 4、整个JavaEE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中 5、它将所有的需要导入的组件一圈类名的方式返回，这些组件就会被添加到容器中 6、它会给容器中导入非常多的自动配置类(xxxAutoConfiguration)，就是给容器中导入这个场景需要的所有组件，并配置好这些组件，即自动装配(Configuration); 7、有了自动配置类，免去了我们手动编写配置注入功能组件等工作； springApplication.run方法分析 分析该方法主要分为两部分，一部分是SpringApplication的实例化，二是run方法的执行 SpringApplication 这个类主要做了一下四件事情 1、推断应用的类型是普通的项目还是web项目 2、查找并加载所有可用初始化器，设置到initializers属性中 3、找出所有的应用程序监听器，设置到listeners属性中 4、推断并设置main方法的定义类，找到运行的主类 ","date":"2021-07-04","objectID":"/springboot/:1:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"配置文件 Springboot使用一个全局的配置文件，配置文件名称是固定的 application.properties 语法结构： key=value application.yml 语法结构：key: 空格 value 注意：这里的空格是不能少的，少了即失效 yml基础语法 说明：语法要求严格！ 1、空格不能省略 2、以缩进来控制层级关系，只要是左边对齐的一列数据都是同一个层级的 3、属性和值的大小写都是十分敏感的 字面量： 普通的值 [ 数字，布尔值，字符串] 字面量直接卸载后面就可以，字符串默认不用加上双引号或者单引号 k: v 注意： ““双引号，不会转义字符串里面的特殊字符，特殊字符会作为本身想表达的意思； 比如：name: “clover \\n felix” 输出： clover 换行 felix ‘‘单引号，会转义特殊字符，特殊字符最终会变成和普通字符一样输出 比如：name:‘clover \\n felix’ 输出：clover \\n felix ","date":"2021-07-04","objectID":"/springboot/:2:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"注入配置文件 yaml注入配置文件 1、在springboot项目中的resource目录下新建一个文件application.yml 2、编写一个实体类Dog； @Component //注册bean到容器中 public class Dog { @Value(\"wangcai\") private String name; @Value(\"3\") private int age; // 有参无参构造、get、set方法、toString()方法 } 3、思考我们原来是如何给bean注入属性值的！@Value，给狗狗类测试一下 @Component //注册bean public class Dog { @Value(\"阿黄\") private String name; @Value(\"18\") private Integer age; } 4、在springboot的测试类下注入狗狗类并输出一下 @SpringBootTest class DemoApplicationTests { @Autowired //将狗狗自动注入进来 private Dog dog; @Test public void contextLoads() { System.out.println(dog); //打印看下狗狗对象 } } 结果成功输出，@Value注入成功，这是我们原来的方法 5、在编写一个复杂一点的实体类：Person类 Component //注册bean到容器中 public class Person { private String name; private Integer age; private Boolean happy; private Date birth; private Map\u003cString,Object\u003e maps; private List\u003cObject\u003e lists; private Dog dog; //有参无参构造、get、set方法、toString()方法 } 6、我们来使用yaml配置的方法进行注入，写的时候要注意区别和优势，编写一个yaml配置 person: name: clover age: 3 happy: false birth: 1996/08/24 maps: {k1: v1,k2: v2} lists: - code - music dog: name: wangcai age: 3 7、把刚刚写好的Person对象所有的值，注入到我们的类中 @Component /* @ConfigurationProperties作用： 将配置文件中配置的每一个属性的值，映射到这个组件中； 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定 参数 prefix = \"person\" ：将配置文件中的person下面的所有属性一一对应 只有这个组件是容器中的组件，才能使用容器提供的@ConfigurationProperties功能 */ @ConfigurationProperties(prefix = \"person\") public class Person { private String name; private int age; private boolean happy; private Date birth; private Map\u003cString,Object\u003e maps; private List\u003cObject\u003e lists; private Dog dog; } 8、IDEA提示，SpringBoot配置注解处理器没有找到，让我们查看文档，我们查看文档，可以找到一个依赖 \u003c!-- 导入配置文件处理器，配置文件进行绑定就会有提示，需要重启 --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-configuration-processor\u003c/artifactId\u003e \u003coptional\u003etrue\u003c/optional\u003e \u003c/dependency\u003e 9、确认以上配置都OK之后，去测试类中测试一下 @SpringBootTest class Springboot02ConfigApplicationTests { @Autowired private Person person; //将person自动注入进来 @Test void contextLoads() { System.out.println(dog); } } 结果：所有值全部注入成功 加载指定的配置文件 @PropertySource：加载指定的配置文件 @configurationProperties：默认从全局配置文件中获取值 注意：properties配置文件在写中文的时候，会有乱码 ， 我们需要去IDEA中设置编码格式为UTF-8； settings--\u003eFileEncodings 中配置； 对比小结 @Value这个使用起来并不友好！我们需要为每个属性单独注解赋值，比较麻烦；看个功能对比图 1、@ConfigurationProperties只需要写一次即可，@Value则需要每个字段都添加 2、松散绑定：这个什么意思呢？比如我写的yml中写的lastname，这个和lastName是一样的，- 后面跟着的字母默认是大写的。这就是松散绑定。可以进行一下测试。 3、JSR303数据校验，这个就是我们可以在字段时增加一层锅炉其验证，可以保证数据的合法性 4、复杂类型封装，yml中可以封装对象，使用value就不支持 结论： 配置yml和配置properties都可以获取到值，推荐使用yml 如果我们在某个业务中，只需要获取配置文件中的某个值，可以使用一下@Value 如果说我们专门编写了一个JavaBean来和配置文件进行一一映射，就直接使用configurationProperties。 ","date":"2021-07-04","objectID":"/springboot/:3:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"自动配置原理 分析自动配置原理 在配置文件中能配置的东西，都存在一个固有的规律 比如：xxxxAutoConfiguration：都有一个默认值 xxxProperties 和 配置文件进行绑定，我们就可以使用自定义的配置了 xxxProperties中存在一些默认值，也就是xxxxAutoConfiguration的默认值，如果我们想要修改值，就必须让xxxProperties与配置文件绑定，然后就可以通过其中的属性修改默认值 以HttpEncodingAutoConfiguration（Http编码自动配置） 为例解释自动配置原理； //表示这是一个配置类，和以前编写的配置文件一样，也可以给容器中添加组件； @Configuration //启动指定类的ConfigurationProperties功能； //进入这个HttpProperties查看，将配置文件中对应的值和HttpProperties绑定起来； //并把HttpProperties加入到ioc容器中 @EnableConfigurationProperties({HttpProperties.class}) //Spring底层@Conditional注解 //根据不同的条件判断，如果满足指定的条件，整个配置类里面的配置就会生效； //这里的意思就是判断当前应用是否是web应用，如果是，当前配置类生效 @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器； @ConditionalOnClass({CharacterEncodingFilter.class}) //判断配置文件中是否存在某个配置：spring.http.encoding.enabled； //如果不存在，判断也是成立的 //即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的； @ConditionalOnProperty( prefix = \"spring.http.encoding\", value = {\"enabled\"}, matchIfMissing = true ) public class HttpEncodingAutoConfiguration { //他已经和SpringBoot的配置文件映射了 private final Encoding properties; //只有一个有参构造器的情况下，参数的值就会从容器中拿 public HttpEncodingAutoConfiguration(HttpProperties properties) { this.properties = properties.getEncoding(); } //给容器中添加一个组件，这个组件的某些值需要从properties中获取 @Bean @ConditionalOnMissingBean //判断容器没有这个组件？ public CharacterEncodingFilter characterEncodingFilter() { CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter(); filter.setEncoding(this.properties.getCharset().name()); filter.setForceRequestEncoding(this.properties.shouldForce(org.springframework.boot.autoconfigure.http.HttpProperties.Encoding.Type.REQUEST)); filter.setForceResponseEncoding(this.properties.shouldForce(org.springframe work.boot.autoconfigure.http.HttpProperties.Encoding.Type.RESPONSE)); return filter; } //。。。。。。。 } 一句话总结：根据当前不同的条件判断，决定这个配置类是否生效！ 一旦这个配置类生效：这个配置类就会给容器中添加各种组件； 这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的; 所有在配置文件中能配置的属性都是在xxxProperties类中封装着； 配置文件能配置什么就可以参照某个功能对应的这个属性类 //从配置文件中获取指定的值和bean的属性进行绑定 @ConfigurationProperties(prefix = \"spring.http\") public class HttpProperties { // ..... } ","date":"2021-07-04","objectID":"/springboot/:4:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"自动配置原理再理解 SpringBoot类启动的时候有一个@SpringBootApplication注解 该注解里面又包含了三个非常重要的注解 @SpringBootConfiguration:点进去以后可以看到里面的底层是Configuration注解，说白了就是支持JavaConfig的方式来进行配置(使用Configuration配置类等同于XML文件) @EnableAutoConfiguration:开启自动配置功能 @ComponentScan:这个注解，默认是扫描当前类下的package。将@Controller/@Service/@Component/@Repository等注解加载到IOC容器中 ","date":"2021-07-04","objectID":"/springboot/:5:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"重点EnableAutoConfiguration 我们知道SpringBoot可以帮我们减少很多的配置，也肯定听过“约定大于配置”这么一句话，那SpringBoot是怎么做的呢？其实靠的就是@EnableAutoConfiguration注解。 简单来说，这个注解可以帮助我们自动载入应用程序所需要的所有默认配置。 点进去查看发现有两个比较主要的注解 @AutoConfigurationPackage：自动配置包 @Import：给IOC容器导入组件 ","date":"2021-07-04","objectID":"/springboot/:5:1","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"AutoConfigurationPackage 这个注解称之为自动配置包，点进去查看后发现依赖的还是Import注解 在点进去看，就发现重要的代码 在默认的情况下就是将：主配置类(@SpringBootApplication)所在包及其子包里边的组件扫描到Spring容器中。 看完这句话，会不会觉得，这不就是ComponentScan的功能吗？这俩不就重复了吗？ 我开始也有这个疑问，直到我看到文档的这句话： it will be used when scanning for code @Entity classes. It is generally recommended that you place EnableAutoConfiguration (if you’re not using @SpringBootApplication) in a root package so that all sub-packages and classes can be searched. 比如说，你用了Spring Data JPA，可能会在实体类上写@Entity注解。这个@Entity注解由@AutoConfigurationPackage扫描并加载，而我们平时开发用的@Controller/@Service/@Component/@Repository这些注解是由ComponentScan来扫描并加载的。 ","date":"2021-07-04","objectID":"/springboot/:5:2","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"回到Import 回到@Import(AutoConfigurationImportSelector.class)这句代码上，再点进去AutoConfigurationImportSelector.class看看具体的实现是什么： 我们再进去看一下这些配置信息是从哪里来的(进去getCandidateConfigurations方法)： 这里包装了一层，我们看到的只是通过SpringFactoriesLoader来加载，还没看到关键信息，继续进去： 梳理思路： FACTORIES_RESOURCE_LOCATION的值是META-INF/spring.factories Spring启动的时候会扫描所有jar路径下的META-INF/spring.factories，将其文件包装成Properties对象 从Properties对象获取到key值为EnableAutoConfiguration的数据，然后添加到容器中去 ","date":"2021-07-04","objectID":"/springboot/:5:3","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"总结 @SpringBootApplication等同于下面三个注解： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 其中@EnableAutoConfiguration是关键(启用自动配置)，内部实际上就去加载META-INF/spring.factories文件的信息，然后筛选出以EnableAutoConfiguration为key的数据，加载到IOC容器中，实现自动配置功能！ 通过获取到的key值为EnableAutoConfiguration的数据，就会自动去加载META-INF/spring.factories文件的信息，然后通过xxxxAutoConfiguration中的条件来判断当前这个配置类是否生效，如果生效就会往容器中添加组件 这些组件中属性的值是从对应的Properties类中所获取的，这些属性又是和配置文件进行绑定的 所以我们需要配置什么就可以参照properties来配置，你也可以去手动的修改其默认值 ","date":"2021-07-04","objectID":"/springboot/:5:4","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"静态资源映射规则 SpringBoot中，SpringMVC的web配置都在WebMvcAutoconfiguration这个配置类里面 WebMvcAutoconfiguration中有很多配置的方法 有一个方法addResourceHandlers添加资源处理 @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { // 已禁用默认资源处理 logger.debug(\"Default resource handling disabled\"); return; } // 缓存控制 Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); // webjars 配置 if (!registry.hasMappingForPattern(\"/webjars/**\")) { customizeResourceHandlerRegistration(registry.addResourceHandler(\"/webjars/**\") .addResourceLocations(\"classpath:/META-INF/resources/webjars/\") .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } // 静态资源配置 String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern) .addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations())) .setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } 读源码： 比如/webjars/** ，都需要去classpath:/META-INF/resources/webjars/找对应的资源； 那什么是webjars呢？ Webjars本质就是以jar包的方式引入我们的静态资源 ， 我们以前要导入一个静态资源文件，直接导入即可 使用SpringBoot需要使用Webjars，我们可以去搜索一下： 网站：https://www.webjars.org 【网站带看，并引入jQuery测试】 要使用jQuery，我们只要要引入jQuery对应版本的pom依赖即可！ \u003cdependency\u003e \u003cgroupId\u003eorg.webjars\u003c/groupId\u003e \u003cartifactId\u003ejquery\u003c/artifactId\u003e \u003cversion\u003e3.4.1\u003c/version\u003e \u003c/dependency\u003e 查看webjars目录结构，并访问jQuery.js文件 访问：只要是静态资源，SpringBoot就会去对应的路径寻找资源 第二种静态资源映射规则 那我们项目中要是使用自己的静态资源该怎么导入呢？我们看下一行代码； 我们去找staticPathPattern发现第二种映射规则 ： /** , 访问当前的项目任意资源，它会去找 resourceProperties 这个类，我们可以点进去看一下分析：. // 进入方法 public String[] getStaticLocations() { return this.staticLocations; } // 找到对应的值 private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS; // 找到路径 private static final String[] CLASSPATH_RESOURCE_LOCATIONS = { \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" }; ResourceProperties 可以设置和我们静态资源有关的参数；这里面指向了它会去寻找资源的文件夹，即 上面数组的内容。 所以有四个目录存放的静态资源可以被我们识别 \"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\" 总结： 1、在SpringBoot，可以使用一下方式处理静态资源 webjars localhost:8080/webjars/ public，static，resources localhost:8080/ 2、优先级：resources\u003estatic(默认)\u003epublic 3、只要自定义了目录，默认路径就会失效，再次访问原来默认对应的路径就会报错 /* 与 /** 的区别： /* ：会匹配所有的url(只匹配当前文件夹下文件，不匹配子文件夹下文件)，包括*.jsp页面 /** ：会匹配所有的url(匹配当前文件夹下文件和子文件夹下文件)；路径型的和后缀型的url(包括/login，.jsp，.js，*.html等) ","date":"2021-07-04","objectID":"/springboot/:6:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"模板引擎 思想： 模板引擎的作用就是我们来写一个页面模板，比如有些值呢，是动态的，我们写一些表达式。而这些 值，从哪来呢，就是我们在后台封装一些数据。然后把这个模板和这个数据交给我们模板引擎，模板引 擎按照我们这个数据帮你把这表达式解析、填充到我们指定的位置，然后把这个数据最终生成一个我们 想要的内容给我们写出去，这就是我们这个模板引擎，不管是jsp还是其他模板引擎，都是这个思想。只 不过呢，就是说不同模板引擎之间，他们可能这个语法有点不一样。其他的我就不介绍了，我主要来介 绍一下SpringBoot给我们推荐的Thymeleaf模板引擎，这模板引擎呢，是一个高级语言的模板引擎，他 的这个语法更简单。而且呢，功能更强大。 引入Thymeleaf Thymeleaf 官网： Thymeleaf 在Github 的主页： Spring官方文档： 找到我们对应的版本 找到对应的pom依赖： \u003c!--thymeleaf--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-thymeleaf\u003c/artifactId\u003e \u003c/dependency\u003e Maven会自动下载jar包，我们可以去看看下载的东西 Thymeleaf分析 前面呢，我们已经引入了Thymeleaf，那这个要怎么使用呢？ 我们首先得按照SpringBoot的自动配置原理看一下我们这个Thymeleaf的自动配置规则，在按照那个规 则，我们进行使用。 我们去找一下Thymeleaf的自动配置类：ThymeleafProperties @ConfigurationProperties( prefix = \"spring.thymeleaf\" ) public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; } 我们可以在其中看到默认的前缀和后缀！ 我们只需要把我们的html页面放在类路径下的templates下，thymeleaf就可以帮我们自动渲染了。 使用thymeleaf什么都不需要配置，只需要将他放在指定的文件夹下即可！ ","date":"2021-07-04","objectID":"/springboot/:7:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"MVC自动配置原理 官网阅读 官方文档 Spring MVC Auto-configuration // Spring Boot为Spring MVC提供了自动配置，它可以很好地与大多数应用程序一起工作。 Spring Boot provides auto-configuration for Spring MVC that works well with most applications. // 自动配置在Spring默认设置的基础上添加了以下功能： The auto-configuration adds the following features on top of Spring's defaults: // 包含视图解析器 Inclusion of ContentNegotiatingViewResolver and BeanNameViewResolver beans. // 支持静态资源文件夹的路径，以及webjars Support for serving static resources, including support for WebJars // 自动注册了Converter： // 转换器，这就是我们网页提交数据到后台自动封装成为对象的东西，比如把\"1\"字符串自动转换为 int类型 // Formatter：【格式化器，比如页面给我们了一个2019-8-10，它会给我们自动格式化为Date对象】 Automatic registration of Converter, GenericConverter, and Formatter beans. // HttpMessageConverters // SpringMVC用来转换Http请求和响应的的，比如我们要把一个User对象转换为JSON字符串，可以去看官网文档解释； Support for HttpMessageConverters (covered later in this document). // 定义错误代码生成规则的 Automatic registration of MessageCodesResolver (covered later in this document). // 首页定制 Static index.html support. // 图标定制 Custom Favicon support (covered later in this document). // 初始化数据绑定器：帮我们把请求数据绑定到JavaBean中！ Automatic use of a ConfigurableWebBindingInitializer bean (covered later in this document). /* 如果您希望保留Spring Boot MVC功能，并且希望添加其他MVC配置（拦截器、格式化程序、视图控制器和其他功能）， 则可以添加自己的@configuration类，类型为webmvcconfiguer，但不添加@EnableWebMvc。如果希望提供 RequestMappingHandlerMapping、RequestMappingHandlerAdapter或 ExceptionHandlerExceptionResolver的自定义实例，则可以声明WebMVCregistrationAdapter实例来提供此类组件。 */ If you want to keep Spring Boot MVC features and you want to add additional MVC configuration (interceptors, formatters, view controllers, and other features), you can add your own@Configuration class of type WebMvcConfigurer but without @EnableWebMvc.If you wish to provide custom instances of RequestMappingHandlerMapping,RequestMappingHandlerAdapter, orExceptionHandlerExceptionResolver, you can declare a WebMvcRegistrationsAdapter instance to provide such components. // 如果您想完全控制Spring MVC，可以添加自己的@Configuration，并用@EnableWebMvc进行注释。 If you want to take complete control of Spring MVC, you can add your own @Configuration annotated with @EnableWebMvc. ContentNegotiatingViewResolver 内容协商视图解析器 自动配置了ViewResolver，就是我们之前学习SpringMVC的视图解析器； 即根据方法的返回值取得视图对象(View)，然后由视图对象决定如何渲染(转发，重定向) 先查看一下源码：找到WebMvcAutoConfiguration，然后搜索ContentNegotiatingViewResolver。找到如下方法！ @Bean @ConditionalOnBean(ViewResolver.class) @ConditionalOnMissingBean(name = \"viewResolver\", value = ContentNegotiatingViewResolver.class) public ContentNegotiatingViewResolver viewResolver(BeanFactory beanFactory) { ContentNegotiatingViewResolver resolver = new ContentNegotiatingViewResolver(); resolver.setContentNegotiationManager(beanFactory.getBean(ContentNegotiationManager.class)); // ContentNegotiatingViewResolver使用所有其他视图解析器来定位视图，因此它应该具有较高的优先级 resolver.setOrder(Ordered.HIGHEST_PRECEDENCE); return resolver; } 可以点击这个类(ContentNegotiatingViewResolver)看看，找到对应的解析视图的代码 @Nullable // 注解说明：@Nullable 即参数可为null public View resolveViewName(String viewName, Locale locale) throws Exception { RequestAttributes attrs = RequestContextHolder.getRequestAttributes(); Assert.state(attrs instanceof ServletRequestAttributes, \"No currentServletRequestAttributes\"); List\u003cMediaType\u003e requestedMediaTypes = this.getMediaTypes(((ServletRequestAttributes)attrs).getRequest()); if (requestedMediaTypes != null) { // 获取候选的视图对象 List\u003cView\u003e candidateViews = this.getCandidateViews(viewName, locale,requestedMediaTypes); // 选择一个最适合的视图对象，然后把这个对象返回 View bestView = this.getBestView(candidateViews, requestedMediaTypes, attrs); if (bestView != null) { return bestView; } } // ..... } 继续点击查看，是如何获取视图的呢？ getCandidateViews中看到他是把所有的视图解析器拿来，进行while循环，挨个解析！ Iterator var5 = this.viewResolvers.iterator(); 所以得出结论：ContentNegotiatingViewResolver 这个视图解析器就是用来组合所有的视图解析器的 再去研究下他的组合逻辑，看到有个属性viewResolvers，看看它是在哪里进行赋值的！ protected void initServletContext(ServletContext servletContext) { // 这里它是从beanFactory工具中获取容器中的所有视图解析器 // ViewRescolver.class 把所有的视图解析器来组合的 Collection\u003cViewResolver\u003e matchingBeans = BeanFactoryUtils.bea","date":"2021-07-04","objectID":"/springboot/:8:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["SpringBoot"],"content":"test ","date":"2021-07-04","objectID":"/springboot/:9:0","tags":["SpringBoot"],"title":"Springboot","uri":"/springboot/"},{"categories":["Redis"],"content":"Redis","date":"2021-07-04","objectID":"/redis/","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"NoSQL概述 1、单机Mysql的年代 90年代，一个基本的网站访问量不会太大，单个数据库完全足够 那个时候，更多的去使用静态网页HTML~ 服务器根本就没有太大的压力！ 思考，这种情况下：整个网站的瓶颈是什么？ 1、数据量如果太大了，一个机器放不下了！ 2、数据的索引，一个机器内存也存放不下 3、访问量（读写混合），一个服务器承受不了 只要开始出现以上的三种情况之一，那么你就必须要晋级！ Memcached（缓存） + MySQL + 垂直拆分（读写分离） 网站80%的情况下都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据的压力 我们可以使用缓存来保证效率。 发展过程：优化数据结构和索引—\u003e文件缓存（IO）—\u003eMemcached（当时最热门的技术！） 3、分库分表 + 水平拆分 + MySQL集群 技术和业务在发展的同时，对人的要求也越来越高 本质：数据库（读、写） 早些年MyISAM：表锁（有100万条数据，查询张三就会将整个表锁起来，等查询完后才能进行下一条查 询，十分影响效率！高并发下就会出现严重的锁问题。 转战Innodb：行锁 慢慢的就开始使用分库分表来解决写的压力！MySQL在那个年代推出了表分区！这个并没有多少公司使用 MySQL的集群，很好满足那个年代的所有需求 4、如今最近的年代 MySQL等关系型数据库就不够用了！数据量很多，变化很快！ MySQL有的时候它用来存放一些比较大的文件，博客，图片！数据库表很大，效率就低了！如果有一种数 据库来专门处理这种数据，MySQL压力就变得十分小（研究如何处理这些问题！）大数据的IO压力下，表 几乎没法更改 目前一个基本的互联网项目 为什么要用NoSQL！ 用户的个人信息，社交网络，地理位置。用户自己产生的数据，用户日志等等爆发式增长！ 这时候我们就需要使用NoSQL数据库，NoSQL可以很好的处理以上的情况！ ","date":"2021-07-04","objectID":"/redis/:0:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"什么是NoSQL NoSQL NoSQL = Not Only SQL （不仅仅是SQL） 关系型数据库：表格，行，列 泛指非关系型数据库的，随着web2.0互联网的诞生！传统的关系型数据库很难对付web2.0时代！尤其是 超大规模的高并发社区！暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速， Redis是发展的最快的，而且是我们当下必须要掌握的一个技术！ 很多的数据类型用户的个人信息，社交网络，地理位置。这些数据类型的存储不需要一个固定的格式！不 需要多余的操作就可以横向扩展！ Map\u003cString，Object\u003e使用键值对来控制 NoSQL特点 解耦！ 1、方便扩展（数据之间没有关系，很好扩展！） 2、大数据量高性能（Redis一秒写8万次，读取11万，NoSQL的缓存是记录级是一种细粒度的缓存，性能 会比较高） 3、数据类型是多样型的！（不需要事先设计数据库！随取随用！如果数据量十分大的表，很多人无法设计了） 4、传统的 RDBMS（关系型数据库） 和 NoSQL 传统的RDBMS - 结构化组织 - SQL - 数据和关系都存在单独的表中 - 数据操作，数据定义语言 - 严格的一致性 - 基础的事务 NoSQL - 不仅仅是数据 - 没有固定的查询语言 - 键值对存储，列存储（HBase），文档存储（MongoDb），图形数据库（社交关系） - 最终一致性 - CAP定理和BASE　（异地存活！整个服务器宕机了，但是不影响其它的地方正常运行） - 高新能，高可用，高可扩 了解3V+3高 大数据时代的3V：主要是描述问题的 1、海量Volume 2、多样Variety 3、实时Velocity 大数据时代的3高：主要是对程序的要求 1、高并发 2、高可扩 3、高新能 真正在公司中的实践：NoSQL + RDBMS一起使用才是最强的 ","date":"2021-07-04","objectID":"/redis/:1:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"NoSQL的四大分类 KV键值对： 新浪：Redis 美团：Redis + Tair 阿里、百度：Redis + memcache 文档型数据库（bson格式 和 json一样） MongoDB（一般必须掌握） MongoDB是一个基于分布式文件存储的数据库，C++编写，主要用来处理大量的文档！ MongoDB是一个介于关系型数据库和非关系型数据库的中间产品！MongoDB是NoSQL中功能最丰富，最像关系型数据库的！ ConchDB（不做了解、国外的） 列存储数据库 HBase 分布式文件系统 图关系数据库 它不是存图形的，放的是关系，比如：朋友圈社交网络，广告推荐！ Neo4j，InfoGrid； Redis入门 ","date":"2021-07-04","objectID":"/redis/:2:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"概述 Redis是什么？ Redis（Remote Dictionary Server），即远程字典服务 是一个开源的使用ANSIC语言编写，支持网络、可基于内存亦可持久化的日志型、Key-Value数据库， 并提供多种语言的API redis会周期型的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且再次基础上实现了 master-slave（主从）同步。 Redis能干什么？ 1、 内存存储、持久化，内存中是断电即失，所以说持久化很重要。（RDB，AOF） 2、效率高，可以用于高速缓存 3、发布订阅系统 4、地图信息分析 5、计时器、计数器（浏览量！） ","date":"2021-07-04","objectID":"/redis/:3:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Windows安装 1、下载安装包 2、下载完毕得到压缩包 3、解压到自己环境目录下！Redis十分的小 4、开启Redis，双击运行即可！ 5、使用redis客户端来连接redis 记住一句话，Windows下使用确实简单，但是Redis推荐我们使用Linux去使用 ","date":"2021-07-04","objectID":"/redis/:4:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Linux安装包 1、下载安装包 2、解压Redis安装包！程序一般放在/opt下 3、进入解压后的文件，可以看到redis的配置文件 4、基本的环境安装 yum install gcc-c++ make make install 5、Redis的默认安装路径usr/local/bin 6、将redis配置文件。复制到我们当前的目录下 7、redis默认不是后台启动的，修改配置文件 8、启动redis服务 9、使用redis-cli进行连接测试 10、查看redis的进程是否开启 11、如何关闭redis服务shutdown 12、再次查看进程是否存在 ","date":"2021-07-04","objectID":"/redis/:5:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"测试性能 redis-benchmark是一个压力测试工具！ 官方自带的性能测试工具！ redis-benchmark +命令参数！ 可选参数如下： # 测试：100个并发连接 100000请求 redis-benchmark -h localhost -p 6379 -c 100 -n 100000 如何查看这些分析呢？ ","date":"2021-07-04","objectID":"/redis/:6:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"基础的知识 redis默认有16个数据库 默认使用的是第0个 可以使用select进行切换数据库！从0-15 清除当前数据库flushdb 清除全部数据库的内容flushall 127.0.0.1:6379[3]\u003e keys * # 查看数据库所有的key 1) \"name\" 127.0.0.1:6379[3]\u003e flushdb # 清除当前数据库 OK 127.0.0.1:6379[3]\u003e keys * (empty array) Redis是单线程的！ 明白Redis是很快的，官方表示，Redis是基于内存操作的，CPU不是Redis性能瓶颈，Redis的瓶颈是根据 机器的内存和网络带宽，既然可以使用单线程来实现，就使用单线程了！所以就使用单线程了！ Redis是C语言写的，官方提供的数据为 100000+QPS，完全不必同样是使用key-value的Memecache差！ Redis为什么是单线程还这么快？查文献巩固一下 1、误区1：高性能的服务器一定是多线程的？ 2、误区2：多线程（CPU上下文会切换）一定比单线程效率高！ 核心：redis是将所有的数据据全部放在内存中的，所以说使用单线程去操作效率就是最高的,多线程（CPU 上下文会切换：这是一个耗时的操作！！！），对于内存系统来说，如果没有上下文切换效率就是最高 的！多次读写都是在一个CPU上的，在内存情况下，这个就是最佳的方案！！ 五大数据类型 127.0.0.1:6379\u003e keys * # 查看所有的key 1) \"name\" 127.0.0.1:6379\u003e set age 1 OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e exists name # 判断当前key是否存在 (integer) 1 127.0.0.1:6379\u003e exists name1 (integer) 0 127.0.0.1:6379\u003e move name 1 # 移出当前key (integer) 1 127.0.0.1:6379\u003e keys * 1) \"age\" 127.0.0.1:6379\u003e set name felix OK 127.0.0.1:6379\u003e KEYS * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e get name \"felix\" 127.0.0.1:6379\u003e move name 10 (integer) 1 127.0.0.1:6379\u003e keys * 1) \"age\" 127.0.0.1:6379\u003e set name felix OK 127.0.0.1:6379\u003e keys * 1) \"age\" 2) \"name\" 127.0.0.1:6379\u003e expire name 10 # 设置key的过期时间，单位是秒 (integer) 1 127.0.0.1:6379\u003e ttl name # 查看当前key 的剩余时间 (integer) 6 127.0.0.1:6379\u003e ttl name (integer) 4 127.0.0.1:6379\u003e ttl name (integer) 4 127.0.0.1:6379\u003e ttl name (integer) 3 127.0.0.1:6379\u003e ttl name (integer) 2 127.0.0.1:6379\u003e ttl name (integer) 1 127.0.0.1:6379\u003e ttl name (integer) -2 127.0.0.1:6379\u003e get name (nil) 127.0.0.1:6379\u003e type name # 查看当前key的一个类型 string 127.0.0.1:6379\u003e type age string ","date":"2021-07-04","objectID":"/redis/:7:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"String（字符串） 127.0.0.1:6379\u003e set key1 clover # 设置值 OK 127.0.0.1:6379\u003e get key1 # 获得值 \"clover\" 127.0.0.1:6379\u003e keys * # 获得所有的key 1) \"key1\" 127.0.0.1:6379\u003e EXISTS key1 # 判断某一个key是否存在 (integer) 1 127.0.0.1:6379\u003e APPEND key1 \"felix\" # 追加字符串，如果当前key不存在，就相当于setkey (integer) 11 127.0.0.1:6379\u003e get key1 \"cloverfelix\" 127.0.0.1:6379\u003e STRLEN key1 # 获取字符串的长度！ (integer) 11 127.0.0.1:6379\u003e APPEND key1 \",wei\" (integer) 15 127.0.0.1:6379\u003e get key1 \"cloverfelix,wei\" 127.0.0.1:6379\u003e STRLEN key1 (integer) 15 127.0.0.1:6379\u003e set views 0 # 初始浏览量为0 OK 127.0.0.1:6379\u003e get views \"0\" 127.0.0.1:6379\u003e incr views # 自增1 浏览量变为1 (integer) 1 127.0.0.1:6379\u003e incr views (integer) 2 127.0.0.1:6379\u003e get views \"2\" 127.0.0.1:6379\u003e decr views # 自减1 浏览量减一 (integer) 1 127.0.0.1:6379\u003e decr views (integer) 0 127.0.0.1:6379\u003e decr views (integer) -1 127.0.0.1:6379\u003e get views \"-1\" 127.0.0.1:6379\u003e INCRBY views 10 # 可以设置步长，指定增量 (integer) 9 127.0.0.1:6379\u003e DECRBY views 10 (integer) -1 127.0.0.1:6379\u003e get views \"-1\" 127.0.0.1:6379\u003e # 字符串范围 range 127.0.0.1:6379\u003e set key1 \"hello,clover\" # 设置key1的值 OK 127.0.0.1:6379\u003e get key1 \"hello,clover\" 127.0.0.1:6379\u003e GETRANGE key1 0 4 # 截取字符串[0，4] \"hello\" 127.0.0.1:6379\u003e GETRANGE key1 0 -1 # 获取全部的字符串 和 get key是一样的 \"hello,clover\" # 替换！ 127.0.0.1:6379\u003e set key2 abcdefg OK 127.0.0.1:6379\u003e get key (nil) 127.0.0.1:6379\u003e get key2 \"abcdefg\" 127.0.0.1:6379\u003e SETRANGE key2 1 xxx # 替换指定位置开始的字符串 (integer) 7 127.0.0.1:6379\u003e get key2 \"axxxefg\" # setex （set with expire） # 设置过期时间 # setnx （set if not exist） # 不存在再设置（在分布式锁中会常常使用！） 127.0.0.1:6379\u003e setex key3 30 cloverfelix # 设置key3的值为 cloverfelix，30秒后过期 OK 127.0.0.1:6379\u003e ttl key3 (integer) 21 127.0.0.1:6379\u003e setnx mykey \"redis\" # 如果mykey 不存在，创建mykey (integer) 1 127.0.0.1:6379\u003e keys * 1) \"key3\" 2) \"key2\" 3) \"mykey\" 4) \"key1\" 127.0.0.1:6379\u003e ttl key3 (integer) -2 127.0.0.1:6379\u003e setnx mykey \"mongoDB\" 如果mykey 存在，创建失败！ (integer) 0 127.0.0.1:6379\u003e get mykey \"redis\" # mset # mget 127.0.0.1:6379\u003e mset k1 v1 k2 v2 k3 v3 # 同时设置多个值 OK 127.0.0.1:6379\u003e keys * 1) \"k1\" 2) \"k3\" 3) \"k2\" 127.0.0.1:6379\u003e mget k1 k2 k3 # 同时获取 1) \"v1\" 2) \"v2\" 3) \"v3\" 127.0.0.1:6379\u003e msetnx k1 v2 k4 v4 # msetnx 是一个原子性的操作，要么一起成功，要么一起失败！ (integer) 0 127.0.0.1:6379\u003e get k4 (nil) 127.0.0.1:6379\u003e # 对象 set user:1 {name:zhangsan,age:3} # 这里的key是一个巧妙的设计：user:{id}:{filed属性}， 如此设计在Redis中完全是OK的 # 那么在设置文章的浏览量的时候就可以指定多篇文章的浏览量 127.0.0.1:6379\u003e mset user:1:name zhangsan user:1:age 3 OK 127.0.0.1:6379\u003e mget user:1:name user:1:age 1) \"zhangsan\" 2) \"3\" getset # 先get然后在set 127.0.0.1:6379\u003e getset db redis # 如果不存在值，则返回为null (nil) 127.0.0.1:6379\u003e get db \"redis\" 127.0.0.1:6379\u003e getset db mongodb # 如果存在值，获取原来的值，并设置新的值 \"redis\" 127.0.0.1:6379\u003e get db \"mongodb\" String类似的使用场景：value除了是我们的字符串还可以是我们的数字！ ","date":"2021-07-04","objectID":"/redis/:8:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"List 在redis乱码，我们可以把list玩成栈、队列、阻塞队列！ 所有的list命令都是用l开头的 127.0.0.1:6379\u003e LPUSH list one # 将一个或多个值插入列表的头部（从左边插入进去） (integer) 1 127.0.0.1:6379\u003e LPUSH list two (integer) 2 127.0.0.1:6379\u003e LPUSH list three (integer) 3 127.0.0.1:6379\u003e keys * 1) \"list\" 127.0.0.1:6379\u003e LRANGE list 0 -1 # 获取值是从前往后的，即先插入进来的值放在最后，最后插入的值放在最前面，下标为0 1) \"three\" 2) \"two\" 3) \"one\" 127.0.0.1:6379\u003e LRANGE list 0 1 # 通过区间获取具体的值 1) \"three\" 2) \"two\" 127.0.0.1:6379\u003e RPUSH list right # 将一个或多个值插入列表的头部（从右边插入进去） (integer) 4 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"two\" 3) \"one\" 4) \"right\" # LPOP # RPOP 127.0.0.1:6379\u003e lpop list # 移出list的第一个元素 \"three\" 127.0.0.1:6379\u003e rpop list # 移出list的最后一个元素 \"right\" 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" # index 127.0.0.1:6379\u003e lindex list 0 # 通过下标获得list中的某一个值！ \"two\" 127.0.0.1:6379\u003e lindex list 1 \"one\" # llen 127.0.0.1:6379\u003e lpush list one (integer) 1 127.0.0.1:6379\u003e lpush list two (integer) 2 127.0.0.1:6379\u003e lpush list three (integer) 3 127.0.0.1:6379\u003e llen list # 返回列表的长度 (integer) 3 # 移除指定的值！ 127.0.0.1:6379\u003e lrem list 1 three # 移出list集合中指定个数的value，精确匹配 (integer) 1 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" 127.0.0.1:6379\u003e lpush list three (integer) 3 127.0.0.1:6379\u003e lpush list three (integer) 4 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"three\" 2) \"three\" 3) \"two\" 4) \"one\" 127.0.0.1:6379\u003e lrem list 2 three (integer) 2 127.0.0.1:6379\u003e LRANGE list 0 -1 1) \"two\" 2) \"one\" # list截断 127.0.0.1:6379\u003e rpush mylist \"hello\" (integer) 1 127.0.0.1:6379\u003e rpush mylist \"hello1\" (integer) 2 127.0.0.1:6379\u003e rpush mylist \"hello2\" (integer) 3 127.0.0.1:6379\u003e rpush mylist \"hello3\" (integer) 4 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello\" 2) \"hello1\" 3) \"hello2\" 4) \"hello3\" 127.0.0.1:6379\u003e ltrim mylist 1 2 # 通过下标截取指定的长度，这个list已经被改变了，截断了只剩下截取的元素 OK 127.0.0.1:6379\u003e LRANGE mylist 0 -1 1) \"hello1\" 2) \"hello2\" 127.0.0.1:6379\u003e # rpoplpush 移出列表的最后一个元素，将它移动到新的列表中！ 127.0.0.1:6379\u003e rpush mylist \"hello\" (integer) 1 127.0.0.1:6379\u003e rpush mylist \"hello1\" (integer) 2 127.0.0.1:6379\u003e rpush mylist \"hello2\" (integer) 3 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"hello1\" 3) \"hello2\" 127.0.0.1:6379\u003e rpoplpush mylist myotherlist # 移出右边的最后一个元素，加入到新的list集合中去 \"hello2\" 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"hello1\" 127.0.0.1:6379\u003e lrange myotherlist 0 -1 1) \"hello2\" 127.0.0.1:6379\u003e # lset 将列表中指定下标的值替换为另外一个值，相当于更新操作 127.0.0.1:6379\u003e exists list # 判断这个表是否存在 (integer) 0 127.0.0.1:6379\u003e lset list 0 item # 如果不存在列表我们去更新就会报错 (error) ERR no such key 127.0.0.1:6379\u003e lpush list value1 (integer) 1 127.0.0.1:6379\u003e lrange list 0 0 1) \"value1\" 127.0.0.1:6379\u003e lset list 0 item # 如果存在，更新当前下标的值 OK 127.0.0.1:6379\u003e lrange list 0 0 1) \"item\" 127.0.0.1:6379\u003e lset list 1 test # 如果不存在，则会报错！ (error) ERR index out of range # linsert 将某个具体的value插入到列表中的某个元素的前面或者后面！ 127.0.0.1:6379\u003e rpush mylist hello (integer) 1 127.0.0.1:6379\u003e rpush mylist world (integer) 2 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"world\" 127.0.0.1:6379\u003e linsert mylist before world other (integer) 3 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"other\" 3) \"world\" 127.0.0.1:6379\u003e linsert mylist after world new (integer) 4 127.0.0.1:6379\u003e lrange mylist 0 -1 1) \"hello\" 2) \"other\" 3) \"world\" 4) \"new\" 小结 它实际上是一个链表，可以在节点前后插入，left，right都可以插入值 如果key不存在，创建新的链表 如果key存在，新增内容 如果移出了所有值，空链表，也代表不存在！ 在两边插入或者改动值，效率最高！中间元素，相对来说效率会低一点！ 可以当作消息队列（Lpush，Rpop），也可以作为栈（Lpush，Lpop） ","date":"2021-07-04","objectID":"/redis/:9:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Set（集合） set中的值是不能重复的！且插入值是随机分布的，并不是有序集合 127.0.0.1:6379\u003e sadd myset \"hello\" # sadd =\u003e set add set集合中添加元素 (integer) 1 127.0.0.1:6379\u003e sadd myset \"clover\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"cloverfelix\" (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset # smembers =\u003e set members 查看指定set的所有值 1) \"hello\" 2) \"clover\" 3) \"cloverfelix\" 127.0.0.1:6379\u003e sismember myset \"felix\" # sismember =\u003e set exist member 判断某一个值是不是在set集合中 (integer) 0 127.0.0.1:6379\u003e sismember myset \"clover\" # 存在集合中就返回0，不存在就返回值为1 (integer) 1 ###################################### 127.0.0.1:6379\u003e scard myset # 获取set集合中元素的个数 (integer) 3 ##################################### srem 127.0.0.1:6379\u003e srem myset \"hello\" # 移除set集合中的指定的元素 (integer) 1 127.0.0.1:6379\u003e scard myset (integer) 2 127.0.0.1:6379\u003e SMEMBERS myset 1) \"clover\" 2) \"cloverfelix\" ##################################### set 是无序不重复集合。抽随机！ 127.0.0.1:6379\u003e SRANDMEMBER myset # 随机抽选出一个元素 \"felix\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"clover\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"clover\" 127.0.0.1:6379\u003e SRANDMEMBER myset \"felix\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 # 随机抽取指定个数的元素 1) \"felix\" 2) \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 1) \"cloverfelix\" 2) \"test\" 127.0.0.1:6379\u003e SRANDMEMBER myset 2 1) \"felix\" 2) \"test\" ##################################### 删除指定的key，随机删除key 127.0.0.1:6379\u003e SMEMBERS myset 1) \"clover\" 2) \"test\" 3) \"felix\" 4) \"cloverfelix\" 127.0.0.1:6379\u003e spop myset # 随机删除一些set集合中的元素 \"test\" 127.0.0.1:6379\u003e spop myset \"clover\" 127.0.0.1:6379\u003e spop myset \"cloverfelix\" 127.0.0.1:6379\u003e SMEMBERS myset 1) \"felix\" ##################################### 将一个指定的值，移动到另外一个set集合中！ 127.0.0.1:6379\u003e sadd myset \"hello\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"world\" (integer) 1 127.0.0.1:6379\u003e sadd myset \"clover\" (integer) 1 127.0.0.1:6379\u003e sadd myset2 \"felix\" (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"hello\" 2) \"clover\" 3) \"world\" 127.0.0.1:6379\u003e SMOVE myset myset2 \"clover\" # 将一个指定的值，移动到另外一个set集合中！，第一个参数是源地址，第二个参数是目的地址 (integer) 1 127.0.0.1:6379\u003e SMEMBERS myset 1) \"hello\" 2) \"world\" 127.0.0.1:6379\u003e SMEMBERS myset2 1) \"clover\" 2) \"felix\" 127.0.0.1:6379\u003e ##################################### 微博，B站，公共关注（并集） 数字集合类： - 差集 - 交集 - 并集 127.0.0.1:6379\u003e sadd key1 a (integer) 1 127.0.0.1:6379\u003e sadd key1 b (integer) 1 127.0.0.1:6379\u003e sadd key1 c (integer) 1 127.0.0.1:6379\u003e sadd key2 c (integer) 1 127.0.0.1:6379\u003e sadd key2 d (integer) 1 127.0.0.1:6379\u003e sadd key2 e (integer) 1 127.0.0.1:6379\u003e SDIFF key1 key2 # 差集 1) \"a\" 2) \"b\" 127.0.0.1:6379\u003e SINTER key1 key2 # 交集 1) \"c\" 127.0.0.1:6379\u003e SUNION key1 key2 # 并集 1) \"c\" 2) \"b\" 3) \"a\" 4) \"d\" 5) \"e\" 127.0.0.1:6379\u003e ","date":"2021-07-04","objectID":"/redis/:10:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Hash（哈希） Hash插入值是顺序插入，并且是可重复的！ 可以将其想象成一个Map集合！之前我们用的都是Key-Value，而我们这里是将Value换成Map，也就是 key-map的形式，Map中存放的又是一个key-value，所以这个时候这个值是一个Map集合 Hash本质和String类型没有太大区别，还是一个简单的key-value 127.0.0.1:6379\u003e hset myhash test1 felix # set一个具体的key-value OK 127.0.0.1:6379\u003e hset myhash test2 ryan OK 127.0.0.1:6379\u003e hget myhash test1 # 获取一个字段值 \"felix\" 127.0.0.1:6379\u003e hget myhash test2 \"ryan\" 127.0.0.1:6379\u003e hmset myhash test1 clover test2 cosy # set多个具体的key-value OK 127.0.0.1:6379\u003e hmget myhash test1 test2 # 获取多个字段值 1) \"clover\" 2) \"cosy\" 127.0.0.1:6379\u003e hgetall myhash # 获取全部数据，展示是key-value形式 1) \"test1\" 2) \"clover\" 3) \"test2\" 4) \"cosy\" 127.0.0.1:6379\u003e hdel myhash test2 # 删除指定key字段！对应的value值也就消失了！ (integer) 1 127.0.0.1:6379\u003e hgetall myhash 1) \"test1\" 2) \"clover\" 127.0.0.1:6379\u003e ######################################## hlen 获取hash的长度 127.0.0.1:6379\u003e hmset myhash test2 felix OK 127.0.0.1:6379\u003e HGETALL myhash 1) \"test1\" 2) \"clover\" 3) \"test2\" 4) \"felix\" 127.0.0.1:6379\u003e HLEN myhash # 获取hash表的字段数量 (integer) 2 127.0.0.1:6379\u003e ######################################## 127.0.0.1:6379\u003e HEXISTS myhash test0 # 判断hash中指定字段是否存在！ (integer) 1 127.0.0.1:6379\u003e HEXISTS myhash test4 (integer) 0 127.0.0.1:6379\u003e ######################################## # 只获得所有filed # 只获得所有value 127.0.0.1:6379\u003e hkeys myhash 1) \"test1\" 2) \"test2\" 3) \"test3\" 4) \"test0\" 127.0.0.1:6379\u003e hvals myhash # 这个地方使用的是简写 1) \"clover\" 2) \"felix\" 3) \"clover\" 4) \"clover\" 127.0.0.1:6379\u003e ######################################## incr 自增 decr 自减 127.0.0.1:6379\u003e hset myhash test4 5 (integer) 1 127.0.0.1:6379\u003e HINCRBY myhash test4 1 # 自增加1 (integer) 6 127.0.0.1:6379\u003e HINCRBY myhash test4 -1 # 这就相当于执行自减了 (integer) 5 127.0.0.1:6379\u003e hsetnx myhash test5 clover # 判断某一个值是否存在，不存在就创建一个，存在就返回0且不能设置 (integer) 1 127.0.0.1:6379\u003e hsetnx myhash test5 felix (integer) 0 127.0.0.1:6379\u003e hash用来保存变更的数据，尤其是用户信息之类的，经常变更的信息！hash更适合于对象的存储，String 更加适合字符串存储！ ","date":"2021-07-04","objectID":"/redis/:11:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Zset（有序集合） 在set基础上，增加了一个值 127.0.0.1:6379\u003e zadd myset 1 one # 添加一个值 (integer) 1 127.0.0.1:6379\u003e zadd myset 2 two 3 three # 添加多个值 (integer) 2 127.0.0.1:6379\u003e ZRANGE myset 0 -1 1) \"one\" 2) \"two\" 3) \"three\" 127.0.0.1:6379\u003e ########################################## 排序是如何实现的呢 127.0.0.1:6379\u003e zadd salary 2500 xiaohong # 添加三个用户 (integer) 1 127.0.0.1:6379\u003e zadd salary 5000 zhangsan (integer) 1 127.0.0.1:6379\u003e zadd salary 500 clover (integer) 1 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf # 显示全部的用户！ 从小到大排序 1) \"clover\" 2) \"xiaohong\" 3) \"zhangsan\" 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf +inf withscores # 显示全部用户并且附带成绩 1) \"clover\" 2) \"500\" 3) \"xiaohong\" 4) \"2500\" 5) \"zhangsan\" 6) \"5000\" 127.0.0.1:6379\u003e ZRANGEBYSCORE salary -inf 2500 withscores # 显示工资小于2500员工的升序排序 1) \"clover\" 2) \"500\" 3) \"xiaohong\" 4) \"2500\" # 此处 狂神将得由问题：RANGE命令是指从小到大，不能用于去执行从大到小，要执行从大到小，得使用ZREVRANGE 127.0.0.1:6379\u003e ZREVRANGE salary 0 -1 1) \"zhangsan\" 2) \"xiaohong\" 3) \"clover\" 127.0.0.1:6379\u003e ######################################## # 移除指定的元素rem 127.0.0.1:6379\u003e zrange salary 0 -1 1) \"clover\" 2) \"xiaohong\" 3) \"zhangsan\" 127.0.0.1:6379\u003e zrem salary xiaohong # 移除有序集合中指定的元素 (integer) 1 127.0.0.1:6379\u003e zrange salary 0 -1 1) \"clover\" 2) \"zhangsan\" 127.0.0.1:6379\u003e zcard salary # 获取有序集合中的个数 (integer) 2 ####################################### 127.0.0.1:6379\u003e zadd myset 1 one 2 two 3 three (integer) 3 127.0.0.1:6379\u003e ZCOUNT myset 1 3 # 获取指定区间的成员数量 (integer) 3 127.0.0.1:6379\u003e ZCOUNT myset 1 2 (integer) 2 127.0.0.1:6379\u003e 三种特殊数据类型 ","date":"2021-07-04","objectID":"/redis/:12:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"geospatial地理位置 Redis的Geo在Redis3.2版本就推出了！这个功能可以推算地理位置的信息，两地之间的距离，方圆几里的人！ 只有六个命令 getadd # getadd 添加地理位置 # 规则：两级无法直接添加，我们一般会下载城市数据，直接通过java程序一次性导入！ # 有效的经度从-180度到180度。 # 有效的纬度从-85.05112878度到85.05112878度。 # 当坐标位置超出上述指定范围时，该命令将会返回一个错误。 # 127.0.0.1:6379\u003e geoadd china:city 39.90 116.40 beijin (error) ERR invalid longitude,latitude pair 39.900000,116.400000 # 参数 key 值（） 127.0.0.1:6379\u003e geoadd china:city 116.40 39.90 beijing (integer) 1 127.0.0.1:6379\u003e geoadd china:city 121.47 31.23 shanghai (integer) 1 127.0.0.1:6379\u003e geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shengzhen (integer) 2 127.0.0.1:6379\u003e geoadd china:city 120.16 30.24 hangzhou 108.96 34.26 xian (integer) 2 getpos 获得当前定位：一定是一个坐标值！ 127.0.0.1:6379\u003e GEOPOS china:city beijing # 获取指定的城市的经度和纬度！ 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" 127.0.0.1:6379\u003e GEOPOS china:city beijing chongqi 1) 1) \"116.39999896287918091\" 2) \"39.90000009167092543\" 2) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" GEODIST 两人之间的距离！ 单位： m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 127.0.0.1:6379\u003e GEODIST china:city beijing shanghai km # 查看上海到北京的直线距离 \"1067.3788\" 127.0.0.1:6379\u003e GEODIST china:city beijing chongqi km # 查看重庆到北京的直线距离 \"1464.0708\" georadius以给定的经纬度为中心， 找出某一半径内的元素 我附近的人？ （获得所有附近的人的地址，定位！）通过半径来查询！ 获得指定数量的人，200 所有数据应该都录入：china:city ，才会让结果更加清晰！ 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 1000 km # 以110，30 这个经纬度为中心，寻 找方圆1000km内的城市 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km 1) \"chongqi\" 2) \"xian\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist # 显示到中间距离的位置 1) 1) \"chongqi\" 2) \"341.9374\" 2) 1) \"xian\" 2) \"483.8340\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withcoord # 显示他人的定位信息 1) 1) \"chongqi\" 2) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 2) 1) \"xian\" 2) 1) \"108.96000176668167114\" 2) \"34.25999964418929977\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist withcoord count 1 # 筛选出指定的结果！ 1) 1) \"chongqi\" 2) \"341.9374\" 3) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 127.0.0.1:6379\u003e GEORADIUS china:city 110 30 500 km withdist withcoord count 2 1) 1) \"chongqi\" 2) \"341.9374\" 3) 1) \"106.49999767541885376\" 2) \"29.52999957900659211\" 2) 1) \"xian\" 2) \"483.8340\" 3) 1) \"108.96000176668167114\" 2) \"34.25999964418929977\" GEORADIUSBYMEMBER # 找出位于指定元素周围的其他元素！ 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city beijing 1000 km 1) \"beijing\" 2) \"xian\" 127.0.0.1:6379\u003e GEORADIUSBYMEMBER china:city shanghai 400 km 1) \"hangzhou\" 2) \"shanghai\" GEOHASH 命令 - 返回一个或多个位置元素的 Geohash 表示 该命令将返回11个字符的Geohash字符串! # 将二维的经纬度转换为一维的字符串，如果两个字符串越接近，那么则距离越近！ 127.0.0.1:6379\u003e geohash china:city beijing chongqi 1) \"wx4fbxxfke0\" 2) \"wm5xzrybty0\" GEO 底层的实现原理其实就是 Zset！我们可以使用Zset命令来操作geo！ 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 # 查看地图中全部的元素 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 5) \"shanghai\" 6) \"beijing\" 127.0.0.1:6379\u003e zrem china:city beijing # 移除指定元素！ (integer) 1 127.0.0.1:6379\u003e ZRANGE china:city 0 -1 1) \"chongqi\" 2) \"xian\" 3) \"shengzhen\" 4) \"hangzhou\" 5) \"shanghai\" ","date":"2021-07-04","objectID":"/redis/:13:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Hyperloglog 什么是基数？ A {1,3,5,7,8,7} B{1,3,5,7,8} 基数（是指一个集合中不重复的元素）= 5 可以接受误差！ 简介 Redis 2.8.9 版本就更新了 Hyperloglog 数据结构！ Redis Hyperloglog 基数统计的算法！ 优点：占用的内存是固定，2^64 不同的元素的基数，只需要废 12KB内存！如果要从内存角度来比较的 话 Hyperloglog 首选！ 网页的 UV （一个人访问一个网站多次，但是还是算作一个人！） 传统的方式， set 保存用户的id，然后就可以统计 set 中的元素数量作为标准判断 ! 这个方式如果保存大量的用户id，就会比较麻烦！我们的目的是为了计数，而不是保存用户id； 0.81% 错误率！ 统计UV任务，可以忽略不计的！ 测试使用 127.0.0.1:6379\u003e PFadd mykey a b c d e f g h i j # 创建第一组元素 mykey (integer) 1 127.0.0.1:6379\u003e PFCOUNT mykey # 统计 mykey 元素的基数数量 (integer) 10 127.0.0.1:6379\u003e PFadd mykey2 i j z x c v b n m # 创建第二组元素 mykey2 (integer) 1 127.0.0.1:6379\u003e PFCOUNT mykey2 (integer) 9 127.0.0.1:6379\u003e PFMERGE mykey3 mykey mykey2 # 合并两组 mykey mykey2 =\u003e mykey3 并集 OK 127.0.0.1:6379\u003e PFCOUNT mykey3 # 看并集的数量！ (integer) 15 如果允许容错，那么一定可以使用 Hyperloglog ！ 如果不允许容错，就使用 set 或者自己的数据类型即可！ ","date":"2021-07-04","objectID":"/redis/:14:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"Bitmap 为什么其他教程都不喜欢讲这些？这些在生活中或者开发中，都有十分多的应用场景，学习了，就是就是 多一个思路！ 技多不压身！ 位存储 统计用户信息，活跃，不活跃！ 登录 、 未登录！ 打卡，365打卡！ 两个状态的，都可以使用 Bitmap！ Bitmap 位图，数据结构！ 都是操作二进制位来进行记录，就只有0 和 1 两个状态！ 365 天 = 365 bit 1字节 = 8bit 46 个字节左右！ 测试 一个方框代表一天，来统计一个星期的打卡情况 使用bitmap 来记录 周一到周日的打卡！ 查看某一天是否打卡 127.0.0.1:6379\u003e getbit sign 3 (integer) 1 127.0.0.1:6379\u003e getbit sign 6 (integer) 0 统计操作，统计 打卡的天数！ 127.0.0.1:6379\u003e bitcount sign # 统计这周的打卡记录，就可以看到是否有全勤！ (integer) 3 事务 要么同时成功，要么同时失败，原子性！ Redis事务本质：一组命令的集合！一个事务中的所有命令都会被序列化，在事务执行过程中，会按照顺序 执行！ 一次性（队列中的命令一次执行完）、顺序性、排他性（不允许别人干扰）！执行一系列命令！ ----------------- 队列 set（命令）set（命令） set（命令）执行---------------------- 命令执行的过程中是不允许被打断的，出现了错误会去执行处理错误的机制 Redis事务没有隔离级别的概念 所有的命令在事务中，并没有直接被执行！只有发起执行命令的时候才会执行！Exec（执行命令） Redis单条命令是保存原子性的，但是redis事务不保证原子性！ redis的事务： 开启事务（multi） 命令入队（） 执行命令（exec） 正常执行事务！ 127.0.0.1:6379\u003e multi # 开启事务 OK # 命令入队 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e get k2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e exec # 执行事务 1) OK 2) OK 3) \"v2\" 4) OK 127.0.0.1:6379\u003e multi # 开启事务 OK # 命令入队 127.0.0.1:6379\u003e set k1 v1 放弃事务！ 127.0.0.1:6379\u003e multi # 开启事务 OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e DISCARD # 取消事务 OK 127.0.0.1:6379\u003e get k4 # 事务队列中命令都不会被执行！ (nil) 编译型异常（代码有问题！ 命令有错！） ，事务中所有的命令都不会被执行！ 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e set k1 v1 QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e getset k3 # 错误的命令 (error) ERR wrong number of arguments for 'getset' command 127.0.0.1:6379\u003e set k4 v4 QUEUED 127.0.0.1:6379\u003e set k5 v5 QUEUED 127.0.0.1:6379\u003e exec # 执行事务报错！ (error) EXECABORT Transaction discarded because of previous errors. 127.0.0.1:6379\u003e get k5 # 所有的命令都不会被执行！ (nil) 运行时异常（1/0）， 如果事务队列中存在语法性错误，那么执行命令的时候，其他命令是可以正常执行的，错误命令抛出异常！ 127.0.0.1:6379\u003e set k1 \"v1\" OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e incr k1 # 会执行的时候失败！ QUEUED 127.0.0.1:6379\u003e set k2 v2 QUEUED 127.0.0.1:6379\u003e set k3 v3 QUEUED 127.0.0.1:6379\u003e get k3 QUEUED 127.0.0.1:6379\u003e exec 1) (error) ERR value is not an integer or out of range # 虽然第一条命令报错了，但是依旧正常执行成功了！ 2) OK 3) OK 4) \"v3\" 127.0.0.1:6379\u003e get k2 \"v2\" 127.0.0.1:6379\u003e get k3 \"v3\" 监控！ Watch （面试常问！） 悲观锁： 很悲观，认为什么时候都会出问题，无论做什么都会加锁！ 乐观锁： 很乐观，认为什么时候都不会出问题，所以不会上锁！ 更新数据的时候去判断一下，在此期间是否 有人修改过这个数据， 获取version 更新的时候比较 version Redis测监视测试 正常执行成功！ 127.0.0.1:6379\u003e set money 100 OK 127.0.0.1:6379\u003e set out 0 OK 127.0.0.1:6379\u003e watch money # 监视 money 对象 OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 20 QUEUED 127.0.0.1:6379\u003e INCRBY out 20 QUEUED 127.0.0.1:6379\u003e exec # 事务正常结束，数据期间没有发生变动，这个时候就正常执行成功！ 1) (integer) 80 2) (integer) 20 测试多线程修改值 , 使用watch 可以当做redis的乐观锁操作！ Watch的生命周期，只是和事务关联的，一个事务执行完毕（执行了exec命令），相应的Watch的生命周期即将结束 127.0.0.1:6379\u003e watch money # 监视 money OK 127.0.0.1:6379\u003e multi OK 127.0.0.1:6379\u003e DECRBY money 10 QUEUED 127.0.0.1:6379\u003e INCRBY out 10 QUEUED 127.0.0.1:6379\u003e exec # 执行之前，另外一个线程，修改了我们的值，这个时候，就会导致事务执行失败！ (nil) ################################ 这是第二条线程，在还没执行exec时，第二条线程插队修改了值 127.0.0.1:6379\u003e get money \"80\" 127.0.0.1:6379\u003e set money 1000 OK 如果修改失败，获取最新的值就好 Jedis 我们要使用 Java 来操作 Redis 什么是Jedis 是 Redis 官方推荐的 java连接开发工具！ 使用Java 操作Redis 中间件！如果你要使用 java操作redis，那么一定要对Jedis 十分的熟悉！ 测试 1、导入对应的依赖 \u003c!--导入jedis包--\u003e \u003cdependencies\u003e \u003c!-- https://mvnrepository.com/artifact/redis.clients/jedis --\u003e \u003cdependency\u003e \u003cgroupId\u003eredis.clients\u003c/groupId\u003e \u003cartifactId\u003ejedis\u003c/artifactId\u003e \u003cversion\u003e3.3.0\u003c/version\u003e \u003c/dependency\u003e \u003c!--fastjson--\u003e \u003c!-- https://mvnrepository.com/artifact/com.alibaba/fastjson --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.alibaba\u003c/groupId\u003e \u003cartifactId\u003efastjson\u003c/artifactId\u003e \u003cversion\u003e1.2.75\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e 2、编码测试： -连接数据库 操作命令 断开连接！ package com.clover; import redis.clients.jedis.Jedis; public class TestPing { public static void main(String[] args) { //1、new Jedis()对象即可 Jedis jedis = new Jedis(\"127.0.0.1\",6379); //jedis所有的命令就是我们之前学习的所有指令！所以之前的指令学习很重要 System.out.println(jedis.ping()); } } ","date":"2021-07-04","objectID":"/redis/:15:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"常用的API String List Set Hash Zset 事务 package com.clover; import com.alibaba.fastjson.JSONObject; import redis.clients.jedis.Jedis; import redis.clients.jedis.Transaction; public class TestTX { public static void main(String[] args) { Jedis jedis = new Jedis(\"127.0.0.4\", 6379); //每次执行前清空数据库 jedis.flushDB(); JSONObject jsonObject = new JSONObject(); jsonObject.put(\"hello\",\"world\"); jsonObject.put(\"name\",\"clover\"); //开启事务 Transaction multi = jedis.multi(); String result = jsonObject.toJSONString(); try { multi.set(\"user1\",result); multi.set(\"user2\",result); //int i = 1/0;//代码抛出异常，执行失败 multi.exec();//执行事务 } catch (Exception e) { multi.discard();//放弃事务 e.printStackTrace(); } finally { System.out.println(jedis.get(\"user1\")); System.out.println(jedis.get(\"user2\")); jedis.close();//关闭连接 } } } SpringBoot整合 SpringBoot操作数据：都是集中在spring-data中操作 SpringData和SpringBoot齐名的项目！ 说明：在SpringBoot2.x之后，原来使用的Jedis被替换成了lettuce jedis：采用的直连，多个线程操作的话，是不安全的，如果想要避免不安全的，使用jedis pool连接池！更像 BIO模式 lettuce：采用netty，实例可以在多个线程中进行共享，不存在线程不安全的情况！可以减少线程数量，更像 NIO模式 源码分析 @Bean @ConditionalOnMissingBean(name = \"redisTemplate\") // 我们可以自己定义一个redis Template来替换这个默认的！ public RedisTemplate\u003cObject, Object\u003e redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { // 默认的 Redis Template 没有过多的设置，redis 对象都是需要序列化！ // 两个泛型都是 Object, Object 的类型，我们后使用需要强制转换 \u003cString, Object\u003e RedisTemplate\u003cObject, Object\u003e template = new RedisTemplate\u003c\u003e(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean // 由于 String 是redis中最常使用的类型，所以说单独提出来了一个bean！ public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } 整合测试 1、导入redis依赖 \u003c!--操作redis--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.boot\u003c/groupId\u003e \u003cartifactId\u003espring-boot-starter-data-redis\u003c/artifactId\u003e \u003c/dependency\u003e 2、编写配置文件 # SpringBoot 所有的配置类，都会由一个自动配置类 # 自动配置类都会绑定一个 properties 配置文件 # 配置redis spring.redis.host=127.0.0.1 spring.redis.port=6379 # 我们以后使用集群部署时尽量使用最新的lettuce，因为Jedis中有一部分配置类不存在，所以不生效 # 而lettuce中所有的类默认都是生效的 我们以后使用集群部署时尽量使用最新的lettuce，因为Jedis中有一部分配置类不存在，所以不生效 而lettuce中所有的类默认都是生效的 3、测试！ package com.clover.redis02springboot; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.springframework.data.redis.core.RedisTemplate; @SpringBootTest class Redis02SpringbootApplicationTests { @Autowired private RedisTemplate redisTemplate; @Test void contextLoads() { // redisTemplate 操作不同的数据类型，api和我们的指令是一样的 // opsForValue 操作字符串 类似String // opsForList 操作List 类似List // opsForSet // opsForHash // opsForZSet // opsForGeo // opsForHyperLogLog // 除了基本的操作，我们常用的方法都可以直接通过redisTemplate操作，比如事务，和基本的CRUD // 获取redis的连接对象 // RedisConnection connection =redisTemplate.getConnectionFactory().getConnection(); // connection.flushDb(); // connection.flushAll(); redisTemplate.opsForValue().set(\"mykey\",\"clover\"); System.out.println(redisTemplate.opsForValue().get(\"mykey\")); } } 关于对象的保存时出现的问题 1、使用了序列化时的结果 @Test public void test() throws JsonProcessingException { // 真实的开发中，我们一般使用json来传递对象 User user = new User(\"clover\", 3); // 这个是我们创建SpringBoot项目中所存在的，也就是jackson对象 // 序列化该对象 String obj = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\",obj); System.out.println(redisTemplate.opsForValue().get(\"user\")); } 2、未使用序列化时的结果 @Test public void test() throws JsonProcessingException { // 真实的开发中，我们一般使用json来传递对象 User user = new User(\"clover\", 3); // 这个是我们创建SpringBoot项目中所存在的，也就是jackson对象 // 序列化该对象 //String obj = new ObjectMapper().writeValueAsString(user); redisTemplate.opsForValue().set(\"user\",user); System.out.println(redisTemplate.opsForValue().get(\"user\")); } 产生的报错结果如下图： 我们编写一个自己的Tempalte package com.clover.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; i","date":"2021-07-04","objectID":"/redis/:16:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"RDB（Redis Database） 在主从复制中，RDB是用来备份的，存在在从机中，不占用主机内存！ 什么是RDB 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存里。 Redis会单独创建一个(fork)一个紫禁城来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。这就确保了极高的性能。 如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。RDB的缺点是最后一次持久化后的数据可能丢失。我们默认的就是RDB，一般情况下不需要修改这个配置！ rdb保存的文件是 dump.rdb 都是在我们的配置文件中的快照进行配置的！ 触发机制 1、sava规则满足的情况下，会自动触发rdb规则 2、执行flushall命令，也会触发我们的rdb规则 3、退出redis，也会产生rdb文件 备份就会自动生成一个dump.rdb文件 注意，使用sava命令保存时，也会产生一个edb文件 如何恢复rdb文件 1、只需要将rdb文件放在我们redis启动目录就可以了，redis启动的时候会自动检查dump.rdb 恢复其中的数据 2、查看需要存放的位置 127.0.0.1:6379\u003e config get dir 1) \"dir\" 2) \"/usr/local/bin\" 几乎它自己默认的配置就够用了，但是我们还是要去学习 优点: 1、适合大规模的数据恢复！ 2、对数据的完整性要求不高！ 缺点： 1、需要一定的时间间隔进行操作！如果redis意外宕机了，这个最后一次修改的数据就没有了！ 2、fork进程的时候，会占用一定的内存空间! ","date":"2021-07-04","objectID":"/redis/:17:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"AOF(Append Only File) 以日志的形式来记录每个写操作。将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据，换而言之，redis重启的化就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作 AOF保存的是appendonly.aof文件 append 默认是不开启的，我们需要手动进行配置！我们只需要将appendonly 改为yes就开启了aof！ 重启，redis就可以生效了！ 如果这个aof文件有错误，这时候redis是启动不起来的，我们需要修复这个aof文件 redis 给我们提供了一个工具redis-check-aof --fix 如果文件正常，重启就可以直接恢复了！ 但是它对文件进行修复，也不是全部修复，是可能损坏部分值的！！！ 重写规则说明 aof默认就是文件的无限追加，文件会越来越大 如果aof文件大于64M，太大了的话，就会fork一个新的进程来将我们的文件进行重写！ 优点和缺点 优点： 1、每一次修改都同步，文件的完整性会更好 2、每秒同步一次，可能会丢失一秒的数据 3、从不同步，效率是最高的！ 缺点： 1、相对于数据文件来说，aof远远大于rdb，修复的速度也比rdb慢！ 2、Aof运行效率也比rdb慢（因为其文件比rdb大），所以我们redis默认的配置就是rdb持久化！ 扩展： 1、RDB 持久化方式能够在指定的时间间隔内对你的数据进行快照存储 2、AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以Redis 协议追加保存每次写的操作到文件末尾，Redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于过大。 **3、只做缓存，如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化 ** 4、同时开启两种持久化方式 在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。 RDB 的数据不实时，同时使用两者时服务器重启也只会找AOF文件，那要不要只使用AOF呢？作者建议不要，因为RDB更适合用于备份数据库（AOF在不断变化不好备份），快速重启，而且不会有AOF可能潜在的Bug，留着作为一个万一的手段。 5、性能建议 因为RDB文件只用作后备用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留 save 900 1 这条规则。 如果Enable AOF ，好处是在最恶劣情况下也只会丢失不超过两秒数据，启动脚本较简单只load自己的AOF文件就可以了，代价一是带来了持续的IO，二是AOF rewrite 的最后将 rewrite 过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上，默认超过原大小100%大小重写可以改到适当的数值。 如果不Enable AOF ，仅靠 Master-Slave Repllcation 实现高可用性也可以，能省掉一大笔IO，也减少了rewrite时带来的系统波动。代价是如果Master/Slave 同时倒掉，会丢失十几分钟的数据，启动脚本也要比较两个 Master/Slave 中的 RDB文件，载入较新的那个，微博就是这种架构。 Redis发布订阅 Redis发布订阅（pub/sub）是一种消息通信模式：发送者（pub）发送消息，订阅者（sub）接受消息。 Redis客户端可以订阅任意数量的频道。 订阅/发布消息图： 下图展示了频道channel1，以及订阅这个频道的三个客户端–client2、client5和client1之间的关系： 当有新消息通过PUBLISH 命令发送给频道channel1时，这个消息就会被发送给订阅它的三个客户端： 命令 测试 订阅端： 127.0.0.1:6379\u003e SUBSCRIBE clover Reading messages... (press Ctrl-C to quit) 1) \"subscribe\" 2) \"clover\" 3) (integer) 1 # 等待读取推送的信息 1) \"message\" # 接送的是什么，消息 2) \"clover\" # 哪个频道的消息 3) \"hello,world\" # 消息的具体内容 1) \"message\" 2) \"clover\" 3) \"hello,cloverfelix\" 发送端: 127.0.0.1:6379\u003e PUBLISH clover \"hello,world\" # 发布者发布消息到频道 (integer) 1 127.0.0.1:6379\u003e PUBLISH clover \"hello,cloverfelix\" # 发布者发布消息到频道 (integer) 1 127.0.0.1:6379\u003e 原理 Redis是使用C实现的，通过分析 Redis 源码里的 pubsub.c 文件，了解发布和订阅机制的底层实现，籍此加深对 Redis 的理解。 Redis 通过 PUBLISH 、SUBSCRIBE 和 PSUBSCRIBE 等命令实现发布和订阅功能。 每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个字典就用于保存订阅频道的信息，其中，字典的键为正在被订阅的频道， 而字典的值则是一个链表， 链表中保存了所有订阅这个频道的客户端。 客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。 缺点 如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。 这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。 应用 消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现） 多人在线聊天室。 稍微复杂的场景，我们就会使用消息中间件MQ处理。 Redis主从复制 ","date":"2021-07-04","objectID":"/redis/:18:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"概念 主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower）， 数据的复制是单向的！只能由主节点复制到从节点（主节点以写为主、从节点以读为主）。 默认情况下，每台Redis服务器都是主节点 一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。 ","date":"2021-07-04","objectID":"/redis/:19:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"作用 数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。 故障恢复：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式 负载均衡：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。 高可用（集群）基石：主从复制还是哨兵和集群能够实施的基础。 ","date":"2021-07-04","objectID":"/redis/:20:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"为什么使用集群 一般来说，要将Redis运用于工程项目中，只使用一台Redis是万万不能的（宕机），原因如下： 1、从结构上，单个Redis服务器会发生单点故障，并且一台服务器需要处理所有的请求负载，压力较大； 2、从容量上，单个Redis服务器内存容量有限，就算一台Redis服务器内存容量为256G，也不能将所有内存用作Redis存储内存，一般来说，单台Redis最大使用内存不应该超过20G。 电商网站上的商品，一般都是一次上传，无数次浏览的，说专业点也就是\"多读少写\"。 对于这种场景，我们可以使如下这种架构： 环境配置 只用配置从库，不用配置主库，因为每个Redis是默认自己是主库 127.0.0.1:6379\u003e info replication # 查看当前库的信息 # Replication role:master # 角色 master connected_slaves:0 # 没有从机 master_failover_state:no-failover master_replid:ce9e2da75c46b69ccaf4bea614598be642658691 master_replid2:0000000000000000000000000000000000000000 master_repl_offset:0 second_repl_offset:-1 repl_backlog_active:0 repl_backlog_size:1048576 repl_backlog_first_byte_offset:0 repl_backlog_histlen:0 复制3个配置文件，然后修改对应的信息 1、端口 2、pid 名字 3、log文件名字 4、dump.rdb 名字 修改完毕后，启动我们3个redis服务，可以通过进程信息查看 ","date":"2021-07-04","objectID":"/redis/:21:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"一主二从 127.0.0.1:6380\u003e SLAVEOF 127.0.0.1 6379 OK 127.0.0.1:6380\u003e info replication # Replication role:slave # 当前角色是从机 master_host:127.0.0.1 # 可以查看到主机的信息 master_port:6379 master_link_status:up master_last_io_seconds_ago:3 master_sync_in_progress:0 slave_repl_offset:14 slave_priority:100 slave_read_only:1 replica_announced:1 connected_slaves:0 master_failover_state:no-failover master_replid:80653bedaad4360f908ff72a68a47a4bd1045f0f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:14 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:14 127.0.0.1:6380\u003e # 在主机中查看信息 127.0.0.1:6379\u003e info replication # Replication role:master connected_slaves:2 # 多了从机的信息，可以查看从机的信息 slave0:ip=127.0.0.1,port=6380,state=online,offset=56,lag=1 slave1:ip=127.0.0.1,port=6381,state=online,offset=56,lag=1 master_failover_state:no-failover master_replid:80653bedaad4360f908ff72a68a47a4bd1045f0f master_replid2:0000000000000000000000000000000000000000 master_repl_offset:56 second_repl_offset:-1 repl_backlog_active:1 repl_backlog_size:1048576 repl_backlog_first_byte_offset:1 repl_backlog_histlen:56 127.0.0.1:6379\u003e 如果两个都配置完了，就会显示两个从机 真实的主从配置应该在配置文件中配置，这样的话是永久的，我们这里使用的是命令，只是暂时的！ ","date":"2021-07-04","objectID":"/redis/:22:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"使用规则 1.从机只能读，不能写，主机可读可写但是多用于写。 2.从机只能读取内容，如果写入内容会报错 测试 主机断开连接，从机依旧连接到主机的，但是没有写操作，这个时候，主机如果回来了，从机依旧可以直接获取到主机写的信息 如果是使用命令行来配置的从机，这个时候如果重启了，就会变回主机！只要变为从机，立马就会从主机中获取值！ 复制原理 Slave 启动成功连接到 master 后会发送一个sync同步命令 Master 接到命令，启动后台的存盘进程，同时收集所有接收到的用于修改数据集命令，在后台进程执行完毕之后，master将传送整个数据文件到slave，并完成一次完全同步。 全量复制：而slave服务在接收到数据库文件数据后，将其存盘并加载到内存中。 增量复制：Master 继续将新的所有收集到的修改命令依次传给slave，完成同步 但是只要是重新连接master，一次完全同步（全量复制）将被自动执行！ 我们的数据一定可以在从机中看到！ 层层链路 上一个Master链接下一个Slave 这样也可以完成我们的主从复制！ 如果没有老大了，这个时候能不能选择一个老大出来呢？哨兵模式没出来之前是：手动选择 如果主机断开了连接，我们可以使用SLAVEOF no one让自己变成主机！其它的节点就可以手动连接到这个最新的主节点（手动）如果这个时候老大修复了，那就只有重新配置连接了！ ","date":"2021-07-04","objectID":"/redis/:23:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Redis"],"content":"哨兵模式 Redis缓存与雪崩 ","date":"2021-07-04","objectID":"/redis/:24:0","tags":["Redis"],"title":"Redis","uri":"/redis/"},{"categories":["Linux部署"],"content":"Linux部署","date":"2021-07-04","objectID":"/mutinodelinux/","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"部署项目到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:0:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"使用的是ruoyi进行试验 ","date":"2021-07-04","objectID":"/mutinodelinux/:1:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"第一步 首先将项目后端的数据库以及一些配置文件配置好 数据库配置： 对于这里的数据库必须使用远程的数据库，本地数据库是不起作用的 其次就是需要在服务器上创建对应的数据库，填写相关的信息 如果你有多台服务器的话你也可以架设到不同的服务器上（但我受限只有一台服务器，就在一台服务器上实验了） 修改redis配置 由于我们的项目全部是部署在服务器上的，所以我们所依赖的环境全部是存在于服务器上 由于我们服务器上的redis是没有设置密码的，所以默认为空 修改pom.xml文件中字符集的设置 注意：由于我采用的是ruoyi的项目，不同的项目对应不同的要求，ruoyi这个项目需要你改动一下pom.xml的配置文件 将encoder对应的地方的字符集编码改为UTF-8 4.修改pom.xml文件中的日志文件logs 如果是第一次运行的话是不存在改路径的，就需要改为自己日志文件存放的路径了 如果是以及运行过的，可以忽略不看 将一些环境配置修改好后就可以运行起来了，当你运行成功后，就可以先将前端打包传送到服务器上 使用terminus工具进行上传 注意：不要使用文件夹拖拽的形式，有可能存在一些隐藏的文件夹没有传递过去 传到服务器上的home目录下自己创建的文件夹中，然后在进行文件的解压 上传成功后，就对该文件夹进行解压**（前端）** 这就是解压后的文件 解压成功后，也把后端运行好的项目压缩上传到服务器 ","date":"2021-07-04","objectID":"/mutinodelinux/:2:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"然后开始进行前端的打包操作 安装依赖 由于我们使用的是root权限所以我们在前面加上--unsafe-perm npm install --unsafe-perm --registry=https://registry.npm.taobao.org 注意：如果你没有安装node的话是执行不了的，那你就必须得先去安装node后才可以执行，Linux上安 装node的教程可以参考codesheep给的pdf上安装node的教程，只是，他最后配置node环境变量时，那个profile文件夹是存在于/etc下的profile文件夹中进行配置，而不是他pdf上所给的指令，使用pdf上的指令会提示我们没有权限 安装完依赖后就可以使用npm run build:prod打生产环境前端的包就可以了 但是在运行的过程中出现了错误信息提示 于是，我将node_modules模块删除掉了，再次运行npm install时，又有新的错误信息出现了 然后我找到一个博客找寻到了解决方法：https://blog.csdn.net/Jserm/article/details/105997504 原因是因为：For security reasons, if you run npm install as root, npm will set the user to “nobody” when running postinstall scripts, which does not have access to the project directory, thus the error message. 出于安全原因，如果您以 root 身份运行 npm install，npm 将在运行 postinstall 脚本时将用户设置为“nobody”，该脚本无权访问项目目录，因此会出现错误消息。 总结：出现这么多错误的原因是：因为之前我上传到服务器上的代码都是我之前已经运行好了，并且配置好了环境变量，已经依赖的，所以导致我上传至服务器后重复安装依赖出现错误。 所以刚才我是重新下载的一个源码直接上传到服务器上去后就直接打jar包成功了 但是，这也可能只是我的片面看法，有可能是其它的原因，是我目前所没有想到的，我暂且就将这个错误认为是我之前已经运行好的代码中有依赖环境存在，是我反复的运行没有成功，这个错误，我会在后期中再次进行验证 ","date":"2021-07-04","objectID":"/mutinodelinux/:3:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Linux部署"],"content":"现在对后端进行打jar包 前提：是服务器上装有maven环境 先去下载一个maven安装包，寻找一个3.6.x版本的maven，找到一个历史地址：https://archive.apache.org/dist/maven/maven-3/ 安装完成以后按照codesheep给的安装教程去配置环境变量，注意自己文件夹的命名与codesheep是不一样的 注意：为什么需要打jar包与war包，因为使用jar包是因为SpringBoot内置了Tomcat服务器，就可以不适用服务器上的Tomcat，而使用内置的Tomcat就行；而打war包就是不使用SpringBoot内置的Tomcat，而是使用服务器自己搭配的Tomcat服务器 将前后端打包好后，就可以将前端部署到Nginx 修改nginx配置文件 先将user改为root，以防止出现不必要的权限错误（这里指的是如果你的项目放在root目录下） 然后修改根目录下的代理，改为dist文件夹所在位置 修改配置文件夹后，切记一定要重新加载Nginx，让其重新加载配置文件，否则你就会一直报错 注意：修改完配置文件后，一定要记得将配置文件中的pid注释去掉，否则重新加载配置文件的时候就会报错，找不到pid文件 如果出现了报错就去配置文件中去除该注释，然后再次重新运行Nginx即可 如果不放心，可以使用命令行去查看进程号，出现这个就代表Nginx启动成功了 前端部署起来后就可以开始部署后端了 使用命令nohup java -jar ruoyi.jar \u0026 直接运行jar包使用后台运行的方式 但是现在前后端都运行起来了，但是没有对接起来，出现如图所示情况 所以，我们就得去nginx中的配置文件进行配置请求路径，将它的请求路径转到后端上，与之对应 location /prod-api/ { proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://121.89.242.18:8081/; } 由于我部署的服务器部署到最后的时候前端连接后端一直超时，没有找到解决问题的原因，所以我暂时放置在这一步了 后续想法：搭载两台虚拟机进行再次搭建 ","date":"2021-07-04","objectID":"/mutinodelinux/:4:0","tags":["Linux部署"],"title":"MutiNodeLinux","uri":"/mutinodelinux/"},{"categories":["Mysql"],"content":"SQL常见问题","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/","tags":["Mysql"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["Mysql"],"content":"SQL常见问题 建立新连接时报错：can’t connect to mysql server on ‘localhost’ 原因：是因为本地服务器没开启 解决：用系统管理员打开命令行，输入net start mysql57启动服务器（这里如果是启动8.0服务器就是net start mysql80） 双数据库情况下，在普通命令行不输入密码直接进到mysql下服务器下 先进入mysql安装目录下的bin目录下 再输入mysql -uroot -P 3306 -p命令 直接回车，不需要输入密码 解决数据库建立新连接时报错access denied for user ‘root’@’localhost’以及mysql命令行工具闪退问题 解决： 到安装的MySQL的目录下，找my.ini文件，在[mysqld]后添加skip-grant-tables，保存退出 在命令行中进入mysql安装目录下的bin目录 输入mysql -uroot -P 3306 -p命令（这里端口号要对应）（作用：使其登录时跳过权限检查） 直接回车，不用输入密码 输入ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘123456’; 修改密码 报错： flush privileges; 刷新权限 再修改密码ALTER USER ‘root’@’localhost’ IDENTIFIED BY ‘123456’; 成功 参考博客：https://blog.csdn.net/weixin_43589074/article/details/107728819 ","date":"2021-07-04","objectID":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/:1:0","tags":["Mysql"],"title":"SQL常见问题","uri":"/sql%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"},{"categories":["Mysql"],"content":"mysql","date":"2021-07-04","objectID":"/mysql/","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1、初始Mysql ","date":"2021-07-04","objectID":"/mysql/:1:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.1、为什么学习数据库 1、岗位技能需求 2、现在的世界,得数据者得天下 3、存储数据的方法 4、程序,网站中,大量数据如何长久保存? 5、数据库是几乎软件体系中最核心的一个存在。 ","date":"2021-07-04","objectID":"/mysql/:1:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.2、什么是数据库 数据库 ( DataBase , 简称DB ) 概念 : 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库” 作用 : 保存,并能安全管理数据(如:增删改查等),减少冗余… 数据库总览 : 关系型数据库 ( SQL ) MySQL , Oracle , SQL Server , SQLite , DB2 , … 关系型数据库通过外键关联来建立表与表之间的关系 非关系型数据库 ( NOSQL ) Redis , MongoDB , … 非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自 身的属性来决定 ","date":"2021-07-04","objectID":"/mysql/:1:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.3、什么是DBMS 数据库管理系统(DataBase Management System) 数据库管理软件，科学组织和存储数据，高效的获取和维护数据 为社么要说这个呢？ 因为我们要学习的Mysql应该算是一个数据库管理系统 ","date":"2021-07-04","objectID":"/mysql/:1:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.4、MySQL简介 概念：是现在流行的，开源的，免费的，关系型数据库 历史：由瑞典MySQL AB公司开发，目前属于Oracle旗下产品。 特点： 免费，开源数据库 小巧，功能齐全 使用便捷 可运行与Windows或Linux操作系统 可适用于中小型甚至大型网站应用 官网 ","date":"2021-07-04","objectID":"/mysql/:1:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.5、安装MySQL 这里建议大家使用压缩版,安装快,方便.不复杂. 1、软件下载 MySQL5.7 64位下载地址 2、步骤 1、下载后得到zip压缩包 2、解压到自己想要安装到的目录，本人解压到的是D:\\Environment\\mysql-5.7.19 3、添加环境变量：我的电脑-\u003e属性-\u003e高级-\u003e环境变 选择PATH,在其后面添加: 你的mysql 安装文件下面的bin文件夹 4、编辑 my.ini 文件 ,注意替换路径位置 [mysqld] basedir=D:\\Program Files\\mysql-5.7\\ datadir=D:\\Program Files\\mysql-5.7\\data\\ port=3306 skip-grant-tables 5、启动管理员模式下的CMD，并将路径切换至mysql下的bin目录，然后输入mysqld –install (安装 mysql) 6、再输入mysqld --initialize-insecure --user=mysql初始化数据文件 7、然后再次启动mysql 然后用命令 mysql –u root –p 进入mysql管理界面（密码可为空） 8、进入界面后更改root密码 update mysql.user set authentication_string=password('xn123456') where user='root' and Host = 'localhost'; 9、刷新权限 flush privileges; 10、修改 my.ini文件删除最后一句skip-grant-tables 11、重启mysql即可正常使用 net stop mysql net start mysql 12、连接上测试出现以下结果就安装好了 一步步去做 , 理论上是没有任何问题的 . 如果以前装过,现在需要重装,一定要将环境清理干净 . 好了,到这里大家都装好了,因为刚接触,所以我们先不学习命令. 这里给大家推荐一个工具 : SQLyog . 即便有了可视化工具,可是基本的DOS命名大家还是要记住! ","date":"2021-07-04","objectID":"/mysql/:1:5","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.6、SQLyog 可手动操作,管理MySQL数据库的软件工具 特点 : 简洁 , 易用 , 图形化 使用SQLyog管理工具自己完成以下操作 : 连接本地MySQL数据库 新建MySchool数据库 数据库名称MySchool 新建数据库表(grade) 字段 GradeID : int(11) , Primary Key (pk) GradeName : varchar(50) 在历史记录中可以看到相对应的数据库操作的语句 . ","date":"2021-07-04","objectID":"/mysql/:1:6","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"1.7、连接数据库 打开MySQL命令窗口 在DOS命令行窗口进入 安装目录\\mysql\\bin 可设置环境遍历，设置了环境变量，可以在任意目录打开！ 连接数据库语句：mysql -h 服务器主机地址 -u 用户名 -p 用户密码 注意 : -p后面不能加空格,否则会被当做密码的内容,导致登录失败 ! 几个基本的数据库操作命令 update user set password=password('123456')where user='root'; 修改密码 flush privileges; 刷新数据库 show databases; 显示所有数据库 use dbname； 打开某个数据库 show tables; 显示数据库mysql中所有的表 describe user; 显示表mysql数据库中user表的列信息 create database name; 创建数据库 use databasename; 选择数据库 exit; 退出Mysql ? 命令关键词 : 寻求帮助 -- 表示注释 ","date":"2021-07-04","objectID":"/mysql/:1:7","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2、操作数据库 ","date":"2021-07-04","objectID":"/mysql/:2:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.1、结构化查询语句分类 ","date":"2021-07-04","objectID":"/mysql/:2:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.2、数据库操作 命令行操作数据库 创建数据库 :create database [if not exists] 数据库名; 删除数据库 : drop database [if exists] 数据库名; 查看数据库 : show databases; 使用数据库 : use 数据库名; 对比工具操作数据库 学习方法： 对照SQLyog工具自动生成的语句学习 固定语法中的单词需要记忆 ","date":"2021-07-04","objectID":"/mysql/:2:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.3、创建数据表 属于DDL的一种语法： create table [if not exists] `表名`( '字段名1' 列类型 [属性][索引][注释], '字段名2' 列类型 [属性][索引][注释], #... '字段名n' 列类型 [属性][索引][注释] )[表类型][表字符集][注释]; 说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键) ","date":"2021-07-04","objectID":"/mysql/:2:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.4、数据值和列类型 列类型：规定数据库中该列存放的数据类型 数值类型 字符串类型 日期和时间型数值类型 NULL值 理解为\"没有值\"或\"未知值\" 不要用NULL进行算术运算，结果仍为NULL ","date":"2021-07-04","objectID":"/mysql/:2:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.5、数据字段属性 UnSigned 无符号的 声明该数据列不允许负数 . ZEROFILL 0填充的 不足位数的用0来填充 , 如int(3),5则为005 Auto_InCrement 自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认) 通常用于设置主键 , 且为整数类型 可定义起始值和步长 当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表 SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局) NULL 和 NOT NULL 默认为NULL , 即没有插入该列的数值 如果设置为NOT NULL , 则该列必须有值 DEFAULT 默认的 用于设置默认值 例如,性别字段,默认为\"男\" , 否则为 “女” ; 若无指定该列的值 , 则默认值为\"男\"的值 -- 目标 : 创建一个school数据库 -- 创建学生表(列,字段) -- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住址,email -- 创建表之前 , 一定要先选择数据库 CREATE TABLE IF NOT EXISTS `student` ( `id` int(4) NOT NULL AUTO_INCREMENT COMMENT '学号', `name` varchar(30) NOT NULL DEFAULT '匿名' COMMENT '姓名', `pwd` varchar(20) NOT NULL DEFAULT '123456' COMMENT '密码', `sex` varchar(2) NOT NULL DEFAULT '男' COMMENT '性别', `birthday` datetime DEFAULT NULL COMMENT '生日', `address` varchar(100) DEFAULT NULL COMMENT '地址', `email` varchar(50) DEFAULT NULL COMMENT '邮箱', PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8 -- 查看数据库的定义 SHOW CREATE DATABASE school; -- 查看数据表的定义 SHOW CREATE TABLE student; -- 显示表结构 DESC student; -- 设置严格检查模式(不能容错了) SET sql_mode='STRICT_TRANS_TABLES'; ","date":"2021-07-04","objectID":"/mysql/:2:5","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.6、数据表的类型 设置数据表的类型 CREATE TABLE 表名( -- 省略一些代码 -- Mysql注释 -- 1. # 单行注释 -- 2. /*...*/ 多行注释 )ENGINE = MyISAM (or InnoDB) -- 查看mysql所支持的引擎类型 (表类型) SHOW ENGINES; MySQL的数据表的类型 : MyISAM , InnoDB , HEAP , BOB , CSV等… 常见的 MyISAM 与 InnoDB 类型： 经验(使用场合)： 使用M有ISAM：节约空间及相应速度 使用InnoDB：安全性，事务性及多用户操作数据表 数据表的存储位置 MySQL数据表以文件方式存放在磁盘中 包括表文件，数据文件，以及数据库的选项文件 位置：Mysql安装目录\\data\\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表 注意： InnoDB类型数据表只有一个*.frm文件，以及上一级目录的ibdata1文件 MyISAM类型数据表对应三个文件： *.frm –表结构定义文件 *.MYD –数据文件(data) *.MYI –索引文件(index) 设置数据表字符集 我们可谓护具看，数据表，数据列设置不同的字符集，设定方法； 创建时通过命令来设置，如：CREATE TABLE 表名()CHARSET = utf8; 如果没有设置，则根据MySQL数据库配置文件my.ini中的参数设定 ","date":"2021-07-04","objectID":"/mysql/:2:6","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"2.7、修改数据库 修改表（ALTER ＴABLE） 修改表名：ALTER TABLE 旧表名 RENAME AS 新表名 添加字段 : ALTER TABLE 表名 ADD字段名 列属性[属性] 修改字段 : ALTER TABLE 表名 MODIFY 字段名 列类型[属性] ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性] 删除字段 : ALTER TABLE 表名 DROP 字段名 删除数据表 语法： DROP TABLE [IF EXISTS] 表名 IF EXISTS为可选 , 判断是否存在该数据表 如删除不存在的数据表会抛出错误 其它 1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！ 2. 每个库目录存在一个保存当前数据库的选项文件db.opt。 3. 注释： 单行注释 # 注释内容 多行注释 /* 注释内容 */ 单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）) 4. 模式通配符： _ 任意单个字符 % 任意多个字符，甚至包括零字符 单引号需要进行转义 \\' 5. CMD命令行内的语句结束符可以为 \";\", \"\\G\", \"\\g\"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。 6. SQL对大小写不敏感 （关键字） 7. 清除已有语句：\\c ","date":"2021-07-04","objectID":"/mysql/:2:7","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3、MySQL数据管理 ","date":"2021-07-04","objectID":"/mysql/:3:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3.1、外键 外键概念 如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见， 外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为主表，具有此外键的 表被称为主表的从表。 在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。 外键作用 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据,约束。 使两张表形成关联，外键只能 引用外表中的列的值或使用空值。 创建外键 建表时指定外键约束 -- 创建外键的方式一 : 创建子表同时创建外键 -- 年级表 (id\\年级名称) CREATE TABLE `grade` ( `gradeid` INT(10) NOT NULL AUTO_INCREMENT COMMENT '年级ID', `gradename` VARCHAR(50) NOT NULL COMMENT '年级名称', PRIMARY KEY (`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号) CREATE TABLE `student` ( `studentno` INT(4) NOT NULL COMMENT '学号', `studentname` VARCHAR(20) NOT NULL DEFAULT '匿名' COMMENT '姓名', `sex` TINYINT(1) DEFAULT '1' COMMENT '性别', `gradeid` INT(10) DEFAULT NULL COMMENT '年级', `phoneNum` VARCHAR(50) NOT NULL COMMENT '手机', `address` VARCHAR(255) DEFAULT NULL COMMENT '地址', `borndate` DATETIME DEFAULT NULL COMMENT '生日', `email` VARCHAR(50) DEFAULT NULL COMMENT '邮箱', `idCard` VARCHAR(18) DEFAULT NULL COMMENT '身份证号', PRIMARY KEY (`studentno`), KEY `FK_gradeid` (`gradeid`), CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 创建外键方式二 : 创建子表完毕后,修改子表添加外键 ALTER TABLE `student` ADD CONSTRAINT `FK_gradeid` FOREIGN KEY (`gradeid`) REFERENCES `grade`(`gradeid`); 删除外键 操作：删除grade表，发现报错 注意：删除具有主外键关系的表时，要先删子表，后删主表 -- 删除外键 ALTER TABLE student DROP FOREIGN KEY FK_gradeid; -- 发现执行完上面的,索引还在,所以还要删除索引 -- 注:这个索引是建立外键的时候默认生成的 ALTER TABLE student DROP INDEX FK_gradeid; ","date":"2021-07-04","objectID":"/mysql/:3:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3.2、DML语言 数据库意义：数据存储、数据管理 管理数据库数据方法： 通过SQLyog等管理工具管理数据库数据 通过DML语句管理数据库数据 DML语言：数据操作语言 用于操作数据库对象中所包含的数据 包括 INSERT(添加数据语句) UPDATE(更新数据语句) DELETE(删除数据语句) ","date":"2021-07-04","objectID":"/mysql/:3:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3.3、添加数据 INSERT 命令 语法： INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') 注意： 字段或值之间使用英文逗号隔开。 ‘字段1,字段2,字段3’该部分可省略，但添加的值无比与表结构，数据列，顺序相对应，且数量一致 可同时插入多条数据，values后用英文逗号隔开 -- 使用语句如何增加语句? -- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES('值1','值2','值3') INSERT INTO grade(gradename) VALUES ('大一'); -- 主键自增,那能否省略呢? INSERT INTO grade VALUES ('大二'); -- 查询:INSERT INTO grade VALUE ('大二')错误代码： 1136 Column count doesn`t match value count at row 1 -- 结论:'字段1,字段2...'该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致. -- 一次插入多条数据 INSERT INTO grade(gradename) VALUES ('大三'),('大四'); ","date":"2021-07-04","objectID":"/mysql/:3:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3.4、修改数据 update命令 语法： UPDATE 表名 SET column_name=value [,column_name2=value2,...] [WHERE condition]; 注意： column_name韋要更改的数据列 value为修改后的数据，可以为变量，具体指表达式或者嵌套的SELECT结果 condition为筛选条件，如不指定则修改该表的所有列数据 where条件子句 可以简单的理解为：有条件的从表中筛选数据 测试： -- 修改年级信息 UPDATE grade SET gradename = '高中' WHERE gradeid = 1; ","date":"2021-07-04","objectID":"/mysql/:3:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"3.5、删除数据 DELETE命令 语法： DELETE FROM 表名 [WHERE condition]; 注意：condition为筛选条件，如不指定则删除该表的所有列数据 -- 删除最后一个数据 DELETE FROM grade WHERE gradeid = 5 TRUNCATE命令 作用：用于完全清空表数据，但表结构，索引，约束等不变； 语法： TRUNCATE [TABLE] table_name; -- 清空年级表 TRUNCATE grade 注意：区别于DELETE命令 相同：都能删除数据，不删除表结构，但TRUNCATE速度更快 不同： 使用TRUNCATE TABLE 重新设置 AUTO_INCREMENT计数器 使用TRUNCATE TABLE 不会对事务有影响 测试： -- 创建一个测试表 CREATE TABLE `test` ( `id` INT(4) NOT NULL AUTO_INCREMENT, `coll` VARCHAR(20) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 -- 插入几个测试数据 INSERT INTO test(coll) VALUES('row1'),('row2'),('row3'); -- 删除表数据(不带where条件的delete) DELETE FROM test; -- 结论:如不指定Where则删除该表的所有列数据,自增当前值依然从原来基础上进行,会记录日志. -- 删除表数据(truncate) TRUNCATE TABLE test; -- 结论:truncate删除数据,自增当前值会恢复到初始值重新开始;不会记录日志. -- 同样使用DELETE清空不同引擎的数据库表数据.重启数据库服务后 -- InnoDB : 自增列从初始值重新开始 (因为是存储在内存中,断电即失) -- MyISAM : 自增列依然从上一个自增数据基础上开始 (存在文件中,不会丢失) ","date":"2021-07-04","objectID":"/mysql/:3:5","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4、使用DQL查询数据 ","date":"2021-07-04","objectID":"/mysql/:4:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.1、DQL语言 **DQL( Data Query Language 数据查询语言 ) ** 查询数据库数据 , 如SELECT语句 简单的单表查询或多表的复杂查询和嵌套查询 是数据库语言中最核心,最重要的语句 使用频率最高的语句 SELECT语法 SELECT [ALL | DISTINCT] {* | table.* | [table.field1[as alias1][,table.field2[as alias2]][,...]]} FROM table_name [as table_alias] [left | right | inner join table_name2] -- 联合查询 [WHERE ...] -- 指定结果需满足的条件 [GROUP BY ...] -- 指定结果按照哪几个字段来分组 [HAVING] -- 过滤分组的记录必须满足的次要条件 [ORDER BY ...] -- 指定查询记录按一个或多个条件排序 [LIMIT {[offset,]row_count | row_countOFFSET offset}]; -- 指定查询的记录从哪条至哪条 注意 : [ ] 括号代表可选的 , { }括号代表必选得 ","date":"2021-07-04","objectID":"/mysql/:4:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.2、指定查询字段 -- 查询表中所有的数据列结果 , 采用 **\" \\* \"** 符号; 但是效率低，不推荐 . -- 查询所有学生信息 SELECT * FROM student; -- 查询指定列(学号 , 姓名) SELECT studentno,studentname FROM student; AS子句作为别名 作用： 可以给数据列取一个新别名 可给表去一个新别名 可把经计算或总结的结果用另一个新名称来代替 -- 这里是为列取别名(当然as关键词可以省略) SELECT studentno AS 学号,studentname AS 姓名 FROM student; -- 使用as也可以为表取别名 SELECT studentno AS 学号,studentname AS 姓名 FROM student AS s; -- 使用as,为查询结果取一个新名字 -- CONCAT()函数拼接字符串 SELECT CONCAT('姓名:',studentname) AS 新姓名 FROM student; DISTINCT关键字的使用 作用 : 去掉SELECT查询返回的记录结果中重复的记录 ( 返回所有列的值都相同 ) , 只返回一条 -- 查看哪些同学参加了考试(学号) 去除重复项 SELECT * FROM result; -- 查看考试成绩 SELECT studentno FROM result; -- 查看哪些同学参加了考试 SELECT DISTINCT studentno FROM result; -- 了解:DISTINCT 去除重复项 , (默认是ALL) 使用表达式的列 数据库中的表达式：一般由文本值，列值，NULL，函数和操作符等组成 应用场景： SELECT语句返回结果列中使用 SELECT语句中的ORDER　BY，HAVING等子句中使用 DML语句中的where条件语句中使用表达式 -- selcet查询中可以使用表达式 SELECT @@auto_increment_increment; -- 查询自增步长 SELECT VERSION(); -- 查询版本号 SELECT 100*3-1 AS 计算结果; -- 表达式 -- 学员考试成绩集体提分一分查看 SELECT studentno,StudentResult+1 AS '提分后' FROM result; 避免SQL返回结果中包含 ’ . ’ , ’ * ’ 和括号等干扰开发语言程序. ","date":"2021-07-04","objectID":"/mysql/:4:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.3、where条件语句 作用：用于检索数据表中符合条件的记录 搜索条件可由一个或多个逻辑表达式组成，结果一般为真或假 逻辑操作符 测试： -- 满足条件的查询(where) SELECT Studentno,StudentResult FROM result; -- 查询考试成绩在95-100之间的 SELECT Studentno,StudentResult FROM result WHERE StudentResult\u003e=95 AND StudentResult\u003c=100; -- AND也可以写成 \u0026\u0026 SELECT Studentno,StudentResult FROM result WHERE StudentResult\u003e=95 \u0026\u0026 StudentResult\u003c=100; -- 模糊查询(对应的词:精确查询) SELECT Studentno,StudentResult FROM result WHERE StudentResult BETWEEN 95 AND 100; -- 除了1000号同学,要其他同学的成绩 SELECT studentno,studentresult FROM result WHERE studentno!=1000; -- 使用NOT SELECT studentno,studentresult FROM result WHERE NOT studentno=1000; 模糊查询：比较操作符 注意： 数值数据类型的记录之间才能进行算术运算； 相同数据类型的数据之间才能进行比较； 测试： -- 模糊查询 between and \\ like \\ in \\ null -- ============================================= -- LIKE -- ============================================= -- 查询姓刘的同学的学号及姓名 -- like结合使用的通配符 : % (代表0到任意个字符) _ (一个字符) SELECT studentno,studentname FROM student WHERE studentname LIKE '刘%'; -- 查询姓刘的同学,后面只有一个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘_'; -- 查询姓刘的同学,后面只有两个字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '刘__'; -- 查询姓名中含有 嘉 字的 SELECT studentno,studentname FROM student WHERE studentname LIKE '%嘉%'; -- 查询姓名中含有特殊字符的需要使用转义符号 '\\' -- 自定义转义符关键字: ESCAPE ':' -- ============================================= -- IN -- ============================================= -- 查询学号为1000,1001,1002的学生姓名 SELECT studentno,studentname FROM student WHERE studentno IN (1000,1001,1002); -- 查询地址在北京,南京,河南洛阳的学生 SELECT studentno,studentname,address FROM student WHERE address IN ('北京','南京','河南洛阳'); -- ============================================= -- NULL 空 -- ============================================= -- 查询出生日期没有填写的同学 -- 不能直接写=NULL , 这是代表错误的 , 用 is null SELECT studentname FROM student WHERE BornDate IS NULL; -- 查询出生日期填写的同学 SELECT studentname FROM student WHERE BornDate IS NOT NULL; -- 查询没有写家庭住址的同学(空字符串不等于null) SELECT studentname FROM student WHERE Address='' OR Address IS NULL; ","date":"2021-07-04","objectID":"/mysql/:4:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.4、连接查询 JOIN对比 测试： /* 连接查询 如需要多张数据表的数据进行查询,则可通过连接运算符实现多个查询 内连接 inner join 查询两个表中的结果集中的交集 外连接 outer join 左外连接 left join (以左表作为基准,右边表来一一匹配,匹配不上的,返回左表的记录,右表以NULL填充) 右外连接 right join (以右表作为基准,左边表来一一匹配,匹配不上的,返回右表的记录,左表以NULL填充) 等值连接和非等值连接 自连接 */ -- 查询参加了考试的同学信息(学号,学生姓名,科目编号,分数) SELECT * FROM student; SELECT * FROM result; /*思路: (1):分析需求,确定查询的列来源于两个类,student result,连接查询 (2):确定使用哪种连接查询?(内连接) */ SELECT s.studentno,studentname,subjectno,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno -- 右连接(也可实现) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s RIGHT JOIN result r ON r.studentno = s.studentno -- 等值连接 SELECT s.studentno,studentname,subjectno,StudentResult FROM student s , result r WHERE r.studentno = s.studentno -- 左连接 (查询了所有同学,不考试的也会查出来) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno -- 查一下缺考的同学(左连接应用场景) SELECT s.studentno,studentname,subjectno,StudentResult FROM student s LEFT JOIN result r ON r.studentno = s.studentno WHERE StudentResult IS NULL -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno 自连接 /* 自连接 数据表与自身进行连接 需求:从一个包含栏目ID , 栏目名称和父栏目ID的表中 查询父栏目名称和其他子栏目名称 */ -- 创建一个表 CREATE TABLE `category` ( `categoryid` INT(10) UNSIGNED NOT NULL AUTO_INCREMENT COMMENT '主题id', `pid` INT(10) NOT NULL COMMENT '父id', `categoryName` VARCHAR(50) NOT NULL COMMENT '主题名字', PRIMARY KEY (`categoryid`) ) ENGINE=INNODB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8 -- 插入数据 INSERT INTO `category` (`categoryid`, `pid`, `categoryName`) VALUES('2','1','信息技术'),('3','1','软件开发'),('4','3','数据库'),('5','1','美术设计'),('6','3','web开发'),('7','5','ps技术'),('8','2','办公信息'); -- 编写SQL语句,将栏目的父子关系呈现出来 (父栏目名称,子栏目名称) -- 核心思想:把一张表看成两张一模一样的表,然后将这两张表连接查询(自连接) SELECT a.categoryName AS '父栏目',b.categoryName AS '子栏目' FROM category AS a,category AS b WHERE a.`categoryid`=b.`pid` -- 思考题:查询参加了考试的同学信息(学号,学生姓名,科目名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON sub.subjectno = r.subjectno -- 查询学员及所属的年级(学号,学生姓名,年级名) SELECT studentno AS 学号,studentname AS 学生姓名,gradename AS 年级名称 FROM student s INNER JOIN grade g ON s.`GradeId` = g.`GradeID` -- 查询科目及所属的年级(科目名称,年级名称) SELECT subjectname AS 科目名称,gradename AS 年级名称 FROM SUBJECT sub INNER JOIN grade g ON sub.gradeid = g.gradeid -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ","date":"2021-07-04","objectID":"/mysql/:4:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.5、排序和分页 测试： /*============== 排序 ================ 语法 : ORDER BY ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照ASC升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。 */ -- 查询 数据库结构-1 的所有考试结果(学号 学生姓名 科目名称 成绩) -- 按成绩降序排序 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC /*============== 分页 ================ 语法 : SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset 好处 : (用户体验,网络传输,查询压力) 推导: 第一页 : limit 0,5 第二页 : limit 5,5 第三页 : limit 10,5 ...... 第N页 : limit (pageNo-1)*pageSzie,pageSzie [pageNo:页码,pageSize:单页面显示条数] */ -- 每页显示5条数据 SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='数据库结构-1' ORDER BY StudentResult DESC , studentno LIMIT 0,5 -- 查询 JAVA第一学年 课程成绩前10名并且分数大于80的学生信息(学号,姓名,课程名,分数) SELECT s.studentno,studentname,subjectname,StudentResult FROM student s INNER JOIN result r ON r.studentno = s.studentno INNER JOIN `subject` sub ON r.subjectno = sub.subjectno WHERE subjectname='JAVA第一学年' ORDER BY StudentResult DESC LIMIT 0,10 ","date":"2021-07-04","objectID":"/mysql/:4:5","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"4.6、子查询 /*============== 子查询 ================ 什么是子查询? 在查询语句中的WHERE条件子句中,又嵌套了另一个查询语句 嵌套查询可由多个子查询组成,求解的方式是由里及外; 子查询返回的结果一般都是集合,故而建议使用IN关键字; */ -- 查询 数据库结构-1 的所有考试结果(学号,科目编号,成绩),并且成绩降序排列 -- 方法一:使用连接查询 SELECT studentno,r.subjectno,StudentResult FROM result r INNER JOIN `subject` sub ON r.`SubjectNo`=sub.`SubjectNo` WHERE subjectname = '数据库结构-1' ORDER BY studentresult DESC; -- 方法二:使用子查询(执行顺序:由里及外) SELECT studentno,subjectno,StudentResult FROM result WHERE subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '数据库结构-1') ORDER BY studentresult DESC; -- 查询课程为 高等数学-2 且分数不小于80分的学生的学号和姓名 -- 方法一:使用连接查询 SELECT s.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo` = r.`StudentNo` INNER JOIN `subject` sub ON sub.`SubjectNo` = r.`SubjectNo` WHERE subjectname = '高等数学-2' AND StudentResult\u003e=80 -- 方法二:使用连接查询+子查询 -- 分数不小于80分的学生的学号和姓名 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult\u003e=80 -- 在上面SQL基础上,添加需求:课程为 高等数学-2 SELECT r.studentno,studentname FROM student s INNER JOIN result r ON s.`StudentNo`=r.`StudentNo` WHERE StudentResult\u003e=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2') -- 方法三:使用子查询 -- 分步写简单sql语句,然后将其嵌套起来 SELECT studentno,studentname FROM student WHERE studentno IN( SELECT studentno FROM result WHERE StudentResult\u003e=80 AND subjectno=( SELECT subjectno FROM `subject` WHERE subjectname = '高等数学-2' ) ) /* 练习题目: 查 C语言-1 的前5名学生的成绩信息(学号,姓名,分数) 使用子查询,查询郭靖同学所在的年级名称 */ ","date":"2021-07-04","objectID":"/mysql/:4:6","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"5、MySQL函数 ","date":"2021-07-04","objectID":"/mysql/:5:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"5.1、常用函数 数据函数 SELECT ABS(-8); /*绝对值*/ SELECT CEILING(9.4); /*向上取整*/ SELECT FLOOR(9.4); /*向下取整*/ SELECT RAND(); /*随机数,返回一个0-1之间的随机数*/ SELECT SIGN(0); /*符号函数: 负数返回-1,正数返回1,0返回0*/ 字符串函数 SELECT CHAR_LENGTH('狂神说坚持就能成功'); /*返回字符串包含的字符数*/ SELECT CONCAT('我','爱','程序'); /*合并字符串,参数可以有多个*/ SELECT INSERT('我爱编程helloworld',1,2,'超级热爱'); /*替换字符串,从某个位置开始替换某个长度*/ SELECT LOWER('KuangShen'); /*小写*/ SELECT UPPER('KuangShen'); /*大写*/ SELECT LEFT('hello,world',5); /*从左边截取*/ SELECT RIGHT('hello,world',5); /*从右边截取*/ SELECT REPLACE('狂神说坚持就能成功','坚持','努力'); /*替换字符串*/ SELECT SUBSTR('狂神说坚持就能成功',4,6); /*截取字符串,开始和长度*/ SELECT REVERSE('狂神说坚持就能成功'); /*反转 -- 查询姓周的同学,改成邹 SELECT REPLACE(studentname,'周','邹') AS 新名字 FROM student WHERE studentname LIKE '周%'; 日期和时间函数 SELECT CURRENT_DATE(); /*获取当前日期*/ SELECT CURDATE(); /*获取当前日期*/ SELECT NOW(); /*获取当前日期和时间*/ SELECT LOCALTIME(); /*获取当前日期和时间*/ SELECT SYSDATE(); /*获取当前日期和时间*/ -- 获取年月日,时分秒 SELECT YEAR(NOW()); SELECT MONTH(NOW()); SELECT DAY(NOW()); SELECT HOUR(NOW()); SELECT MINUTE(NOW()); SELECT SECOND(NOW()); 系统信息函数 SELECT VERSION(); /*版本*/ SELECT USER(); /*用户*/ ","date":"2021-07-04","objectID":"/mysql/:5:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"5.2、聚合函数 -- 聚合函数 /*COUNT:非空的*/ SELECT COUNT(studentname) FROM student; SELECT COUNT(*) FROM student; SELECT COUNT(1) FROM student; /*推荐*/ -- 从含义上讲，count(1) 与 count(*) 都表示对全部数据行的查询。 -- count(字段) 会统计该字段在表中出现的次数，忽略字段为null 的情况。即不统计字段为null 的记录。 -- count(*) 包括了所有的列，相当于行数，在统计结果的时候，包含字段为null 的记录； -- count(1) 用1代表代码行，在统计结果的时候，包含字段为null 的记录 。 /* 很多人认为count(1)执行的效率会比count(*)高，原因是count(*)会存在全表扫描，而count(1) 可以针对一个字段进行查询。其实不然，count(1)和count(*)都会对全表进行扫描，统计所有记录的 条数，包括那些为null的记录，因此，它们的效率可以说是相差无几。而count(字段)则与前两者不 同，它会统计该字段不为null的记录条数。 下面它们之间的一些对比： 1）在表没有主键时，count(1)比count(*)快 2）有主键时，主键作为计算条件，count(主键)效率最高； 3）若表格只有一个字段，则count(*)效率较高。 */ SELECT SUM(StudentResult) AS 总和 FROM result; SELECT AVG(StudentResult) AS 平均分 FROM result; SELECT MAX(StudentResult) AS 最高分 FROM result; SELECT MIN(StudentResult) AS 最低分 FROM result; 题目： -- 查询不同课程的平均分,最高分,最低分 -- 前提:根据不同的课程进行分组 SELECT subjectname,AVG(studentresult) AS 平均分,MAX(StudentResult) AS 最高分,MIN(StudentResult) AS 最低分 FROM result AS r INNER JOIN `subject` AS s ON r.subjectno = s.subjectno GROUP BY r.subjectno HAVING 平均分\u003e80; /* where写在group by前面. 要是放在分组后面的筛选 要使用HAVING.. 因为having是从前面筛选的字段再筛选，而where是从数据表中的\u003e字段直接进行的筛选的 */ MD5加密 一、MD5简介 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一（又译摘要算法、哈希算法），主流编程语言普遍已有MD5实现。将数据（如汉字）运算为另一固定长度值，是杂凑算法的基础原理，MD5的前身有MD2、MD3和MD4。 二、实现数据加密 新建一个表testmd5 CREATE TABLE `testmd5` ( `id` INT(4) NOT NULL, `name` VARCHAR(20) NOT NULL, `pwd` VARCHAR(50) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 插入一些数据 INSERT INTO testmd5 VALUES(1,'kuangshen','123456'),(2,'qinjiang','456789') 如果我们要对pwd着一列数据进行加密，语法是： update testmd5 set pwd = md5(pwd); 如果单独对某个用户(如kuangshen)的密码加密： INSERT INTO testmd5 VALUES(3,'kuangshen2','123456') update testmd5 set pwd = md5(pwd) where name = 'kuangshen2'; 插入新的数据自动加密 INSERT INTO testmd5 VALUES(4,'kuangshen3',md5('123456')); 查询登录用户信息（md5对比使用，查看用户输入加密后的密码进行比对） SELECT * FROM testmd5 WHERE `name`='kuangshen' AND pwd=MD5('123456'); ","date":"2021-07-04","objectID":"/mysql/:5:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"5.3、小结 -- ================ 内置函数 ================ -- 数值函数 abs(x) -- 绝对值 abs(-10.9) = 10 format(x, d) -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46 ceil(x) -- 向上取整 ceil(10.1) = 11 floor(x) -- 向下取整 floor (10.1) = 10 round(x) -- 四舍五入去整 mod(m, n) -- m%n m mod n 求余 10%3=1 pi() -- 获得圆周率 pow(m, n) -- m^n sqrt(x) -- 算术平方根 rand() -- 随机数 truncate(x, d) -- 截取d位小数 -- 时间日期函数 now(), current_timestamp(); -- 当前日期时间 current_date(); -- 当前日期 current_time(); -- 当前时间 date('yyyy-mm-dd hh:ii:ss'); -- 获取日期部分 time('yyyy-mm-dd hh:ii:ss'); -- 获取时间部分 date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j'); -- 格式化时间 unix_timestamp(); -- 获得unix时间戳 from_unixtime(); -- 从时间戳获得时间 -- 字符串函数 length(string) -- string长度，字节 char_length(string) -- string的字符个数 substring(str, position [,length]) -- 从str的position开始,取length个字符 replace(str ,search_str ,replace_str) -- 在str中用replace_str替换search_str instr(string ,substring) -- 返回substring首次在string中出现的位置 concat(string [,...]) -- 连接字串 charset(str) -- 返回字串字符集 lcase(string) -- 转换成小写 left(string, length) -- 从string2中的左边起取length个字符 load_file(file_name) -- 从文件读取内容 locate(substring, string [,start_position]) -- 同instr,但可指定开始位置 lpad(string, length, pad) -- 重复用pad加在string开头,直到字串长度为length ltrim(string) -- 去除前端空格 repeat(string, count) -- 重复count次 rpad(string, length, pad) --在str后用pad补充,直到长度为length rtrim(string) -- 去除后端空格 strcmp(string1 ,string2) -- 逐字符比较两字串大小 -- 聚合函数 count() sum(); max(); min(); avg(); group_concat() -- 其他常用函数 md5(); default(); ","date":"2021-07-04","objectID":"/mysql/:5:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"6、事务 ","date":"2021-07-04","objectID":"/mysql/:6:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"6.1、概述 什么是事务 事务就是将一组SQL语句放在同一批次内去执行 如果一个SQL语句出错,则该批次内的所有SQL都将被取消执行 MySQL事务处理只支持InnoDB和BDB数据表类型 事务的ACID原则 百度ACID 原子性(Atomic) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执 行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过 一样。 一致性(Consist) 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务 一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五 个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多 个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之 间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 隔离性(Isolated) 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系 统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同 一时间仅有一个请求用于同一数据。 持久性(Durable) 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 ","date":"2021-07-04","objectID":"/mysql/:6:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"6.2、事务实现 基本语法： -- 使用set语句来改变自动提交模式 SET autocommit = 0; /*关闭*/ SET autocommit = 1; /*开启*/ -- 注意: --- 1.MySQL中默认是自动提交 --- 2.使用事务时应先关闭自动提交 -- 开始一个事务,标记事务的起始点 START TRANSACTION -- 提交一个事务给数据库 COMMIT -- 将事务回滚,数据回到本次事务的初始状态 ROLLBACK -- 还原MySQL数据库的自动提交 SET autocommit =1; -- 保存点 SAVEPOINT 保存点名称 -- 设置一个事务保存点 ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点 RELEASE SAVEPOINT 保存点名称 -- 删除保存点 事务处理步骤： ","date":"2021-07-04","objectID":"/mysql/:6:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"6.3、测试题目 /* 课堂测试题目 A在线买一款价格为500元商品,网上银行转账. A的银行卡余额为2000,然后给商家B支付500. 商家B一开始的银行卡余额为10000 创建数据库shop和创建表account并插入2条数据 */ CREATE DATABASE `shop`CHARACTER SET utf8 COLLATE utf8_general_ci; USE `shop`; CREATE TABLE `account` ( `id` INT(11) NOT NULL AUTO_INCREMENT, `name` VARCHAR(32) NOT NULL, `cash` DECIMAL(9,2) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO account (`name`,`cash`) VALUES('A',2000.00),('B',10000.00) -- 转账实现 SET autocommit = 0; -- 关闭自动提交 START TRANSACTION; -- 开始一个事务,标记事务的起始点 UPDATE account SET cash=cash-500 WHERE `name`='A'; UPDATE account SET cash=cash+500 WHERE `name`='B'; COMMIT; -- 提交事务 # rollback; SET autocommit = 1; -- 恢复自动提交 ","date":"2021-07-04","objectID":"/mysql/:6:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"7、索引 ","date":"2021-07-04","objectID":"/mysql/:7:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"7.1、索引分类 索引的作用 提高查询速度 确保数据唯一性 可以加速表和表之间的连接，实现表与表之间的参照完整性 使用分组和排序子句进行数据检索时，可以显著减少分组和排序的时间 全文检索字段进行搜索优化 在一个表中，主键索引只能有一个，唯一索引可以有多个 主键索引 唯一的标识，主键不可重复，只能有一个列作为主键 唯一索引 避免重复的列出现，唯一索引可以重复，多个列都可以标识为唯一索引 常规索引 默认的，可以使用index，key关键字来设置 全文索引 在特定的数据库引擎下才有，MyISAM 快速定位数据 只能用于CHAR，VARCHAR，TEXT数据列类型 基础语法： -- 索引的使用 -- 1、在创建表的时候给字段增加索引 -- 2、创建完毕后，增加索引 -- 显示所有的索引信息 SHOW INDEX FROM student -- 增加一个全文索引(索引名) 列名 ALTER TABLE school.student ADD FULLTEXT INDEX studentName(studentName); -- EXPLAIN 分析sql执行的状况 EXPLAIN SELECT * FROM student; --- 非全文索引 EXPLAIN SELECT * FROM student WHERE MATCH(studentName) AGAINST('刘'); 关于EXPLAIN ","date":"2021-07-04","objectID":"/mysql/:7:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"7.2、扩展：测试索引 建表app_user： CREATE TABLE `app_user` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `name` varchar(50) DEFAULT '' COMMENT '用户昵称', `email` varchar(50) NOT NULL COMMENT '用户邮箱', `phone` varchar(20) DEFAULT '' COMMENT '手机号', `gender` tinyint(4) unsigned DEFAULT '0' COMMENT '性别（0:男；1：女）', `password` varchar(100) NOT NULL COMMENT '密码', `age` tinyint(4) DEFAULT '0' COMMENT '年龄', `create_time` datetime DEFAULT CURRENT_TIMESTAMP, `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='app用户表' 批量插入数据：100w DROP FUNCTION IF EXISTS mock_data; DELIMITER $$ CREATE FUNCTION mock_data() RETURNS INT BEGIN DECLARE num INT DEFAULT 1000000; DECLARE i INT DEFAULT 0; WHILE i \u003c num DO INSERT INTO app_user(`name`, `email`, `phone`, `gender`, `password`,`age`) VALUES(CONCAT('用户', i), '24736743@qq.com', CONCAT('18', FLOOR(RAND()* (999999999-100000000)+100000000)),FLOOR(RAND()*2),UUID(), FLOOR(RAND()*100)); SET i = i + 1; END WHILE; RETURN i; END; SELECT mock_data(); # 创建一个索引 -- 格式：id_表名_字段名 CREATE INDEX 索引名 on 表(字段) CREATE INDEX id_user_app_name ON user_app(name); 索引效率测试 无索引 SELECT * FROM app_user WHERE name = '用户9999'; -- 查看耗时 SELECT * FROM app_user WHERE name = '用户9999'; SELECT * FROM app_user WHERE name = '用户9999'; mysql\u003e EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 992759 filtered: 10.00 Extra: Using where 1 row in set, 1 warning (0.00 sec) 创建索引 CREATE INDEX idx_app_user_name ON app_user(name); 测试普通索引 mysql\u003e EXPLAIN SELECT * FROM app_user WHERE name = '用户9999'\\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: app_user partitions: NULL type: ref possible_keys: idx_app_user_name key: idx_app_user_name key_len: 203 ref: const rows: 1 filtered: 100.00 Extra: NULL 1 row in set, 1 warning (0.00 sec) mysql\u003e SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql\u003e SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) mysql\u003e SELECT * FROM app_user WHERE name = '用户9999'; 1 row in set (0.00 sec) 索引在小数据量的时候，用户不大，但是在大数据的时候，区别十分明显 ","date":"2021-07-04","objectID":"/mysql/:7:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"7.3、索引原则 索引不是越多越好 不要对经常变动的数据加索引(因为又得重新查询) 小数据量的表不需要加索引 索引一般加载常用来查询的字段上！ ","date":"2021-07-04","objectID":"/mysql/:7:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"7.4、索引的数据结构 -- 我们可以在创建上述索引的时候，为其指定索引类型，分两类 hash类型的索引：查询单条快，范围查询慢 btree类型的索引：b+树，层数越多，数据量指数级增长（我们就用它，因为innodb默认支持它） -- 不同的存储引擎支持的索引类型也不一样 InnoDB 支持事务，支持行级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； MyISAM 不支持事务，支持表级别锁定，支持 B-tree、Full-text 等索引，不支持 Hash 索引； Memory 不支持事务，支持表级别锁定，支持 B-tree、Hash 等索引，不支持 Full-text 索引； NDB 支持事务，支持行级别锁定，支持 Hash 索引，不支持 B-tree、Full-text 等索引； Archive 不支持事务，支持表级别锁定，不支持 B-tree、Hash、Full-text 等索引； 关于索引的本质 ","date":"2021-07-04","objectID":"/mysql/:7:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"8、权限管理和备份 ","date":"2021-07-04","objectID":"/mysql/:8:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"8.1、用户管理 SQLyog可视化界面 SQL命令操作 用户表：mysql.user 本质：对这张表进行增删改查 -- 创建用户 CREATE USER 用户名 IDENTIFIED BY '密码' CREATE USER clover IDENTIFIED BY '1234566'; -- 修改密码(修改当前用户的密码) SET PASSWORD = PASSWORD('123456') -- 修改密码(修改指定用户的密码) SET PASSWORD FOR clover= PASSWORD('123456') -- 重命名 RENAME USER 原来名字 TO 新名字 RENAME USER clover TO cloverfelix -- 用户授权 ALL PRIVILEGES 全部的权限，库.表 -- ALL PRIVILEGES 除了给别人授权，其它都可以干 GRANT ALL PRIVILEGES ON *.* TO cloverfelix -- 查询权限 SHOW GRANTS FOR cloverfelix -- 查看指定用户的权限 SHOW GRANTS FOR root@localhost -- ROOT用户权限：GRANT ALL PRIVILEGES ON *.* TO 'root'@'localhost' WITH GRANT　OPTION -- 撤销权限 REVOKE 哪些权限 在哪个库撤销，给谁撤销 REVOKE ALL PRIVILEGES ON *.* FROM cloverfelix -- 删除用户 DROP USER cloverfelix 基本命令 /* 用户和权限管理 */ ------------------ 用户信息表：mysql.user -- 刷新权限 FLUSH PRIVILEGES -- 增加用户 CREATE USER kuangshen IDENTIFIED BY '123456' CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串) - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。 - 只能创建用户，不能赋予权限。 - 用户名，注意引号：如 'user_name'@'192.168.1.1' - 密码也需引号，纯数字密码也要加引号 - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD -- 重命名用户 RENAME USER kuangshen TO kuangshen2 RENAME USER old_user TO new_user -- 设置密码 SET PASSWORD = PASSWORD('密码') -- 为当前用户设置密码 SET PASSWORD FOR 用户名 = PASSWORD('密码') -- 为指定用户设置密码 -- 删除用户 DROP USER kuangshen2 DROP USER 用户名 -- 分配权限/添加用户 GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password'] - all privileges 表示所有权限 - *.* 表示所有库的所有表 - 库名.表名 表示某库下面的某表 -- 查看权限 SHOW GRANTS FOR root@localhost; SHOW GRANTS FOR 用户名 -- 查看当前用户权限 SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER(); -- 撤消权限 REVOKE 权限列表 ON 表名 FROM 用户名 REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名 -- 撤销所有权限 权限解释 -- 权限列表 ALL [PRIVILEGES] -- 设置除GRANT OPTION之外的所有简单权限 ALTER -- 允许使用ALTER TABLE ALTER ROUTINE -- 更改或取消已存储的子程序 CREATE -- 允许使用CREATE TABLE CREATE ROUTINE -- 创建已存储的子程序 CREATE TEMPORARY TABLES -- 允许使用CREATE TEMPORARY TABLE CREATE USER -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。 CREATE VIEW -- 允许使用CREATE VIEW DELETE -- 允许使用DELETE DROP -- 允许使用DROP TABLE EXECUTE -- 允许用户运行已存储的子程序 FILE -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE INDEX -- 允许使用CREATE INDEX和DROP INDEX INSERT -- 允许使用INSERT LOCK TABLES -- 允许对您拥有SELECT权限的表使用LOCK TABLES PROCESS -- 允许使用SHOW FULL PROCESSLIST REFERENCES -- 未被实施 RELOAD -- 允许使用FLUSH REPLICATION CLIENT -- 允许用户询问从属服务器或主服务器的地址 REPLICATION SLAVE -- 用于复制型从属服务器（从主服务器中读取二进制日志事件） SELECT -- 允许使用SELECT SHOW DATABASES -- 显示所有数据库 SHOW VIEW -- 允许使用SHOW CREATE VIEW SHUTDOWN -- 允许使用mysqladmin shutdown SUPER -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句， mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。 UPDATE -- 允许使用UPDATE USAGE -- “无权限”的同义词 GRANT OPTION -- 允许授予权限 /* 表维护 */ -- 分析和存储表的关键字分布 ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ... -- 检查一个或多个表是否有错误 CHECK TABLE tbl_name [, tbl_name] ... [option] ... option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED} -- 整理数据文件的碎片 OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... ","date":"2021-07-04","objectID":"/mysql/:8:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"8.2、数据库备份 使用命令行导出 mysqldump 命令行使用 # mysqldump -h 主机 -u 用户名 -p 密码 数据库 表 \u003e物理磁盘位置/文件名 mysqldump -hlocalhost -uroot -pxn123456 mybatis user \u003eH:/a.sql # mysqldump -h 主机 -u 用户名 -p 密码 数据库 表1 表2 表3 \u003e物理磁盘位置/文件名 mysqldump -hlocalhost -uroot -pxn123456 mybatis user1 user2 user3 \u003eH:/a.sql # mysqldump -h 主机 -u 用户名 -p 密码 数据库 \u003e物理磁盘位置/文件名 mysqldump -hlocalhost -uroot -pxn123456 mybatisr \u003eH:/a.sql # 导入 # 在登录的情况下，切换到指定的数据库 # source 备份文件 source H:/a.sql # 一步完成 mysql -u用户名 -p密码 库名\u003c 备份文件 如下图所示即可成功，需要进入mysql安装目录下的bin目录在使用cmd命令 如果在管理员模式下运行不成功说明你环境配置有问题，取环境变量中的path选项中加入MySQL安装目录下的bin所在位置即可 ","date":"2021-07-04","objectID":"/mysql/:8:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"9、规范化数据库 ","date":"2021-07-04","objectID":"/mysql/:9:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"9.1、为什么需要数据库设计 糟糕的数据库设计 数据冗余，存储空间浪费 数据更新和插入的异常 程序性能差 良好的数据库设计 节省数据的存储空间 能够保证数据的完整性 方便进行数据库应用系统的开发 软件项目开发周期中数据库设计 需求分析阶段：分析客户的业务和数据处理需求 概要设计阶段：设计数据库的E-R模型图，确认需求信息的正确和完整 设计数据库步骤 收集信息 与该系统有关人员进行交流、座谈，充分了解用户需求，理解数据库需要完成的任务 标识实体[Entity] 标识数据库要管理的关键对象或实体，实体一般是名词 标识每个实体需要存储的详细信息[Attribute] 标识实体之间的关系[Relationship] ","date":"2021-07-04","objectID":"/mysql/:9:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"9.2、三大范式 问题：为什么需要数据规范化 不合规范的表设计会导致的问题 信息重复 更新异常 插入异常 无法正确表示信息 删除异常 丢失有效信息 百度搜索：三大范式 第一范式(1st NF) 第一范式的目标是确保每列的原子性，如果每列都是不可再分的最小数据单元，则满足第一范式 第二范式(2st NF) 第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式 第二范式要求每个表只描述一件事情 第三范式(3st NF) 如果一个关系满足第二范式，并且非主键列都不传递依赖于主键列，则满足第三范式 第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关 规范化和性能的关系 为满足某种商业目标，数据库性能比规范化数据库更重要 在数据规范化的同时，要综合考虑数据库的性能 通过在给定的表中添加额外的字段，一减少需要从中搜索信息所需要的时间 通过在给的的表中插入计算列，以方便查询 ","date":"2021-07-04","objectID":"/mysql/:9:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10、JDBC ","date":"2021-07-04","objectID":"/mysql/:10:0","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.1、数据库驱动 我们的程序会通过数据库驱动和数据库打交道！！ ","date":"2021-07-04","objectID":"/mysql/:10:1","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.2、JDBC介绍 SUN公司为了简化开发人员的(对数据库的统一)操作，提供了一个(Java操作数据库的)规范，俗称JDBC 这些规范的实现由具体的厂商取做 对于开发人员来说，我们只需要掌握JDBC接口的操作即可 ","date":"2021-07-04","objectID":"/mysql/:10:2","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.3、编写JDBC程序 搭建实验环境 CREATE DATABASE jdbcStudy CHARACTER SET utf8 COLLATE utf8_general_ci; USE jdbcStudy; CREATE TABLE users( id INT PRIMARY KEY, NAME VARCHAR(40), PASSWORD VARCHAR(40), email VARCHAR(60), birthday DATE ); INSERT INTO users(id,NAME,PASSWORD,email,birthday) VALUES(1,'zhansan','123456','zs@sina.com','1980-12-04'), (2,'lisi','123456','lisi@sina.com','1981-12-04'), (3,'wangwu','123456','wangwu@sina.com','1979-12-04'); 新建一个Java工程，并导入数据驱动 编写程序从user表中读取数据，并打印在命令行窗口中 package com.kuang.lesson01; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.Statement; public class JdbcFirstDemo { public static void main(String[] args) throws Exception { //要连接的数据库URL String url = \"jdbc:mysql://localhost:3306/jdbcStudy? useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true\"; //连接的数据库时使用的用户名 String username = \"root\"; //连接的数据库时使用的密码 String password = \"123456\"; //1.加载驱动 //DriverManager.registerDriver(new com.mysql.jdbc.Driver());不推荐使用这种方式来加载驱动 Class.forName(\"com.mysql.jdbc.Driver\");//推荐使用这种方式来加载驱动 //2.获取与数据库的链接 conn 代表数据库 Connection conn = DriverManager.getConnection(url, username,password); //3.获取用于向数据库发送sql语句的statement Statement st = conn.createStatement(); String sql = \"select id,name,password,email,birthday from users\"; //4.向数据库发sql,并获取代表结果集的resultset ResultSet rs = st.executeQuery(sql); //5.取出结果集的数据 while(rs.next()){ System.out.println(\"id=\" + rs.getObject(\"id\")); System.out.println(\"name=\" + rs.getObject(\"name\")); System.out.println(\"password=\" + rs.getObject(\"password\")); System.out.println(\"email=\" + rs.getObject(\"email\")); System.out.println(\"birthday=\" + rs.getObject(\"birthday\")); } //6.关闭链接，释放资源 rs.close(); st.close(); conn.close(); } } 步骤总结： 1、加载驱动 2、连接数据库DriverManager 3、获得执行sql的对象Statement 4、获得返回的结果集 5、释放连接 ","date":"2021-07-04","objectID":"/mysql/:10:3","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.4、对象说明 DriverManager类讲解 Jdbc程序中的DriverManager用于加载驱动，并创建与数据库的连接，这个API常用方法 DriverManager.registerDriver(new Driver()); DriverManager.getConnection(url, user, password); 注意：在实际开发中并不推荐采用registerDriver方法注册驱动。原因有二： 查看Driver的源代码可以看到，如果采用此种方式，会导致驱动程序注册两次，也就是在内存中会有两个Driver对象 程序依赖MySQL的api，脱离MySQL的jar包，程序将无法编译，将来程序切换底层数据库将会非常麻烦 推荐方式：Class.forName(“com.mysql.jdbc.Driver”); 采用此种方式不会导致驱动对象在内存中重复出现，并且采用此种方式，程序仅仅只需要一个字符串，不需要依赖具体的驱动，使程序的灵活性更高 数据库URL URL用于标识数据库的位置，通过URL地址告诉JDBC程序连接哪个数据库，URL的写法为： 常用数据库URL地址的写法： Oracle写法：jdbc:oracle:thin:@localhost:1521:sid SqlServer写法:jdbc:microsoft:sqlserver://localhost:1433;DatabaseName=sid Mysqlxi写法：jdbc:mysql://localhost:3306/sid 如果连接的使本地的MySQL数据库，并且连接使用的端口使3306，那么url地址可以简写为jdbc:mysql:///数据库 Connection类 Jdbc程序中的Connection，它用于代表数据库的链接，Collection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法： createStatement()：创建向数据库发送sql的statement对象。 prepareStatement(sql) ：创建向数据库发送预编译sql的PrepareSatement对象。 setAutoCommit(boolean autoCommit)：设置事务是否自动提交。 commit() ：在链接上提交事务。 rollback() ：在此链接上回滚事务。 Statement类 Jdbc程序中的Statement对象用于向数据库发送SQL语句， Statement对象常用方法： executeQuery(String sql) ：用于向数据发送查询语句。 executeUpdate(String sql)：用于向数据库发送insert、update或delete语句 execute(String sql)：用于向数据库发送任意sql语句 addBatch(String sql) ：把多条sql语句放到一个批处理中。 executeBatch()：向数据库发送一批sql语句执行。 ResultSet类 Jdbc程序中的ResultSet用于代表Sql语句的执行结果。Resultset封装执行结果时，采用的类似于表格的 方式。ResultSet 对象维护了一个指向表格数据行的游标，初始的时候，游标在第一行之前，调用ResultSet.next() 方法，可以使游标指向具体的数据行，进行调用方法获取该行的数据。 ResultSet既然用于封装执行结果的，所以该对象提供的都是用于获取数据的get方法： 获取任意类型的数据 getObject(int index) getObject(string columnName) 获取指定类型的数据，例如： getString(int index) getString(String columnName) ResultSet还提供了对结果集进行滚动的方法： next()：移动到下一行 Previous()：移动到前一行 absolute(int row)：移动到指定行 beforeFirst()：移动resultSet的最前面。 afterLast() ：移动到resultSet的最后面。 释放资源 Jdbc程序运行完后，切记要释放程序在运行过程中，创建的那些与数据库进行交互的对象，这些对象通常是ResultSet, Statement和Connection对象，特别是Connection对象，它是非常稀有的资源，用完后必须马上释放，如果Connection不能及时、正确的关闭，极易导致系统宕机。Connection的使用原则是尽量晚创建，尽量早的释放。 为确保资源释放代码能运行，资源释放代码也一定要放在finally语句中。 ","date":"2021-07-04","objectID":"/mysql/:10:4","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.5、statement对象 Jdbc中的statement对象用于向数据库发送SQL语句，想完成对数据库的增删改查，只需要通过这个对象向数据库发送增删改查语句即可。 Statement对象的executeUpdate方法，用于向数据库发送增、删、改的sql语句，executeUpdate执行完后，将会返回一个整数（即增删改语句导致了数据库几行数据发生了变化）。 Statement.executeQuery方法用于向数据库发送查询语句，executeQuery方法返回代表查询结果的 ResultSet对象。 CRUD操作-create 使用executeUpdate(String sql)方法完成数据添加操作，示例操作： Statement st = conn.createStatement(); String sql = \"insert into user(….) values(…..) \"; int num = st.executeUpdate(sql); if(num\u003e0){ System.out.println(\"插入成功！！！\"); } CRUD操作-update 使用executeUpdate(String sql)方法完成数据修改操作，示例操作： Statement st = conn.createStatement(); String sql = \"update user set name='' where name=''\"; int num = st.executeUpdate(sql); if(num\u003e0){ System.out.println(“修改成功！！！\"); } CRUD操作-read 使用executeQuery(String sql)方法完成数据查询操作，示例操作： Statement st = conn.createStatement(); String sql = \"select * from user where id=1\"; ResultSet rs = st.executeUpdate(sql); while(rs.next()){ //根据获取列的数据类型，分别调用rs的相应方法映射到java对象中 } 使用jdbc对数据库增删改查 新建一个lesson02的包 在src目录下创建一个个db.properties文件，如下图所示： driver=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/jdbcStudy?useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true username=root password=xn123456 在lesson02 下新建一个 utils 包，新建一个类 JdbcUtils package com.kuang.lesson02.utils; import java.io.InputStream; import java.sql.Connection; import java.sql.DriverManager; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; public class JdbcUtils { private static String driver = null; private static String url = null; private static String username = null; private static String password = null; static{ try{ //读取db.properties文件中的数据库连接信息 InputStream in =JdbcUtils.class.getClassLoader().getResourceAsStream(\"db.properties\"); Properties prop = new Properties(); prop.load(in); //获取数据库连接驱动 driver = prop.getProperty(\"driver\"); //获取数据库连接URL地址 url = prop.getProperty(\"url\"); //获取数据库连接用户名 username = prop.getProperty(\"username\"); //获取数据库连接密码 password = prop.getProperty(\"password\"); //加载数据库驱动 Class.forName(driver); }catch (Exception e) { throw new ExceptionInInitializerError(e); } } // 获取数据库连接对象 public static Connection getConnection() throws SQLException{ return DriverManager.getConnection(url, username,password); } // 释放资源，要释放的资源包括Connection数据库连接对象，负责执行SQL命令的Statement对象，存储查询结果的ResultSet对象 public static void release(Connection conn,Statement st,ResultSet rs){ if(rs!=null){ try{ //关闭存储查询结果的ResultSet对象 rs.close(); }catch (Exception e) { e.printStackTrace(); } rs = null; } if(st!=null){ try{ //关闭负责执行SQL命令的Statement对象 st.close(); }catch (Exception e) { e.printStackTrace(); } } if(conn!=null){ try{ //关闭Connection数据库连接对象 conn.close(); }catch (Exception e) { e.printStackTrace(); } } } } 使用statement对象完成对数据库的CRUD操作 1、插入一条数据 package com.kuang.lesson02; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; public class TestInsert { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try{ //获取一个数据库连接 conn = JdbcUtils.getConnection(); //通过conn对象获取负责执行SQL命令的Statement对象 st = conn.createStatement(); //要执行的SQL命令 String sql = \"insert into users(id,name,password,email,birthday)\" + \"values(4,'kuangshen','123','24736743@qq.com','2020-01-01')\"; //执行插入操作，executeUpdate方法返回成功的条数 int num = st.executeUpdate(sql); if(num\u003e0){ System.out.println(\"插入成功！！\"); } }catch (Exception e) { e.printStackTrace(); }finally{ //SQL执行完成之后释放相关资源 JdbcUtils.release(conn, st, rs); } } } 2、删除一条数据 package com.kuang.lesson02; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.ResultSet; import java.sql.Statement; public class TestDelete { public static void main(String[] args) { Connection conn = null; Statement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); String sql = \"delete from users where id=4\"; st = conn.createStatement(); int num = st.executeUpdate(sql); if(num\u003e0){ System.out.println(\"删除成功！！\"); } }catch (Except","date":"2021-07-04","objectID":"/mysql/:10:5","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.6、PreparedStatement对象 PreperedStatement是Statement的子类，它的实例对象可以通过调用Connection.preparedStatement()方法获得，相对于Statement对象而言：PreperedStatement可以避 免SQL注入的问题。 Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。 PreparedStatement可对SQL进行预编译，从而提高数据库的执行效率。并且PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。 使用PreparedStatement对象完成对数据库的CRUD操作 1、插入数据 package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.util.Date; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestInsert { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ //获取一个数据库连接 conn = JdbcUtils.getConnection(); //要执行的SQL命令，SQL中的参数使用?作为占位符 String sql = \"insert into users(id,name,password,email,birthday) values(?,?,?,?,?)\"; //通过conn对象获取负责执行SQL命令的prepareStatement对象 st = conn.prepareStatement(sql); //为SQL语句中的参数赋值，注意，索引是从1开始的 st.setInt(1, 4);//id是int类型的 st.setString(2, \"kuangshen\");//name是varchar(字符串类型) st.setString(3, \"123\");//password是varchar(字符串类型) st.setString(4, \"24736743@qq.com\");//email是varchar(字符串类型) st.setDate(5, new java.sql.Date(new Date().getTime()));//birthday是date类型 //执行插入操作，executeUpdate方法返回成功的条数 int num = st.executeUpdate(); if(num\u003e0){ System.out.println(\"插入成功！！\"); } }catch (Exception e) { e.printStackTrace(); }finally{ //SQL执行完成之后释放相关资源 JdbcUtils.release(conn, st, rs); } } } 2、删除一条数据 package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestDelete { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); String sql = \"delete from users where id=?\"; st = conn.prepareStatement(sql); st.setInt(1, 4); int num = st.executeUpdate(); if(num\u003e0){ System.out.println(\"删除成功！！\"); } }catch (Exception e) { e.printStackTrace(); }finally{ JdbcUtils.release(conn, st, rs); } } } 3、更新一条数据 package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestUpdate { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); String sql = \"update users set name=?,email=? where id=?\"; st = conn.prepareStatement(sql); st.setString(1, \"kuangshen\"); st.setString(2, \"24736743@qq.com\"); st.setInt(3, 2); int num = st.executeUpdate(); if(num\u003e0){ System.out.println(\"更新成功！！\"); } }catch (Exception e) { e.printStackTrace(); }finally{ JdbcUtils.release(conn, st, rs); } } } 4、查询一条数据 package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; public class TestSelect { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); String sql = \"select * from users where id=?\"; st = conn.prepareStatement(sql); st.setInt(1, 1); rs = st.executeQuery(); if(rs.next()){ System.out.println(rs.getString(\"name\")); } }catch (Exception e) { }finally{ JdbcUtils.release(conn, st, rs); } } } 避免SQL注入 package com.kuang.lesson03; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.Statement; public class SQL注入 { public static void main(String[] args) { // login(\"zhangsan\",\"123456\"); // 正常登陆 login(\"'or '1=1\",\"123456\"); // SQL 注入 } public static void login(String username,String password){ Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); // 假设其中存在转义字符，就直接忽略，比如说 ' 会被直接转义 // select * from users where name='' or '1=1' and password ='123456' String sql = \"select * from users where name=? and password=?\"; st = conn.prepareStatement(sq","date":"2021-07-04","objectID":"/mysql/:10:6","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.7、事务 概念 事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，要不全部不成功 ACID原则 原子性 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执 行过程中发生错误，会被回滚（ROLLBACK）到事务开始前的状态，就像这个事务从来没有执行过一样 一致性 一个事务可以封装状态改变（除非它是一个只读的）。事务必须始终保持系统处于一致的状态，不 管在任何给定的时间并发事务有多少。也就是说：如果事务是并发多个，系统也必须如同串行事务 一样操作。其主要特征是保护性和不变性(Preserving an Invariant)，以转账案例为例，假设有五 个账户，每个账户余额是100元，那么五个账户总额是500元，如果在这个5个账户之间同时发生多 个转账，无论并发多少个，比如在A与B账户之间转账5元，在C与D账户之间转账10元，在B与E之 间转账15元，五个账户总额也应该还是500元，这就是保护性和不变性。 隔离性 隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相 同的时间内，执行相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系 统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请求，使得在同 一时间仅有一个请求用于同一数据。 持久性 在事务完成以后，该事务对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 隔离性问题 脏读：脏读指一个事务读取了另外一个事务未提交的数据 不可重复读：不可重复读指在一个事务内读取表中的某一行数据，多次读取结构不同 虚读(幻读)：虚读(幻读)是指在一个事务内读到了别的事务插入的数据，导致前后读取不一致 代码测试 /*创建账户表*/ CREATE TABLE account( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(40), money FLOAT ); /*插入测试数据*/ insert into account(name,money) values('A',1000); insert into account(name,money) values('B',1000); insert into account(name,money) values('C',1000); 当Jdbc程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交在它上面发送的SQL语句。若想关闭这种默认提交方式，让多条SQL在一个事务中执行，可使用下列的JDBC控制事务语句 Connection.setAutoCommit(false);//开启事务(start transaction) Connection.rollback();//回滚事务(rollback) Connection.commit();//提交事务(commit) 程序编写 1、模拟转账成功时的业务场景 package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; //模拟转账成功时的业务场景 public class TestTransaction1 { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); conn.setAutoCommit(false);//通知数据库开启事务(start transaction) String sql1 = \"update account set money=money-100 where name='A'\"; st = conn.prepareStatement(sql1); st.executeUpdate(); String sql2 = \"update account set money=money+100 where name='B'\"; st = conn.prepareStatement(sql2); st.executeUpdate(); conn.commit();//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit) System.out.println(\"成功！！！\"); //log4j }catch (Exception e) { e.printStackTrace(); }finally{ JdbcUtils.release(conn, st, rs); } } } 2、模拟转账过程中出现异常导致有一部分SQL执行失败后让数据库自动回滚事务 package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; // 模拟转账过程中出现异常导致有一部分SQL执行失败后让数据库自动回滚事务 public class TestTransaction2 { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); conn.setAutoCommit(false);//通知数据库开启事务(start transaction) String sql1 = \"update account set money=money-100 where name='A'\"; st = conn.prepareStatement(sql1); st.executeUpdate(); //用这句代码模拟执行完SQL1之后程序出现了异常而导致后面的SQL无法正常执行，事务也无法正常提交，此时数据库会自动执行回滚操作 int x = 1/0; String sql2 = \"update account set money=money+100 where name='B'\"; st = conn.prepareStatement(sql2); st.executeUpdate(); conn.commit();//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit) System.out.println(\"成功！！！\"); }catch (Exception e) { e.printStackTrace(); }finally{ JdbcUtils.release(conn, st, rs); } } } 3、模拟转账过程中出现异常导致有一部分SQL执行失败时手动通知数据库回滚事务 package com.kuang.lesson04; import com.kuang.lesson02.utils.JdbcUtils; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; //模拟转账过程中出现异常导致有一部分SQL执行失败时手动通知数据库回滚事务 public class TestTransaction3 { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ conn = JdbcUtils.getConnection(); conn.setAutoCommit(false);//通知数据库开启事务(start transaction) String sql1 = \"update account set money=money-100 where name='A'\"; st = conn.prepareStatement(sql1); st.executeUpdate(); //用这句代码模拟执行完SQL1之后程序出现了异常而导致后面的SQL无法正常执行，事务也无法正常提交 int x = 1/0; String sql2 = \"update account set money=money+100 where name='B'\"; st = conn.prepareStatement(sql2); st.executeUpdate(); conn.commit();//上面的两条SQL执行Update语句成功之后就通知数据库提交事务(commit) System.out.println(\"","date":"2021-07-04","objectID":"/mysql/:10:7","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mysql"],"content":"10.8、数据库连接池 用户每次请求都需要向数据库获得链接，而数据库创建连接通常需要消耗相对较大的资源，创建时间也 较长。假设网站一天10万访问量，数据库服务器就需要创建10万次连接，极大的浪费数据库的资源，并 且极易造成数据库服务器内存溢出、拓机。 数据库连接池的基本概念 数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的 数据库连接,而不是重新建立一个。 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中, 这些数据库连接的数量是由最小数据库连接数来设定的.无论这些数据库连接是否被使用,连接池都将一直保证至少拥有这么多的连接数量. 连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数,当应用程序向连接池请求的连接数超过最大连接数量时,这些请求将被加入到等待队列中 数据库连接池的最小连接数和最大连接数的设置要考虑到以下几个因素: 最小连接数:是连接池一直保持的数据库连接,所以如果应用程序对数据库连接的使用量不大,将会有 大量的数据库连接资源被浪费. 最大连接数:是连接池能申请的最大连接数,如果数据库连接请求超过次数,后面的数据库连接请求将 被加入到等待队列中,这会影响以后的数据库操作 如果最小连接数与最大连接数相差很大:那么最先连接请求将会获利,之后超过最小连接数量的连接 请求等价于建立一个新的数据库连接.不过,这些大于最小连接数的数据库连接在使用完不会马上被 释放,他将被放到连接池中等待重复使用或是空间超时后被释放. 编写连接池需实现java.sql.DataSource接口。 开源数据库连接池 现在很多WEB服务器(Weblogic, WebSphere, Tomcat)都提供了DataSoruce的实现，即连接池的实现。 通常我们把DataSource的实现，按其英文含义称之为数据源，数据源中都包含了数据库连接池的实 现。 也有一些开源组织提供了数据源的独立实现： DBCP数据库连接池 C3P0数据库连接池 在使用了数据库连接池之后，在项目的实际开发中就不需要编写连接数据库的代码了，直接从数据源获得数据库的连接 DBCP数据源 DBCP 是 Apache 软件基金组织下的开源连接池实现，要使用DBCP数据源，需要应用程序应在系统中增加如下两个 jar 文件： Commons-dbcp.jar：连接池的实现 Commons-pool.jar：连接池实现的依赖库 Tomcat 的连接池正是采用该连接池来实现的。该数据库连接池既可以与应用服务器整合使用，也可由 应用程序独立使用。 测试： 导入相关jar包 在类目录下加入dbcp的配置文件：dbcpconfig.properties #连接设置 driverClassName=com.mysql.jdbc.Driver url=jdbc:mysql://localhost:3306/jdbcStudy? useUnicode=true\u0026characterEncoding=utf8\u0026useSSL=true username=root password=123456 #\u003c!-- 初始化连接 --\u003e initialSize=10 #最大连接数量 maxActive=50 #\u003c!-- 最大空闲连接 --\u003e maxIdle=20 #\u003c!-- 最小空闲连接 --\u003e minIdle=5 #\u003c!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --\u003e maxWait=60000 #JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] #注意：\"user\" 与 \"password\" 两个属性会被明确地传递，因此这里不需要包含他们。 connectionProperties=useUnicode=true;characterEncoding=UTF8 #指定由连接池所创建的连接的自动提交（auto-commit）状态。 defaultAutoCommit=true #driver default 指定由连接池所创建的连接的只读（read-only）状态。 #如果没有设置该值，则“setReadOnly”方法将不被调用。（某些驱动并不支持只读模式，如：Informix） defaultReadOnly= #driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。 #可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED,REPEATABLE_READ, SERIALIZABLE defaultTransactionIsolation=READ_UNCOMMITTED 3、编写工具类 JdbcUtils_DBCP package com.kuang.datasource.utils; import java.io.InputStream; import java.sql.Connection; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Properties; import javax.sql.DataSource; import org.apache.commons.dbcp.BasicDataSourceFactory; //数据库连接工具类 public class JdbcUtils_DBCP { /** * 在java中，编写数据库连接池需实现java.sql.DataSource接口，每一种数据库连接池都 是DataSource接口的实现 * DBCP连接池就是java.sql.DataSource接口的一个具体实现 */ private static DataSource ds = null; //在静态代码块中创建数据库连接池 static{ try{ //加载dbcpconfig.properties配置文件 InputStream in =JdbcUtils_DBCP.class.getClassLoader().getResourceAsStream(\"dbcpconfig.properties\"); Properties prop = new Properties(); prop.load(in); //创建数据源 ds = BasicDataSourceFactory.createDataSource(prop); }catch (Exception e) { throw new ExceptionInInitializerError(e); } } //从数据源中获取数据库连接 public static Connection getConnection() throws SQLException{ //从数据源中获取数据库连接 return ds.getConnection(); } // 释放资源 public static void release(Connection conn,Statement st,ResultSet rs){ if(rs!=null){ try{ //关闭存储查询结果的ResultSet对象 rs.close(); }catch (Exception e) { e.printStackTrace(); } rs = null; } if(st!=null){ try{ //关闭负责执行SQL命令的Statement对象 st.close(); }catch (Exception e) { e.printStackTrace(); } } if(conn!=null){ try{ //将Connection连接对象还给数据库连接池 conn.close(); }catch (Exception e) { e.printStackTrace(); } } } } 测试类 package com.kuang.datasource; import com.kuang.datasource.utils.JdbcUtils_DBCP; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.util.Date; public class DBCPTest { public static void main(String[] args) { Connection conn = null; PreparedStatement st = null; ResultSet rs = null; try{ //获取数据库连接 conn = JdbcUtils_DBCP.getConnection(); String sql = \"insert into users(id,name,password,email,birthday) values(?,?,?,?,?)\"; st = conn.prepareStatement(sql); st.setInt(1, 5);//id是int类型的 st.setString(2, \"kuangshen\");//name是varchar(字符串类型) st.setString(3, \"123\");//password是varchar(字","date":"2021-07-04","objectID":"/mysql/:10:8","tags":["Mysql"],"title":"Mysql","uri":"/mysql/"},{"categories":["Mybatis"],"content":"mybatis","date":"2021-07-04","objectID":"/mybatis/","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1、简介 ","date":"2021-07-04","objectID":"/mybatis/:1:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.1、什么是Mybatis ","date":"2021-07-04","objectID":"/mybatis/:1:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.2、持久化（持久化是一个动作） 数据持久化 持久化就是将程序的数据在持久状态和瞬时状态转化的过程 内存：断电即失 数据库（jdbc），io文件持久化。 为什么需要持久化有一些对象，不能让他丢掉。用时再取 对象：如支付宝里面的钱不能丢失以及页面的一些信息 因为内存有一个特点是断电即失 另外一个原因也是内存太贵（外在原因） ","date":"2021-07-04","objectID":"/mybatis/:1:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.3、持久层（是一个概念） Dao层，Service层，Controller层…等每一个层都有它们自己要做的事情 完成持久化工作的代码块 层是界限十分明显 ","date":"2021-07-04","objectID":"/mybatis/:1:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"1.4、为什么需要Mybatis 帮助程序员将数据存入到数据库中 方便 传统的JDBC代码太复杂了。所以将其简化，出现一个框架 不用Mybatis也可以。更容易上手。 ","date":"2021-07-04","objectID":"/mybatis/:1:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2、第一个Mybatis程序 思路：搭建环境–\u003e导入Mybatis–\u003e编写代码–\u003e测试！ ","date":"2021-07-04","objectID":"/mybatis/:2:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.1、搭建环境 CREATE DATABASE `mybatis`; USE `mybatis`; CREATE TABLE `user`( `id` INT(20) NOT NULL PRIMARY KEY, # 设置id，并设为主键且不为空 `name` VARCHAR(30) DEFAULT NULL, # 设置名字，默认为空 `pwd` VARCHAR(30) DEFAULT NULL )ENGINE=INNODB DEFAULT CHARSET=utf8; # 设置引擎为INNODB 默认字符集为utf8 INSERT INTO `user`(`id`,`name`,`pwd`) VALUES (1,'科比','123456'), (2,'哈登','123456'), (3,'威少','123456') 新建项目 1.新建一个普通的maven项目 2.删除src目录 3.导入maven依赖 \u003cdependencies\u003e \u003c!--mysql驱动--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis\u003c/groupId\u003e \u003cartifactId\u003emybatis\u003c/artifactId\u003e \u003cversion\u003e3.5.2\u003c/version\u003e \u003c/dependency\u003e \u003c!--mybatis--\u003e \u003cdependency\u003e \u003cgroupId\u003emysql\u003c/groupId\u003e \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e \u003cversion\u003e5.1.47\u003c/version\u003e \u003c/dependency\u003e \u003c!--junit--\u003e \u003cdependency\u003e \u003cgroupId\u003ejunit\u003c/groupId\u003e \u003cartifactId\u003ejunit\u003c/artifactId\u003e \u003cversion\u003e4.12\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e ","date":"2021-07-04","objectID":"/mybatis/:2:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.2、创建一个模块 编写mybatis的核心配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"com.mysql.jdbc.Driver\"/\u003e \u003cproperty name=\"url\" value=\"jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026amp;userUnicode=true\u0026amp;characterEncoding=UTF-8\"/\u003e \u003c!--此处的\u0026amp;相当于yml里面的\u0026\u0026,只是在xml文件中得进行转化--\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003c/configuration\u003e 编写mybatis工具类 package com.kuang.utils; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import java.io.IOException; import java.io.InputStream; public class MybatisUtils { //提升作用域 private static SqlSessionFactory sqlSessionFactory; static { try { //使用Mybatis第一步 获取sqlSessionFactory对象 String resource = \"mybatis-config.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); } catch (IOException e) { e.printStackTrace(); } } //既然有了 SqlSessionFactory，顾名思义，我们可以从中获得 SqlSession 的实例。 // SqlSession 提供了在数据库执行 SQL 命令所需的所有方法。 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } } ","date":"2021-07-04","objectID":"/mybatis/:2:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.3、编写代码 实体类 package com.kuang.pojo; //实体类 public class User { private int id; private String name; private String pwd; public User() { } public User(int id, String name, String pwd) { this.id = id; this.name = name; this.pwd = pwd; } public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getPwd() { return pwd; } public void setPwd(String pwd) { this.pwd = pwd; } @Override public String toString() { return \"User{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", pwd='\" + pwd + '\\'' + '}'; } } Dao接口 public interface UserDao { List\u003cUser\u003e getUserList(); } 接口实现类（由原来的Use人DaoImpl转变为一个Mapper配置文件） \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003c!--namespace等于绑定一个对于的Dao/Mapper接口--\u003e \u003cmapper namespace=\"com.kuang.dao.UserDao\"\u003e \u003c!--select查询语句 id对应的是我们的方法名字--\u003e \u003cselect id=\"getUserList\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user \u003c/select\u003e \u003c/mapper\u003e 注意点：在使用resultType返回结果时，返回集合中的泛型，不要写集合 ","date":"2021-07-04","objectID":"/mybatis/:2:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"2.4、测试 注意点：org.apache.ibatis.binding.BindingException: Type interface com.kuang.dao.UserDao is not known to the MapperRegistry. MapperRegistry是什么？ 核心配置文件中注册mappers \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e junit测试 package com.kuang.dao; import com.kuang.pojo.User; import com.kuang.utils.MybatisUtils; import org.apache.ibatis.session.SqlSession; import org.junit.Test; import java.util.List; public class UserDaoTest { @Test public void test(){ //第一步：活得SqlSession对象 SqlSession sqlSession = MybatisUtils.getSqlSession(); //方式一：getMapper UserDao userDao = sqlSession.getMapper(UserDao.class); List\u003cUser\u003e userList = userDao.getUserList(); for (User user : userList) { System.out.println(user); } //关闭sqlsession sqlSession.close(); } } 官网推荐的是我们将close放入finally中，自己手动添加一个try-catch语句 可能遇到的问题： 配置文件没有注册 绑定接口错误 namespace绑定问题 方法名不对 返回类型不对 resulttype返回类型 Maven导出资源问题 思路： 导入最基本需要的依赖包 创建一个工具类，构建SqlSessionFactory 编写核心配置文件 连接数据库，修改里面的属性 写完实体类后写接口，最后写实体类，用mapper.xml代替了原来的Impl 每次收到的HTTP请求（也就是连接我们的数据库），就可以打开一个SqlSession，返回一个响应，就关闭它。 ","date":"2021-07-04","objectID":"/mybatis/:2:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3、CRUD ","date":"2021-07-04","objectID":"/mybatis/:3:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.1、namespace namespace中的包名要和Dao/mapper接口的包名一致！ ","date":"2021-07-04","objectID":"/mybatis/:3:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.2、select 选择，查询语句 id：就是对应的namespace中的方法名 resultType：SQL语句执行的返回值 parameterType：参数类型！ 1.编写接口 //根据ID查询用户 User getUserById(int id); 2.编写对应的mapper中的sql语句 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select * from mybatis.user where id = #{id} \u003c/select\u003e 3.测试 public void getUserById(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); //关闭sqlsession sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:3:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.3、Insert \u003c!--对象中的属性可以直接提取出来--\u003e \u003cinsert id=\"addUser\" parameterType=\"com.kuang.pojo.User\"\u003e insert into mybatis.user (id,name,pwd) values (#{id},#{name},#{pwd}) \u003c/insert\u003e ","date":"2021-07-04","objectID":"/mybatis/:3:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.4、Update \u003cupdate id=\"updateUser\" parameterType=\"com.kuang.pojo.User\"\u003e update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}; \u003c/update\u003e ","date":"2021-07-04","objectID":"/mybatis/:3:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.5、delete \u003cdelete id=\"deleteUser\" parameterType=\"int\"\u003e delete from mybatis.user where id=#{id}; \u003c/delete\u003e 注意点： 增删改需要提交事务，否则添加不进去（代码执行没问题，数据库里面不显示） resource绑定mapper，需要使用路径 ","date":"2021-07-04","objectID":"/mybatis/:3:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.6、万能Map 假设，我们的实体类，或者数据库中的表，字段或者参数过多，我们应当考虑使用Map！ Map传递参数，直接在sql中取出即可！【parameterType=“Map”】 对象传递参数，直接在sql中取对象的属性即可！【parameterType=“Object”】 只有一个基本类型参数的情况下，可以直接在sql中取到！ 多个参数用Map，或者注解！ ","date":"2021-07-04","objectID":"/mybatis/:3:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"3.7、思考题 模糊查询 ​ 1.Java代码执行的时候，传递通配符% % List\u003cUser\u003e userList = mapper.getUserLike(\"%李%\"); ​ 2.在sql拼接中使用通配符！ select * from mybatis.user where name like \"%\"#{value}\"%\" ","date":"2021-07-04","objectID":"/mybatis/:3:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4、配置解析 ","date":"2021-07-04","objectID":"/mybatis/:4:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.1、核心配置文件 mybatis-config.xml MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 configuration（配置） properties（属性） settings（设置） typeAliases（类型别名） typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments（环境配置） environment（环境变量） transactionManager（事务管理器） dataSource（数据源） databaseIdProvider（数据库厂商标识） mappers（映射器） ","date":"2021-07-04","objectID":"/mybatis/:4:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.2、环境配置（environment） Mybatis可以配置成适应多种环境 不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。 transactionManager：事务管理器，分为JDBC与MANAGED dataSource：数据源，分为UNPOOLED、POOLED、JNDI；最重要的概念就是：池：拥有回收机制，即下次可以继续执行 Mybatis默认的事务管理器就是JDBC，连接池：POOLED ","date":"2021-07-04","objectID":"/mybatis/:4:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.3、属性（properties） 我们可以通过properties属性来实现引用配置文件 这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。【db.properties】 编写一个配置文件：db.properties driver=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3308/mybatis?useSSL=true\u0026userUnicode=true\u0026characterEncoding=UTF-8 username=root password=xn123456 在核心配置文件中引入 \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e 可以直接引入外部文件 可以在其中增加一些属性配置 如果两个文件有同一个字段，优先使用外部配置文件的！ ","date":"2021-07-04","objectID":"/mybatis/:4:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.4、类型别名（typeAliases） 类型别名可为 Java 类型设置一个缩写名字。 意在降低冗余的全限定类名书写。 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003ctypeAlias type=\"com.kuang.pojo.User\" alias=\"User\"/\u003e \u003c/typeAliases\u003e 也可以指定一个包名，Mybatis会在包名下面搜索需要的Java Bean 扫描实体类的包，它的默认别名就为这个类的类名首字母小写 \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e 在实体类比较少的时候，使用第一种方式 如果实体类十分多，建议使用第二种 第一种可以DIY别名，第二种则不行，如果非要使用别名，需要在实体类上增加注解，在实体类上注解的同时，也需要在核心配置文件中扫描指定的包。 @Alias(\"user\") public class User { ","date":"2021-07-04","objectID":"/mybatis/:4:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.5、设置 这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。 ","date":"2021-07-04","objectID":"/mybatis/:4:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.6、其它配置 typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件] mybatis-generator-core mybatis-plus 通用mapper ","date":"2021-07-04","objectID":"/mybatis/:4:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.7、映射器（mappers） MapperRegistry：绑定注册我们的Mapper文件 方式一：【推荐使用】 \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/UserMapper.xml\"/\u003e \u003c/mappers\u003e 方式二：使用class文件绑定注册 \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ 方式三：使用扫描包进行注入绑定 \u003cmappers\u003e \u003cmapper package=\"com.kuang.dao\"/\u003e \u003c/mappers\u003e 注意点： 接口和它的mapper配置文件必须同名 接口和它的Mapper配置文件必须在同一个包下！ ","date":"2021-07-04","objectID":"/mybatis/:4:7","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"4.8、生命周期和作用域 生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的并发问题。 SqlSessionFactoryBuilder： 一旦创建了 SqlSessionFactory，就不再需要它了 它是一个局部变量 SqlSessionFactory： 说白了就是可以想象为：数据库连接池 SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例 因此SqlSessionFactory的最佳作用域是应用作用域 最简单的就是使用单例模式或者静态单例模式。使其保证全局唯一 SqlSession： 连接到连接池的一个请求！ SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 用完之后需要赶紧关闭，否则资源被占用！ 这里面的每一个Mapper，就代表一个具体的业务！ ","date":"2021-07-04","objectID":"/mybatis/:4:8","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5、解决属性名和字段名不一致的问题 ","date":"2021-07-04","objectID":"/mybatis/:5:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.1、问题 数据库中的字段 新建一个项目，拷贝之前的，测试实体类字段不一致的情况 public class User { private int id; private String name; private String password; } // select * from mybatis.user where id = #{id} //类型处理器 // select id,name,pwd from mybatis.user where id = #{id} 解决方法： 起别名 \u003cselect id=\"getUserById\" parameterType=\"int\" resultType=\"com.kuang.pojo.User\"\u003e select id,name,pwd as password from mybatis.user where id = #{id} \u003c/select\u003e ","date":"2021-07-04","objectID":"/mybatis/:5:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"5.2、resultMap 结果集映射 \u003c!--结果集映射：id就是你下面resultMap的值；type就是结果集要映射成谁就是什么类型--\u003e \u003cresultMap id=\"UserMap\" type=\"User\"\u003e \u003c!--column数据库中的字段，property实体类中的属性--\u003e \u003cresult column=\"id\" property=\"id\"/\u003e \u003cresult column=\"name\" property=\"name\"/\u003e \u003cresult column=\"pwd\" property=\"password\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getUserById\" parameterType=\"int\" resultMap=\"UserMap\" \u003e select * from mybatis.user where id = #{id} \u003c/select\u003e resultMap 元素是 MyBatis 中最重要最强大的元素 ResultMap 的设计思想是，对简单的语句做到零配置，对于复杂一点的语句，只需要描述语句之间的关系就行了。 ResultMap最优秀的地方在于，虽然你已经对它相当了解了，但是根本iju不需要显示地用到它们。 ","date":"2021-07-04","objectID":"/mybatis/:5:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6、日志 ","date":"2021-07-04","objectID":"/mybatis/:6:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.1、日志工厂 如果一个数据库操作，出现了异常。日志就是最好的助手 曾经：sout、debug 现在：日志工厂！ SLF4J LOG4J LOG4J2 JDK_LOGGING COMMONS_LOGGING STDOUT_LOGGING NO_LOGGING 在mybatis中具体使用哪一个日志实现，在设置中设定！ STDOUT_LOGGING标准日志输出 注意：使用标准日志输出时，出现报错：1、value后面的值又空格，切记！ 在mybatis核心配置文件中，配置我们的日志 \u003csettings\u003e \u003c--标准的日志工厂实现--\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c/settings\u003e ","date":"2021-07-04","objectID":"/mybatis/:6:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"6.2、Log4j 什么是log4j？ Log4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件 我们也可以控制每一条日志的输出格式 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程 通过一个配置文件来灵活地进行配置，而不需要修改应用的代码 先导入log4j的包 \u003c!-- https://mvnrepository.com/artifact/log4j/log4j --\u003e \u003cdependency\u003e \u003cgroupId\u003elog4j\u003c/groupId\u003e \u003cartifactId\u003elog4j\u003c/artifactId\u003e \u003cversion\u003e1.2.17\u003c/version\u003e \u003c/dependency\u003e kog4j.properties #将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码 log4j.rootLogger=DEBUG,console,file #控制台输出的相关设置 log4j.appender.console=org.apache.log4j.ConsoleAppender log4j.appender.console.Target=System.out log4j.appender.console.Threshold=DEBUG log4j.appender.console.layout=org.apache.log4j.PatternLayout log4j.appender.console.layout.ConversionPattern=[%c]-%m%n #文件输出的相关设置 log4j.appender.file=org.apache.log4j.RollingFileAppender log4j.appender.file.File=./log/kuang.log log4j.appender.file.MaxFileSize=10mb log4j.appender.file.Threshold=DEBUG log4j.appender.file.layout=org.apache.log4j.PatternLayout log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n #日志输出级别 log4j.logger.org.mybatis=DEBUG log4j.logger.java.sql=DEBUG log4j.logger.java.sql.Statement=DEBUG log4j.logger.java.sql.ResultSet=DEBUG log4j.logger.java.sql.PrepareStatement=DEBUG 配置log4j为日志的实现 \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"LOG4J\"/\u003e \u003c/settings\u003e Log4j的使用，直接测试运行刚才的查询 [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.logging.LogFactory]-Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VFS [org.apache.ibatis.io.JBoss6VFS]-JBoss 6 VFS API is not available in this environment. [org.apache.ibatis.io.VFS]-Class not found: org.jboss.vfs.VirtualFile [org.apache.ibatis.io.VFS]-VFS implementation org.apache.ibatis.io.JBoss6VFS is not valid in this environment. [org.apache.ibatis.io.VFS]-Using VFS adapter org.apache.ibatis.io.DefaultVFS [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Reader entry: User.class [org.apache.ibatis.io.DefaultVFS]-Listing file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo [org.apache.ibatis.io.DefaultVFS]-Find JAR URL: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Not a JAR: file:/G:/IDEADocument/MyBatis-study/Mybatis-study/mybatis-04/target/classes/com/kuang/pojo/User.class [org.apache.ibatis.io.DefaultVFS]-Reader entry: ���� 4 @ [org.apache.ibatis.io.ResolverUtil]-Checking to see if class com.kuang.pojo.User matches criteria [is assignable to Object] [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.datasource.pooled.PooledDataSource]-PooledDataSource forcefully closed/removed all connections. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Opening JDBC Connection [org.apache.ibatis.datasource.pooled.PooledDataSource]-Created connection 2044903525. [org.apache.ibatis.transaction.jdbc.JdbcTransaction]-Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@79e2c065] [com.kuang.dao.UserMapper.getUserList]-==\u003e Preparing: select * from mybatis.user [com.kuang.dao.UserMapper.getUserList]-==\u003e Parameters: [com.kuang.dao.UserMapper.getUserList]-\u003c== Total: 3 User{id=1, name='科比', pwd='123456'} User{id=2, name='哈登', pwd='123456'} User{id=3, name='威少', pwd='123456'} [org.apache.ibatis.tran","date":"2021-07-04","objectID":"/mybatis/:6:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7、分页 思考：为什么要分页？ 减少数据的处理量 ","date":"2021-07-04","objectID":"/mybatis/:7:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.1、使用Limit 分页 语法： SELECT * from user limit startIndex,pageSize; startIndex:起始的位置，按数组下标开始进行分页 pageSize:每一页的数量 SELECT * from user limit 3; #类似于[0,n] 使用Mybatis实现分页，核心就是SQL 接口 //分页 List\u003cUser\u003e getUserByLimit(Map\u003cString,Integer\u003emap); Mapper.xml \u003cselect id=\"getUserByLimit\" parameterType=\"map\" resultType=\"user\"\u003e select * from mybatis.user limit #{startIndex},#{pageSize}; \u003c/select\u003e 如果此处的pwd没有改成password，则不需要进行结果集映射，如果改了，则需要进行结果集映射，就不能使用resultType，则需要使用resultMap 测试 @Test public void getUserByLimit(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); HashMap\u003cString, Integer\u003e map = new HashMap\u003c\u003e(); map.put(\"startIndex\",0); map.put(\"pageSize\",2); List\u003cUser\u003e userList = mapper.getUserByLimit(map); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:7:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.2、RowBounds分页 不再使用sql实现分页 接口 //分页2 List\u003cUser\u003e getUserByRowBounds(); mapper.xml \u003cselect id=\"getUserByRowBounds\" resultType=\"user\"\u003e select * from mybatis.user; \u003c/select\u003e 测试 @Test public void getUserByRowBounds(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //通过RowBounds实现分页 RowBounds rowBounds = new RowBounds(1, 2); //通过Java代码层实现分页 List\u003cUser\u003e userList = sqlSession.selectList(\"com.kuang.dao.UserMapper.getUserByRowBounds\",null,rowBounds); for (User user : userList) { System.out.println(user); } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:7:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"7.3、分页插件 了解即可，==Mybatis PageHelper== ","date":"2021-07-04","objectID":"/mybatis/:7:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8、使用注解开发 ","date":"2021-07-04","objectID":"/mybatis/:8:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.1、面向接口编程 ","date":"2021-07-04","objectID":"/mybatis/:8:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.2、使用注解开发 注解直接在接口上实现 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); } 需要在核心配置文件中绑定接口！ \u003c!--绑定接口--\u003e \u003cmappers\u003e \u003cmapper class=\"com.kuang.dao.UserMapper\"/\u003e \u003c/mappers\u003e 测试使用 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); //底层主要应用反射 UserMapper mapper = sqlSession.getMapper(UserMapper.class); List\u003cUser\u003e userList = mapper.getUsers(); for (User user : userList) { System.out.println(user); } sqlSession.close(); } 本质：反射机制实现 底层：动态代理！ ","date":"2021-07-04","objectID":"/mybatis/:8:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"8.3、注解的CRUD 我们可以在工具类创建的时候自动提交事务 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(true); } 编写接口，增加注解 public interface UserMapper { @Select(\"select * from user\") List\u003cUser\u003e getUsers(); //@Param方法存在多个参数，所有的参数前面必须加上@Param(\"id\")注解 @Select(\"select * from user where id = #{id}\") User getUserById(@Param(\"id\") int id); @Insert(\"insert into user(id,name,pwd) values (#{id},#{name},#{pwd})\") int addUser(User user); @Update(\"update user set name=#{name},pwd=#{pwd} where id = #{id}\") int updateUser(User user); @Delete(\"delete from user where id = #{uid}\") int deleteUser(@Param(\"uid\") int id); } 注意：我们必须要将接口注册绑定到我们的核心配置文件中 使用Param注解时，里面对应的基本类型应当与sql语句中的类型一致，否则报错 关于@Param()注解 基本类型的参数或者String类型，需要加上 引用类型不需要加 如果只有一个基本类型的话，可以忽略，但是建议加上去 我们在SQL中引用的就是我们这里的@Param()中设置的属性名 ","date":"2021-07-04","objectID":"/mybatis/:8:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"9、Lombok 使用步骤： 在IDEA中安装Lombok插件！ 在项目中导入Lombok的ｊａｒ包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 这是一款懒人插件，虽然简化了许多，但是却对新手造成了困惑，不容易去阅读源码了；对于这种插件，合理的利用才是关键 说明： ＠Data：无参构造，get、set、toString、hashcode、equals @AllArgsConstructor：有参构造 @NoArgsConstructor：无参构造 ","date":"2021-07-04","objectID":"/mybatis/:9:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10、多对一处理 多对一: 多个学生，对应一个老师 对于学生这边而言，关联…多个学生，关联一个老师 【多对一】 对于老师这边而言，集合…一个老师，有很多学生 【一对多】 SQL： CREATE TABLE `teacher`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, PRIMARY KEY(`id`) )ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO teacher(`id`,`name`) VALUES (1,'秦老师'); CREATE TABLE `student`( `id` INT(10) NOT NULL, `name` VARCHAR(30) DEFAULT NULL, `tid` INT(10) DEFAULT NULL, PRIMARY KEY(`id`), KEY `fktid`(`tid`), CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8 INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('1','小明','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('2','小红','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('3','小张','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('4','小李','1'); INSERT INTO `student` (`id`,`name`,`tid`) VALUES ('5','小王','1'); 实体类： public class Student { private int id; private String name; //关联老师 private Teacher teacher; } public class Teacher { private int id; private String name; } ","date":"2021-07-04","objectID":"/mybatis/:10:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.1、按照查询嵌套处理 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.StudentMapper\"\u003e \u003c!--思路： 1.查询所有的学生信息 2.根据查询出来的学生的tid，寻找对应的那个老师 --\u003e \u003cselect id=\"getStudent\" resultMap=\"StudentTeacher\"\u003e select * from student; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--复杂的属性，我们需要单独处理，如果属性是对象，我们采用association，如果属性是集合，我们采用collection javaType是因为属性为对象，所以得给其设置一个类型，select作用是通过column中的字段要来进行什么操作 javaType=\"\" 指定属性的类型 集合中的泛型信息，我们使用ofType获取 --\u003e \u003cassociation property=\"teacher\" column=\"tid\" javaType=\"Teacher\" select=\"getTeacher\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getTeacher\" resultType=\"Teacher\"\u003e select * from teacher; \u003c/select\u003e \u003c/mapper\u003e 相当于是子查询，先查询出所有的学生，在通过查询出来的结果再进行一次查询。如下这种形式 select id,name,name from student where tid=(select .......); ","date":"2021-07-04","objectID":"/mybatis/:10:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"10.2、按照结果嵌套处理 \u003c--s.id sid相当于给其起一个别名，也就相当于数据库里面的id变成了sid--\u003e \u003cselect id=\"getStudent2\" resultMap=\"StudentTeacher2\"\u003e select s.id sid,s.name sname,t.name tname from student s,teacher t where s.tid=t.id; \u003c/select\u003e \u003cresultMap id=\"StudentTeacher2\" type=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003c--这里是直接根据结果来返回结果的类型，再来嵌套进行查找；即相当于从结果入手，反向查询--\u003e \u003cassociation property=\"teacher\" javaType=\"Teacher\"\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c/association\u003e \u003c/resultMap\u003e 回顾M以上情况多对一查询方式： 子查询 联表查询（即第二种方法） ","date":"2021-07-04","objectID":"/mybatis/:10:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11、一对多 比如：一个老师拥有多个学生 对于老师而言，就是一对多的关系 实体类： @Data public class Teacher { private int id; private String name; //一个老师拥有多个学生 private List\u003cStudent\u003e students; } public class Student { private int id; private String name; private int tid; } ","date":"2021-07-04","objectID":"/mybatis/:11:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.1、按照结果嵌套查询（推荐） \u003cselect id=\"getTeacher\" resultMap=\"TeacherStudent\"\u003e select s.id sid,s.name sname ,t.name tname ,t.id tid from student s,teacher t where s.tid=t.id and t.id=#{tid} \u003c/select\u003e \u003cresultMap id=\"TeacherStudent\" type=\"Teacher\"\u003e \u003cresult property=\"id\" column=\"tid\"/\u003e \u003cresult property=\"name\" column=\"tname\"/\u003e \u003c!--集合中的泛型信息，我们使用ofType获取 这里取出来的是每一个值，取出每一个值所对应的，所以我们采用ofType--\u003e \u003ccollection property=\"students\" ofType=\"Student\"\u003e \u003cresult property=\"id\" column=\"sid\"/\u003e \u003cresult property=\"name\" column=\"sname\"/\u003e \u003cresult property=\"tid\" column=\"tid\"/\u003e \u003c/collection\u003e \u003c/resultMap\u003e 注意点：一对多，对于按结果查询使用collection时，如果是取出的一个个值，则 需使用ofType来指定其类型，而不使用JavaType 而对于按查询嵌套使用collection时，我们取出的是一个集合，而不是一个个值，则需要使用JavaType来指定属性的对象类型，同时还得将泛型的信息使用ofType写上 ","date":"2021-07-04","objectID":"/mybatis/:11:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.2、按照查询嵌套处理 \u003cselect id=\"getTeacher2\" resultMap=\"TeacherStudent2\"\u003e select * from Teacher where id=#{tid}; \u003c/select\u003e \u003cresultMap id=\"TeacherStudent2\" type=\"Teacher\"\u003e \u003c--这里是相同属性名的话可以省略不用写--\u003e \u003cresult property=\"id\" column=\"id\"/\u003e \u003cresult property=\"name\" column=\"name\"/\u003e \u003c!--这里所取出来的值就是一个集合，所以得写上其JavaType的类型，也就是集合的对象类型，并且里面的泛型信息也得写上--\u003e \u003ccollection property=\"students\" column=\"id\" javaType=\"ArrayList\" ofType=\"Student\" select=\"getStudent\"/\u003e \u003c/resultMap\u003e \u003cselect id=\"getStudent\" resultType=\"Student\"\u003e \u003c--这个地方的#{id}中的id可以随意填，因为mybatis会自动去匹配，但是为了规范还是正规写--\u003e select * from Student where tid=#{id}; \u003c/select\u003e ","date":"2021-07-04","objectID":"/mybatis/:11:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"11.3、小结 1. 关联--assocation 【多对一】 2. 集合--collection 【一对多】 3. JavaType \u0026\u0026 ofType 1. Java Type 用来指定实体类中属性的类型 2. ofType 用来指定映射到List或者集合中的pojo类型，即泛型中的约束类型！ 注意点： 保证SQL的可读性，尽量保证通俗易懂 注意一对多和多对一中，属性名和字段的问题 如果问题不好排查错误，可以使用日志，建议使用Log4j ","date":"2021-07-04","objectID":"/mybatis/:11:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12、动态SQL 什么是动态SQL：动态SQL就是根据不同的条件生成不同的语句 ","date":"2021-07-04","objectID":"/mybatis/:12:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.1、搭建环境 CREATE TABLE `blog`( `id` VARCHAR(50) NOT NULL COMMENT '博客id', `title` VARCHAR(100) NOT NULL COMMENT '博客标题', `author` VARCHAR(30) NOT NULL COMMENT '博客作者', `create_time` DATETIME NOT NULL COMMENT '创建时间', `views` INT(30) NOT NULL COMMENT '浏览量' )ENGINE=INNODB DEFAULT CHARSET=utf8 创建一个基础工程 导包 \u003c!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.projectlombok\u003c/groupId\u003e \u003cartifactId\u003elombok\u003c/artifactId\u003e \u003cversion\u003e1.18.18\u003c/version\u003e \u003c/dependency\u003e 编写配置文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"\u003e \u003c!--configuration核心配置文件--\u003e \u003cconfiguration\u003e \u003c!--引入外部配置文件--\u003e \u003cproperties resource=\"db.properties\"\u003e \u003cproperty name=\"username\" value=\"root\"/\u003e \u003cproperty name=\"password\" value=\"xn123456\"/\u003e \u003c/properties\u003e \u003csettings\u003e \u003csetting name=\"logImpl\" value=\"STDOUT_LOGGING\"/\u003e \u003c!--是否开启驼峰命名自动映射--\u003e \u003csetting name=\"mapUnderscoreToCamelCase\" value=\"true\"/\u003e \u003c/settings\u003e \u003c!--可以给实体类起别名--\u003e \u003ctypeAliases\u003e \u003cpackage name=\"com.kuang.pojo\"/\u003e \u003c/typeAliases\u003e \u003cenvironments default=\"development\"\u003e \u003cenvironment id=\"development\"\u003e \u003ctransactionManager type=\"JDBC\"/\u003e \u003cdataSource type=\"POOLED\"\u003e \u003cproperty name=\"driver\" value=\"${driver}\"/\u003e \u003cproperty name=\"url\" value=\"${url}\"/\u003e \u003cproperty name=\"username\" value=\"${username}\"/\u003e \u003cproperty name=\"password\" value=\"${password}\"/\u003e \u003c/dataSource\u003e \u003c/environment\u003e \u003c/environments\u003e \u003cmappers\u003e \u003cmapper resource=\"com/kuang/dao/BlogMapper.xml\"/\u003e \u003c/mappers\u003e \u003c/configuration\u003e 编写实体类 @Data public class Blog { private String id; private String title; private String author; private Date createTime;//属性名和字段名不一致，可以开启Setting中的驼峰命名规则 private int views; } 编写实体类对应Mapper接口和Mapper.xml文件 public interface BlogMapper { //插入数据 int addBlog(Blog blog); } \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003c!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"\u003e \u003cmapper namespace=\"com.kuang.dao.BlogMapper\"\u003e \u003cinsert id=\"addBlog\" parameterType=\"blog\"\u003e insert into mybatis.blog (id,title,author,create_time,views) values (#{id},#{title},#{author},#{createTime},#{views}); \u003c/insert\u003e \u003c/mapper\u003e 测试 @Test public void addBlogTest() { SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); Blog blog = new Blog(); blog.setId(IDUtils.getId()); blog.setTitle(\"Mybatis\"); blog.setAuthor(\"狂神说\"); blog.setCreateTime(new Date()); blog.setViews(9999); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Java\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"Spring\"); mapper.addBlog(blog); blog.setId(IDUtils.getId()); blog.setTitle(\"微服务\"); mapper.addBlog(blog); sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:12:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.2、IF \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog where 1=1 \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/select\u003e @Test public void queryBlogif(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); BlogMapper mapper = sqlSession.getMapper(BlogMapper.class); HashMap map = new HashMap(); //map.put(\"title\",\"Mybatis\"); map.put(\"author\",\"狂神说\"); List\u003cBlog\u003e blogList = mapper.queryBlogIf(map); for (Blog blog : blogList) { System.out.println(blog) ; } sqlSession.close(); } ","date":"2021-07-04","objectID":"/mybatis/:12:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.3、choose（when,otherwise） \u003cselect id=\"queryBlogChoose\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cchoose\u003e \u003cwhen test=\"title != null\"\u003e title=#{title} \u003c/when\u003e \u003cwhen test=\"author != null\"\u003e and author=#{author} \u003c/when\u003e \u003cotherwise\u003e and views=#{views} \u003c/otherwise\u003e \u003c/choose\u003e \u003c/where\u003e \u003c/select\u003e **注意点：**使用where的时候，当条件成立的时候where会自动去除and或者or 使用choose时，当条件成立时，只会选择一个语句进行执行，其它语句则不执行，当所有语句都不成立时，则会使用otherwise中的语句；类似与switch-case，执行一个case后面有break，执行完就跳出 ","date":"2021-07-04","objectID":"/mybatis/:12:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.4、trim(where，set) \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/where\u003e \u003c/select\u003e \u003cupdate id=\"updateBlog\" parameterType=\"map\"\u003e update mybatis.blog \u003cset\u003e \u003cif test=\"title != null\"\u003e title=#{title}, \u003c/if\u003e \u003cif test=\"author != null\"\u003e author=#{author} \u003c/if\u003e \u003c/set\u003e where id =#{id} \u003c/update\u003e set元素会动态前置SET关键字，同时也会删掉无关的逗号 所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一个逻辑代码 ","date":"2021-07-04","objectID":"/mybatis/:12:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.5、SQL片段 有时候，我们可能会将一些功能的部分抽取出来，方便复用 使用SQL标签抽取公共的部分 \u003csql id=\"if-title-author\"\u003e \u003cif test=\"title != null\"\u003e and title=#{title} \u003c/if\u003e \u003cif test=\"author != null\"\u003e and author=#{author} \u003c/if\u003e \u003c/sql\u003e 在需要使用的地方使用include标签引用即可 \u003cselect id=\"queryBlogIf\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cinclude refid=\"if-title-author\"\u003e\u003c/include\u003e \u003c/where\u003e \u003c/select\u003e 注意事项： 最好基于单表来定义SQL片段（如果是多表查询会让其效率变低，公共部分的拼接就会很复杂） 不要存在where标签 ","date":"2021-07-04","objectID":"/mybatis/:12:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"12.6、Foreach \u003c!-- 这个地方我们在使用foreach时，是遍历的一个集合，而我们传递的参数为map，所有我们的map中可以存在一个集合 item：从集合中遍历出来的值,也就是传到#{}中的值 separator：中间的分隔符 --\u003e \u003cselect id=\"queryBlogForeach\" parameterType=\"map\" resultType=\"blog\"\u003e select * from mybatis.blog \u003cwhere\u003e \u003cforeach collection=\"ids\" item=\"id\" open=\"and (\" close=\")\" separator=\"or\"\u003e id=#{id} \u003c/foreach\u003e \u003c/where\u003e \u003c/select\u003e 动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了 建议： 先在Mysql中写出完整的SQL，再对应的去修改成为我们的动态SQL实现通用即可 ","date":"2021-07-04","objectID":"/mybatis/:12:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13、缓存（了解） ","date":"2021-07-04","objectID":"/mybatis/:13:0","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.1、简介 查询---\u003e连接数据库，耗资源 一次查询的结果，给它暂存到一个可以直接取值的地方！--\u003e内存：缓存 我们再次查询相同数据的时候，直接走缓存，就不用走数据库了 什么是缓存 存在内存中的临时数据 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库文件）查询，从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题 为什么使用缓存？ 减少和数据库的交互次数，减少系统开销，提高系统效率 什么样的数据能使用缓存 经常查询并且不经常改变的数据【可以使用缓存】 不经常查询并且经常改变的数据【不可以使用缓存】 ","date":"2021-07-04","objectID":"/mybatis/:13:1","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.2、Mybatis缓存 Mybatis包含一个非常强大的查询缓存特性，它可以非常方便的定制和配置缓存。缓存可以极大的提升查询效率 Mybatis系统中默认定义了两级缓存：一级缓存和二级缓存 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存） 二级缓存需要手动开启和配置，它是基于namespace级别的缓存。 为了提高扩展性，Mybatis定于了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存 ","date":"2021-07-04","objectID":"/mybatis/:13:2","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.3、一级缓存 一级缓存也叫本地缓存：SqlSession就是一个一级缓存 与数据库同一次会话期间查询到的数据会放在本地缓存中。 以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库 测试步骤： 开启日志 测试在一个Sqlsession中查询两次相同的记录 @Test public void test(){ SqlSession sqlSession = MybatisUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); User user = mapper.queryUserById(1); System.out.println(user); System.out.println(\"================\"); User user1 = mapper.queryUserById(1); System.out.println(user1); System.out.println(user==user1); sqlSession.close(); } 查看日志输出 缓存失效的情况： 查询不同的东西 增删改操作，可能改变原来的数据，所以必定会刷新缓存 查询不同的Mapper.xml 手动清理缓存 小结：一级缓存默认是开启的，只在一次Sqlsession中有效，也就是拿到连接到关闭连接这个区间段！ 一级缓存就是一个map ","date":"2021-07-04","objectID":"/mybatis/:13:3","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.4、二级缓存 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存 基于namespace级别的缓存，一个名称空间，对应一个二级缓存 工作机制 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据被保存到二级缓存中 新的会话查询信息，就可以从二级缓存中获取内容 不同的mapper查出的数据会存放在自己对应的缓存（map）中 步骤： 开启全局缓存 \u003c!--开启全局缓存--\u003e \u003csetting name=\"cacheEnabled\" value=\"true\"/\u003e 在要使用二级缓存的Mapper中开启 \u003c!--开启二级缓存--\u003e \u003ccache/\u003e 也可以自定义参数 \u003c!--在当前Mapper.xml中使用二级缓存--\u003e \u003ccache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/\u003e 测试 问题：当我们没有设置策略时，我们需要将实体类实例化！否则就会报错 Caused by: java.io.NotSerializableException: com.kuang.pojo.User 小结： 只要开启了二级缓存，在同一个Mapper下就有效 所有的数据都会先放在一级缓存中 只有当会话提交，或者关闭的时候，才会提交到二级缓存中！ ","date":"2021-07-04","objectID":"/mybatis/:13:4","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.5、缓存原理 缓存顺序： 先看二级缓存中有没有 再看一级缓存中有没有 两个都没有，再去查数据库 ","date":"2021-07-04","objectID":"/mybatis/:13:5","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Mybatis"],"content":"13.6、自定义缓存-ehcache Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存 要在程序中使用Ehcache步骤 先导包 \u003c!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.mybatis.caches\u003c/groupId\u003e \u003cartifactId\u003emybatis-ehcache\u003c/artifactId\u003e \u003cversion\u003e1.2.1\u003c/version\u003e \u003c/dependency\u003e 在mapper中指定使用我们的ahcache缓存实现 \u003ccache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/\u003e ehcache.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"http://ehcache.org/ehcache.xsd\" updateCheck=\"false\"\u003e \u003cdiskStore path=\"./tmpdir/Tmp_EhCache\"/\u003e \u003cdefaultCache eternal=\"false\" maxElementsInMemory=\"10000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"259200\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003ccache name=\"cloud_user\" eternal=\"false\" maxElementsInMemory=\"5000\" overflowToDisk=\"false\" diskPersistent=\"false\" timeToIdleSeconds=\"1800\" timeToLiveSeconds=\"1800\" memoryStoreEvictionPolicy=\"LRU\"/\u003e \u003c/ehcache\u003e ","date":"2021-07-04","objectID":"/mybatis/:13:6","tags":["Mybatis"],"title":"Mybatis","uri":"/mybatis/"},{"categories":["Linux"],"content":"linux","date":"2021-07-04","objectID":"/linux/","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Linux 基本使用 /bin: bin是Binary的缩写，这个目录存放着最经常使用的命令。 /boot: 这里存放的是启动Linux是使用的一些核心文件，包括一些连接文件以及镜像文件。 (不要动) /dev：dev是Device（设备）的缩写，存放的是Linux的外部设备，在Linux中访问设备的方式和文件的方式是相同的。 ==/etc==：这个目录用来存放所有的系统管理所需要的配置文件和子目录。重要 ==/home==：用户的主目录，在Linux中，每个用户都拥有一个自己的目录，一般该目录是以用户的账号命名的。 /lib：这个目录里存放着系统最基本的动态连接库，其与Windows里的DLL文件 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。（不要动，存放一些突然关机文件） /media：Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux会把识别的设备挂在到这个目录下。 /mnt：系统提供该目录是为了让用户临时挂载别的文件系统，我们看将光驱挂载在/mnt上，然后进入该目录就可以查看光驱里面的内容了。 ==/opt==：这是给主机额外安装软件所摆放的目录。比如你安装有一个Oracle数据库，则就可以用放在这个目录下。默认是空的。 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统的信息。（不用管） /root：该目录为系统管理员，也称作超级权限这的与用户主目录。 /sbin：s就是Super User的isi，这里存放的就是系统管理员使用的系统管理程序。 /srv：该目录存放一些服务启动之后需要提取的数据。 /sys：这是Linux2.6内核的有一个很大的变化，该目录下安装了2.6内核中新出现的一个文件系统sysfs。 /tmp：这个目录用来存放一些临时文件的。（用完即丢的文件可以放在这个目录下） ==/usr==：这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下。类似与Windows下的progra files目录。 /usr/bin：系统用户使用的应用程序。 /usr/sbin：超级用户使用的比较高级的管理程序和系统守护程序。Super /usr/src：内核源代码默认的放置目录。 /var：这个目录中存放着在不断扩充的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。 /run：是一个临时文件系统，存储系统同启动以来的信息。当系统重启时，这个目录下的文件一个被删掉或者清除。 ","date":"2021-07-04","objectID":"/linux/:1:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Linux常用的基本命令 ","date":"2021-07-04","objectID":"/linux/:2:0","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"目录管理 绝对路径、相对路径 绝对路径的全称：F:\\deskBackground\\xxxx cd：切换目录命令 ./：当前目录 cd ..：退回到上一级目录 ls（列出目录） 在Linux中ls可能时最常常被使用的！ -a 参数：all，查看全部的文件，包括隐藏的文件 -l 参数：列出所有的文件，包含文件的属性和权限，没有隐藏文件 所有的Linux可以组合使用。 cd命令 切换目录 cd 目录命令（绝对路径都是以/开头，相对路径，对于当前目录该如何寻找../../） pwd显示当前用户所在的目录 mkdir 创建一个目录 白色代表文件。蓝色代表文件夹 创建一个层级目录， 要加入一个 -p rmdir 删除目录 如果要删除一个层级目录，则也需要加入一个参数 -p rmdir仅仅只能删除空的目录，如果下面存在文件，需要先删除文件，递归删除多个目录加入-p参数即可 如果删除文件夹中的内容，可以采用 rm -f 强制删除 \\-r 向下递归，不管有多少级目录，一并删除。 \\-f 直接强行删除，没有任何提示。 cp （复制文件或者目录） cp 原来的地方 新的地方 如果是重复复制一个文件会产生覆盖现象，它会提示你是否覆盖。 rm （移出文件或者目录） -f 忽略不存在的文件，不会出现警告，强制删除！ -r 递归删除目录！ -i 互动，删除询问是否删除 rm -f / 系统中所有的文件就被删除了，删库跑路就是这么操作的！ mv 移动文件或者目录！ 重命名文件 -f 强制移动 -u 只替换已经更新过的文件 ","date":"2021-07-04","objectID":"/linux/:2:1","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"基本属性 看懂文件属性 Linux系统是一种典型的多用户系统，不同的用户处于不同的地位，拥有不同的权限。为了保护系统的安全性，Linux系统对不同的用户访问同一文件（包括目录文件）的权限做了不同的规定。 在Linux中我们可以使用ll或者ls –l命令来显示一个文件的属性以及文件所属的用户和组，如： 实例中，boot文件的第一个属性用\"d\"表示。“d\"在Linux中代表该文件是一个目录文件。 在Linux中第一个字符代表这个文件是目录、文件或链接文件等等： ==当为[ d ]则是目录== ==当为[ - ]则是文件；== ==若是[ l ]则表示为链接文档 ( link file )；==如Windows系统中应用的快捷方式 若是[ b ]则表示为装置文件里面的可供储存的接口设备 ( 可随机存取装置 )； 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标 ( 一次性读取装置 )。 接下来的字符中，以三个为一组，且均为『rwx』 的三个参数的组合。 其中，\\[ r \\]代表可读(read)、\\[ w \\]代表可写(write)、\\[ x \\]代表可执行(execute)。 要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号\\[ - \\]而已。 每个文件的属性由左边第一部分的10个字符来确定（如下图）： 从左至右用0-9这些数字来表示。 第0位确定文件类型，第1-3位确定属主（该文件的所有者）拥有该文件的权限。第4-6位确定属组（所有者的同组用户）拥有该文件的权限，第7-9位确定其他用户拥有该文件的权限。 其中： 第1、4、7位表示读权限，如果用\"r\"字符表示，则有读权限，如果用\"-\"字符表示，则没有读权限； 第2、5、8位表示写权限，如果用\"w\"字符表示，则有写权限，如果用\"-\"字符表示没有写权限； 第3、6、9位表示可执行权限，如果用\"x\"字符表示，则有执行权限，如果用\"-\"字符表示，则没有执行权限。 对于文件来说，它都有一个特定的所有者，也就是对该文件具有所有权的用户。 同时，在Linux系统中，用户是按组分类的，一个用户属于一个或多个组。 文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。 因此，Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。 在以上实例中，boot 文件是一个目录文件，属主和属组都为 root。 修改文件属性 1、chgrp：更改文件属组 属主：表示属于哪一个主人 属组：表示属于哪一个组 chgrp \\[-R\\] 属组名 文件名 \\ -R：递归更改文件属组，就是在更改某个目录文件的属组时，如果加上-R的参数，那么该目录下的所有文件的属组都会更改。 2、chown：更改文件属主，也可以同时更改文件属组 chown \\[–R\\] 属主名 文件名 chown \\[-R\\] 属主名：属组名 文件名 3、chmod：更改文件9个属性 ==（必须掌握）== chmod \\[-R\\] xyz 文件或目 Linux文件属性有两种设置方法，一种是数字，一种是符号。 Linux文件的基本权限就有九个，分别是owner/group/others三种身份各有自己的read/write/execute权限。 先复习一下刚刚上面提到的数据：文件的权限字符为：『-rwxrwxrwx』， 这九个权限是三个三个一组的！其中，我们可以使用数字来代表各个权限，各权限的分数对照表如下： r:4 w:2 x:1 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，例如当权限为：[-rwxrwx—] 分数则是： - owner = rwx = 4+2+1 = 7 - group = rwx = 4+2+1 = 7 - others= --- = 0+0+0 = 0 chmod 770 filename 可以自己下去多进行测试！ ","date":"2021-07-04","objectID":"/linux/:2:2","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"文件内容查看 Linux系统中使用以下命令来查看文件内容 cat 由第一行开始显示文件内容 tac 从最后一行开始显示，可以看出tac 是 cat 的倒着写 nl 显示的时候，顺道输出行号！ more 一页一页的显示文件内容==按空格进行下翻页，enter代表像下一行看，:f查看行号== less 与 more 类似，但是比more 更好的是，它可以往前翻页！==按空格进行下翻页，上下键代表翻动页面，退出使用q命令，查找字符串 /要查找的字符串 向下查询；向上查询使用？要查询的字符串 ；n 继续搜寻下一个，N 向上寻找== head 只看头几行 ==它通过-n 参数来控制显示几行 tail 只看尾巴几行 ==也是通过-n参数来控制看那几行 可以使用man[命令]来查看各个命令的使用文档，如：man cp 网络配置目录：cd /etc/sysconfig/network-scripts/ 默认网络配置文件： Linux链接的概念（了解即可） Linux的链接分为两种：硬链接、软连接！ 硬链接：A—B，假设B是A的硬链接，那么他们两个指向了同一个文件！允许一个文件拥有多个路径，用户可通过这种机制建议硬链接到一些重要文件上，防止误删。 软链接：类似Windows下的快捷方式，删除了原文件，快捷方式也访问不了！ 创建链接 ln 命令 touch 命令创建文件 echo 输入字符串 [root@iZ8vb8plggk0dqs0rr5kzfZ /]# cd home [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 ln: failed to access ‘f1’: No such file or directory [root@iZ8vb8plggk0dqs0rr5kzfZ home]# touch f1 # 创建一个f1文件 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln f1 f2 # 创建一个硬链接 f2 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ln -s f1 f3 # 创建一个软链接 f3 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f1 f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ll total 4 -rw-r--r-- 2 root root 0 May 25 20:49 f1 -rw-r--r-- 2 root root 0 May 25 20:49 f2 lrwxrwxrwx 1 root root 2 May 25 20:49 f3 -\u003e f1 drwx------ 3 www www 4096 May 9 17:03 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# echo \"yeziqi hanhan\" \u003e\u003e f1 # 给f1文件中写入一些字符串！ [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f1 # 查看f1 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 # 查看f2 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 # 查看f3 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# 删除f1之后，查看f2和f3的区别 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# rm -rf f1 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls f2 f3 www [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f2 #f2硬链接还在 yeziqi hanhan [root@iZ8vb8plggk0dqs0rr5kzfZ home]# cat f3 #f3（软链接、符号链接失效）快捷方式失效 cat: f3: No such file or directory ","date":"2021-07-04","objectID":"/linux/:2:3","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"Vim编辑器 vim通过一些插件可以实现和IDE一样的功能！ 什么是Vim编辑器 Vim是从 vi 发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 简单的来说， vi 是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。 vim 则可以说是程序开发者的一项很好用的工具。 所有的 Unix Like 系统都会内建 vi 文书编辑器，其他的文书编辑器则不一定会存在。 连 vim 的官方网站 (http://www.vim.org) 自己也说 vim 是一个程序开发工具而不是文字处理软件。 vim键盘图： 三种使用模式 基本上 vi/vim 共分为三种模式，分别是命令模式（Command mode），输入模式（Insert mode）和底线命令模式（Last line mode）。这三种模式的作用分别是： 命令模式： 用户刚刚启动 vi/vim，便进入了命令模式。 此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。 以下是常用的几个命令： i 切换到输入模式，以输入字符。 x 删除当前光标所在处的字符。 : 切换到底线命令模式，以在最底一行输入命令。如果是编辑模式，需要先退出编辑模式！ESC！ 若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。 输入模式： 在命令模式下按下i就进入了输入模式。 在输入模式中，可以使用以下按键： 字符按键以及Shift组合，输入字符 ENTER，回车键，换行 BACK SPACE，退格键，删除光标前一个字符 DEL，删除键，删除光标后一个字符 方向键，在文本中移动光标 HOME/END，移动光标到行首/行尾 Page Up/Page Down，上/下翻页 Insert，切换光标为输入/替换模式，光标将变成竖线/下划线 ESC，退出输入模式，切换到命令模式 底线命令模式 在命令模式下按下:（英文冒号）就进入了底线命令模式。 底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。 在底线命令模式中，基本的命令有（已经省略了冒号）： q 退出程序 w 保存文件 按ESC键可随时退出底线命令模式。 简单的说，我们可以将这三个模式想成底下的图标来表示： Vim按键说明 除了上面简易示范的 i ，Esc ， :wq 之外，其实vim还有非常多的按键可以使用 第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等 移动光标的方法 h 或 向左箭头键(←) 光标向左移动一个字符 j 或 向下箭头键(↓) 光标向下移动一个字符 k 或 向上箭头键(↑) 光标向上移动一个字符 l 或 向右箭头键(→) 光标向右移动一个字符 [Ctrl] + [f] 屏幕『向下』移动一页，相当于 [Page Down]按键==(常用)== [Ctrl] + [b] 屏幕『向上』移动一页，相当于 [Page Up] 按键 ==(常用)== [Ctrl] + [d] 屏幕『向下』移动半页 [Ctrl] + [u] 屏幕『向上』移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 数字\u003c space\u003e 那个 n 表示『数字』，例如 20 。快捷切换光标 0 或功能键[Home] 这是数字『 0 』：移动到这一行的最前面字符处 ==(常用)== $ 或功能键[End] 移动到这一行的最后面字符处==(常用)== H 光标移动到这个屏幕的最上方那一行的第一个字符 M 光标移动到这个屏幕的中央那一行的第一个字符 L 光标移动到这个屏幕的最下方那一行的第一个字符 G 移动到这个档案的最后一行==(常用)== nG n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu) gg 移动到这个档案的第一行，相当于 1G 啊！==常用)== 数字\u003c Enter\u003e 光标向下移动 n 行==(常用)== 搜索替换 /word 向光标之下寻找一个名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！(常用) ?word 向光标之上寻找一个字符串名称为 word 的字符串。 n 这个 n 是英文按键。代表重复前一个搜寻的动作。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！ N 这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。 删除、复制与粘贴 x, X 在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) ==(常用)== nx n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。 dd 删除游标所在的那一整行==(常用)== ndd n 为数字。删除光标所在的向下 n 行，例如 20dd 则是删除 20 行 ==(常用)== d1G 删除光标所在到第一行的所有数据 dG 删除光标所在到最后一行的所有数据 d$ 删除游标所在处，到该行的最后一个字符 d0 那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符 yy 复制游标所在的那一行==(常用)== nyy n 为数字。复制光标所在的向下 n 行，例如 20yy 则是复制 20 行==(常用)== y1G 复制游标所在行到第一行的所有数据 yG 复制游标所在行到最后一行的所有数据 y0 复制光标所在的那个字符到该行行首的所有数据 y$ 复制光标所在的那个字符到该行行尾的所有数据 p,P p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？那么原本的第 20 行会被推到变成 30 行。==(常用)== J 将光标所在行与下一行的数据结合成同一行 c 重复删除多个数据，例如向下删除 10 行，[ 10cj ] u 复原前一个动作。==(常用)== [Ctrl]+r 重做上一个动作。==(常用)== 第二部分：一般模式切换到编辑模式的可用的按钮说明 进入输入或取代的编辑模式 i,I 进入输入模式(Insert mode)：i 为『从目前光标所在处输入』， I 为『在目前所在行的第一个非空格符处开始输入』。==(常用)== a,A 进入输入模式(Insert mode)：a 为『从目前光标所在的下一个字符处开始输入』， A 为『从光标所在行的最后一个字符处开始输入』。==(常用)== o,O 进入输入模式(Insert mode)：这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处输入新的一行』；O 为在目前光标所在处的上一行输入新的一行！==(常用)== r,R 进入取代模式(Replace mode)：r 只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下 ESC 为止；==(常用)== [Esc] 退出编辑模式，回到一般模式中==(常用)== 第三部分：一般模式切换到指令行模式的可用的按钮说明 指令行的储存、离开等指令 :w 将编辑的数据写入硬盘档案中==(常用)== :w! 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟你对该档案的档案权限有关啊！ :q 离开 vi ==(常用)== :q! 若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。 注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～ :wq 储存后离开，若为 :wq! 则为强制储存后离开 ==(常用)== ZZ 这是大写的 Z 喔！若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开 :w [filename] 将编辑的数据储存成另一个档案（类似另存新档） :r [filename] 在编辑的数据中，读入另一个档案的数据。亦即将 『filename』 这个档案内容加到游标所在行后面 :n1,n2 w [filename] 将 n1 到 n2 的内容储存成 filename 这个档案。 :! command 暂时离开 vi 到指令行模式下执行 command 的显示结果！例如 『:! ls /home』即可在 vi 当中看 /home 底下以 ls 输出的档案信息！ :set nu 显示行号，设定之后，会在每一行的前缀显示该行的行号 :set nonu 与 set nu 相反，为取消行号！ 以上标绿的是要熟练掌握的，其余的做了解即可！ ","date":"2021-07-04","objectID":"/linux/:2:4","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"账号管理 实现用户账号的管理，要完成的工作主要有如下几个方面： 用户账号的添加、删除与修改。 用户口令的管理。 用户组的管理。 useradd 命令 添加用户 useradd -选项 用户名 -m：自动创建这个用户的主目录–\u003e /home/用户名 参数说明： 选项 : \\-c comment 指定一段注释性描述。 \\-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。 \\-g 用户组 指定用户所属的用户组。 \\-G 用户组，用户组 指定用户所属的附加组。 \\-m　使用者目录如不存在则自动建立。 \\-s Shell文件 指定用户的登录Shell。 \\-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。 用户名 : 指定新账号的登录名。 [root@iZ8vb8plggk0dqs0rr5kzfZ home]# useradd -m wei [root@iZ8vb8plggk0dqs0rr5kzfZ home]# ls wei www 理解一下本质：Linux中一切皆文件，这里的添加用户说白了就是往某一个文件中写入用户信息了！/etc/passwd 删除用户 userdel userdel -r wei 删除用户的时候将他的目录页一并删掉！ 修改用户 usermod 修改用户 usermod 对应修改的内容 修改的用户 usermod -d /home/test wei 在进行修改某一个用户时，也要修改其文件的时候，应当先创建要移动到的文件，否则可能当前目录不显示移动后的文件，但是在配置文件中是存在的！ ​ Linux 下如何切换用户 root用户 1.切换用户的命令为：su username 【username是你的用户名哦】 2.从普通用户切换到root用户，还可以使用命令：sudo su 3.在终端输入exit或logout或使用快捷方式ctrl+d，可以退回到原来用户，其实ctrl+d也是执行的exit命令 4.在切换用户时，如果想在切换用户之后使用新用户的工作环境，可以在su和username之间加-，例如：【su - root】 $表示普通用户 #表示超级用户，也就是root用户 与用户的密码设置问题 我们一般它通过root创建用户的时候！要配置密码 Linux上输入密码时不会显示的，正常输入即可！ 在公司中，一般拿不到公司服务器的root权限，都是有一些分配的账号！ 锁定账户 root一旦冻结这个账号，这个人就登录不上系统了！ passwd -l wei #锁定之后这个用户也就不能登录了 passwd -d wei #没有密码也不能登录 ","date":"2021-07-04","objectID":"/linux/:2:5","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"用户组管理 属主（属于那一个主人）、属组 每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理（开发、测试、运维、root）。不同Linux 系统对用户 组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。 用户组的管理涉及用户组的添加、删除和修改。==组的增加、删除和修改实际上就是对/etc/group文件的更新。 创建一个用户组 groupadd wei 创建完用户组后可以得到一个Id，这个Id是可以指定的！-g 520 如果不指定就是自增1 用户如果要切换用户组怎么办呢？ # 登录当前用户 wei $ newgrp root 这样转换的前提是你得需要有这个权限，否则切换不成功！ 删除用户组 groupdel groupdel wei 修改与用户组的权限信息和名字 groupmod -g：修改端口号 -n：修改用户名字 拓展；文件的查看！（了解即可） /etc/passwd 用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell 这个文件中的灭有一行都代表这一个用户，我们可以用从这里看出这个用户的主目录在哪里，可以看到属于哪一个组！ 登录口令：把真正的加密后的用户口令字存放到/etc/shadow文件中 用户组的所有信息都存放在/etc/group文件中 ","date":"2021-07-04","objectID":"/linux/:2:6","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"磁盘管理 df （列出文件系统整体的磁盘使用量） du（检查磁盘空间的使用量） df du Mac或者想要使用Linux挂载我们的ixie本地磁盘或者文件！ 挂载：使用mount命令 卸载：unmount -f [挂载位置] 强制卸载 ","date":"2021-07-04","objectID":"/linux/:2:7","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"进程管理 Linux中一切皆文件 ==(文件: 读、写、执行（查看，创建，删除，移动，复制，编辑），权限（用户，用户组），系统（磁盘，进程））== 什么是进程（基本概念） 在Linux中，每一个进程都是有自己的一个进程，每一个进程都有一个id号 每一个进程，都有一个父进程 进程可以拥有两种方式存在：前台！后台运行 一般的话服务都是后台运行的，基本的程序都是前台运行的！ 命令 ps 查看当前系统中正在执行的各种进程信息 ps -xxx: a 显示当前终端运行的所有进程信息(当前的进程是一个) u 以用户的信息显示进程 x 显示后台运行进程的参数! ps -aux 查看所有的进程 ps -aux |grep mysql # | 在Linux中这个叫做管道符 # grep 查找文件中符合条件的字符串(相当于过滤) 对于我们来说, 这里目前只需要记住一个命令即可 ps -xx|grep 进程名字!过滤进程信息! ps -ef: 可以查看到父进程的信息 ps -ef|grep mysql # 看父进程我们一般可以通过目录树结构来查看！ # 进程树 pstree -pu -p 显示父id -u 显示用户组 结束进程： 杀掉进程，等价与Windows结束任务 kill -9 进程的id kill -9 进程的id 表示强制结束进程 ","date":"2021-07-04","objectID":"/linux/:2:8","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["Linux"],"content":"环境安装 安装软件有一般有三种方式： rpm（Jdk：在线发布一个SpringBoot项目） 解压缩（tomcat，启动并通过外网访问，也就是发布网站） yum在线安装（docker：直接运行跑起来docker就可以！） JDK安装 下载JDK rpm。去Oracle官网下载即可！ 安装Java环境 # 检测当前系统是否存在Java环境！ Java -version # 如果有的话就需要先卸载 # rpm -qa|grep jdk # 检测JDK版本信息 # rpm -e --nodeps jdk所在文件夹 # --nodeps 代表强制删除 # 卸载完毕后即可安装JDK # rpm -ivh rpm包 # 配置环境变量 配置环境变量：etc/profile在文件的最后面增加Java的配置和Windows安装环境变量一样 JAVA_HOME=/usr/java/jdk # Java根路径 CLASSPATH=%JAVA_HOME%/lib:%JAVA_HOME%/jre/lib # 类路径文件 PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin # 环境变量文件 export PATH CLASSPATH JAVA_HOME 让这个配置文件生效！source /etc/profile 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 Tomcat安装 安装好了Java环境后我们可以测试下Tomcat！准备好Tomcat的安装包！ 将文件移动到/usr/tomcat/下，并解压！ root@kuangshen kuangshen]# mv apache-tomcat-9.0.22.tar.gz /usr [root@kuangshen kuangshen]# cd /usr [root@kuangshen usr]# ls apache-tomcat-9.0.22.tar.gz [root@kuangshen usr]# tar -zxvf apache-tomcat-9.0.22.tar.gz # 解压 运行Tomcat，进入bin目录，和我们以前在Windows下看的都是一样的 # 执行：startup.sh --\u003e启动tomcat # 执行：shutdown.sh --\u003e关闭tomcat ./startup.sh ./shutdown.sh 确保Linux的防火墙端口是开启的，如果是阿里云，需要保证阿里云的安全组策略是开放的！ # 查看firewall服务状态 systemctl status firewalld # 开启、重启、关闭、firewalld.service服务 # 开启 service firewalld start # 重启 service firewalld restart # 关闭 service firewalld stop # 查看防火墙规则 firewall-cmd --list-all # 查看全部信息 firewall-cmd --list-ports # 只看端口信息 # 开启端口 开端口命令：firewall-cmd --zone=public --add-port=80/tcp --permanent 重启防火墙：systemctl restart firewalld.service 命令含义： --zone #作用域 --add-port=80/tcp #添加端口，格式为：端口/通讯协议 --permanent #永久生效，没有此参数重启后失效 域名解析完毕后，如果端口是80 -http或者443 -https，可以直接访问，如果是9000 8080，就需要通过Apache或者Nginx做一下反向代理即可，配置文件即可。 ","date":"2021-07-04","objectID":"/linux/:2:9","tags":["Linux"],"title":"Linux","uri":"/linux/"},{"categories":["JavaWeb"],"content":"javaweb","date":"2021-07-04","objectID":"/javaweb/","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1、基本概念 ","date":"2021-07-04","objectID":"/javaweb/:1:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.1、静态web 静态web存在的缺点 web页面无法更新 它无法和数据库交互（数据无法持久化，用户无法交互） ","date":"2021-07-04","objectID":"/javaweb/:1:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"1.2、动态web 页面会动态展示：“web的页面展示的效果因人而异” 动态web存在的缺点： 假如服务器的动态web资源出现了错误，我们需要重新编写我们的后台程序，重新发布； 动态web的优点： Web页面可以动态更新，所有用户看到的都不是同一个页面 它可以与数据库交互 ","date":"2021-07-04","objectID":"/javaweb/:1:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2、web服务器 ","date":"2021-07-04","objectID":"/javaweb/:2:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.1、技术讲解 PHP： PHP开发速度很快，功能很强大，跨平台，代码很简单 无法承载大量访问的情况 JSP/Servlet： B/S：浏览器和服务器 C/S：客户端和服务器 sun公司主推的B/S架构 基于Java语言（所有的大公司，或者一些开源的组件，都是用Java写的） 可以承载三高问题带来的影响 高可用 高并发 高性能 语法像ASP ","date":"2021-07-04","objectID":"/javaweb/:2:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"2.2、web服务器 服务器是一种被动的操作，用来处理用户的一些请求和给用户一些响应信息 IIS 微软的：ASP…….，Windows中自带的 Tomcat 下载tomcat： 解压 or 安装 了解配置文件以及目录结构 这个东西的作用 ","date":"2021-07-04","objectID":"/javaweb/:2:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3、Tomcat ","date":"2021-07-04","objectID":"/javaweb/:3:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.1、安装Tomcat Tomcat官网 ","date":"2021-07-04","objectID":"/javaweb/:3:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.2、Tomcat启动和配置 文件夹的作用 访问测试：Tomcat测试 可能遇到的问题： Java环境变量没有配置 闪退问题：需要配置兼容性 乱码问题：配置文件中设置 ","date":"2021-07-04","objectID":"/javaweb/:3:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.3、配置 可以配置启动的端口号 tomcat的默认端口是：8080 \u003cConnector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /\u003e 可以配置主机的名称 默认主机名为：localhost—\u003e127.0.0.1 默认网站应用存放的位置：webapps \u003cHost name=\"localhost\" appBase=\"webapps\" unpackWARs=\"true\" autoDeploy=\"true\"\u003e 高难度面试题： 请你谈谈网站是如何进行访问的！ 1. 输入一个域名；回车 2. 检查本机的C:\\Windows\\System32\\drivers\\etc\\hosts配置文件下有没有这个域名映射； 1. 有：直接返回对应的IP地址，这个地址中，有我们需要访问的web程序，可以直接访问 2. 没有：去DNS服务器找，找到的话就返回，找不到就返回找不到 ","date":"2021-07-04","objectID":"/javaweb/:3:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"3.4、发布一个web网站 查看Tomcat自带的一些样例 将自己写的网站，放到服务器（Tomcat）中指定的web应用的文件夹（webapps）下，就可以访问了 网站应有的结构 --webapps ：Tomcat服务器的web目录 --ROOT --clover ： 网站的目录名 - WEB-INF - classes ： Java程序 - lib ：web应用所有依赖的jar包 - web.xml ：网站配置文件 - index.html 默认的首页 - static -css -style.css -js -img ","date":"2021-07-04","objectID":"/javaweb/:3:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4、Http ","date":"2021-07-04","objectID":"/javaweb/:4:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.1、什么是Http HTTP（超文本传输协议）是一个简单的请求-响应协议，它通常运行在TCP之上 文本：html，字符串 超文本： 图片，音乐，视频，定位，地图。。。。。 默认端口：80 HTTPS：安全的 默认端口：443 ","date":"2021-07-04","objectID":"/javaweb/:4:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.2、两个时代 http1.0 HTTP/1.0：客户端可以与web服务器连接后，只能获得一个web资源，就断开连接。 http2.0 HTTP/2.0：客户端可以与web服务器连接后，可以获得多个web资源。 ","date":"2021-07-04","objectID":"/javaweb/:4:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.3、HTTP请求 客户端—发请求–服务器 1. Request URL: https://www.baidu.com/ 请求地址 2. Request Method: GET get方法/post方法 3. Status Code: 200 OK 状态码：200 4. Remote Address: 14.215.177.39:443 远程地址 1、请求行 请求行中的请求方式：GET 请求方式：Get，Post，HEAD，DELETE，PUT，TRACT get：一次请求能够携带的参数比较少，大小有限制，会在浏览器的URL地址栏显示数据内容，不安全，但高效。 post：一次请求能够携带的参数没有限制，大小没有限制，不会在浏览器的URL地址栏显示数据内容，安全，但不高效。 2、消息头 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 ","date":"2021-07-04","objectID":"/javaweb/:4:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"4.4、HTTP响应 服务器—响应—客户端 百度： Cache-Control: private 缓存控制 Connection: keep-alive 连接 Content-Encoding: gzip 编码 Content-Type: ext/html 类型 1、响应体 Accept: 告诉浏览器，它所支持的数据类型 Accept-Encoding: 支持那种编码格式GBK UTF-8 GB2312 ISO8859-1 Accept-Language: 告诉浏览器，它的语言环境 Cache-Control：缓存控制 Connection： 告诉浏览器，请求完成时断开还是保持连接 Refrush：告诉客户端多久刷新一次 Location： 让网页重新定位 2、相应状态码 200：代表请求响应成功 3**：请求重定向 重定向：你重新到我给你的新位置去 4xx：找不到资源 资源不存在 5xx：服务器代码错误 502：网关错误 常见面试题： 当你的浏览器中地址栏输入地址并回车的一瞬间到页面能够展示回来，经历了什么！ ","date":"2021-07-04","objectID":"/javaweb/:4:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5、Maven ","date":"2021-07-04","objectID":"/javaweb/:5:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.1、Maven项目架构管理工具 我们目前用来就是方便导入Jar包的！ Maven的核心思想：约定大于配置 有约束就不要去违反 Maven会规定好你该如何去编写我们的Java代码，必须按照这个规定来 ","date":"2021-07-04","objectID":"/javaweb/:5:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.2、配置环境变量 在系统环境变量中配置如下配置： M2_HOME maven 目录下的bin目录 MAVEN_HOME　maven的目录 在系统的path中配置 %MAVEN_HOME%\\bin 测试maven是否安装成功，必须配置完毕 ","date":"2021-07-04","objectID":"/javaweb/:5:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.3、阿里云镜像 \u003cmirror\u003e \u003cid\u003ealimaven\u003c/id\u003e \u003cname\u003ealiyun maven\u003c/name\u003e \u003curl\u003ehttp://maven.aliyun.com/nexus/content/groups/public/\u003c/url\u003e \u003cmirrorOf\u003ecentral\u003c/mirrorOf\u003e \u003c/mirror\u003e ","date":"2021-07-04","objectID":"/javaweb/:5:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.4、本地仓库 有本地仓库，就有远程仓库！ 建立一个本地仓库：localRepository \u003clocalRepository\u003eE:\\maven repository\\.m2\\repository\u003c/localRepository\u003e ","date":"2021-07-04","objectID":"/javaweb/:5:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.5、IDEA使用Maven Maven官网：https://mvnrepository.com/ IDEAMaven自动配置问题 在IDEA中标记文件夹功能 ","date":"2021-07-04","objectID":"/javaweb/:5:5","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"5.6、配置Tomcat的问题 解决警告问题 必须要的配置：为什么会有这个问题：我们访问一个网站，需要指定一个文件夹的名字 maven由于它的约定大于配置，我们之后可能遇到我们写的配置文件，无法被导出或者生效的问题。 解决方案： \u003c!--在build中配置resources，来防止我们资源导出失败的问题--\u003e \u003cbuild\u003e \u003cresources\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/resources\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003c/resource\u003e \u003cresource\u003e \u003cdirectory\u003esrc/main/java\u003c/directory\u003e \u003cincludes\u003e \u003cinclude\u003e**/*.properties\u003c/include\u003e \u003cinclude\u003e**/*.xml\u003c/include\u003e \u003c/includes\u003e \u003cfiltering\u003etrue\u003c/filtering\u003e \u003c/resource\u003e \u003c/resources\u003e \u003c/build\u003e ","date":"2021-07-04","objectID":"/javaweb/:5:6","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6、Servlet ","date":"2021-07-04","objectID":"/javaweb/:6:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.1、HelloSevlet Servlet接口Sun公司有两个默认的实现类：HttpServlet，GenericServlet 构建一个普通的Maven项目，删掉里面的src目录，以后我们的学习就在这个项目里面建议Moudel； 这个空的工程就是Maven主工程 关于Maven父子工程的理解： 父项目中会有 \u003cmodules\u003e \u003cmodule\u003eservlet-01\u003c/module\u003e \u003c/modules\u003e 子项目会有 \u003cparent\u003e \u003cartifactId\u003ejavaweb-03-servlet\u003c/artifactId\u003e \u003cgroupId\u003ecom.clover\u003c/groupId\u003e \u003cversion\u003e1.0-SNAPSHOT\u003c/version\u003e \u003c/parent\u003e 父项目中的Jar包子项目可以直接使用，而子项目中的jar包父项目不可以使用 Maven环境优化 修改web.xml为最新版本（可以去tomcat中的webapps里面找到） 将Maven的结构搭建完整 编写一个Servlet程序 编写一个普通类 实现Servlet接口，这里我们直接继承HttpServlet public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { PrintWriter writer = resp.getWriter(); writer.print(\"Hello,Servlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 编写Servlet映射 为什么需要映射：我们写的是Java程序，但是要通过浏览器访问，而浏览器需要连接web服务器，所 有我们需要在web服务器中注册我们写的Servlet，还需要给他一个浏览器能够访问的路径； \u003c!--注册Servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003c!-- Servlet的请求路径--\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 配置tomcat 注意：配置项目的发布路径就可以了 启动测试 ","date":"2021-07-04","objectID":"/javaweb/:6:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.2、Servlet原理 Servlet是由Web服务器调用，web服务器在收到浏览器请求之后，会有如下操作： ","date":"2021-07-04","objectID":"/javaweb/:6:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.3、Mapping 一个Servlet请求可以指定一个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定多个映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello5\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 一个Servlet请求可以指定通用映射路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello\\*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 默认请求路径 \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 指定一些后缀或者前缀等等 \u003c!--可以自定义后缀实现请求映射 注意点：*前面不能加项目映射的路径 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e*.clover\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 优先级问题 指定了固有的映射路径优先级最高，如果找不到就会走默认的处理请求了 \u003c!--404--\u003e \u003cservlet\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ErrorServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eerror\u003c/servlet-name\u003e \u003curl-pattern\u003e/*\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 注意：在使用IDEA创建多个webapps工程时，在第二个运行可能会出现404找不到资源问题 这里是因为新创建的webapps文件上没有带蓝色点点,需要自己手动去加上，然后运行才会成功。 如若创建新的工程的pom.xml中没有parent那一行，重新创建即可 另外在创建新文件时应当先创建java跟resources两个文件夹，并且要标记，否则无法创建package ","date":"2021-07-04","objectID":"/javaweb/:6:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.4、ServletContext web容器在启动的时候，它会为每个web应用程序都创建一个对应的ServletContext对象，它代 表了当前的web应用； 1、共享数据 我在这个Servlet中保存的数据，可以在另外一个servlet中拿到 public class HelloServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { // this.getInitParameter() 初始化参数 很少用 // this.getServletConfig() Servlet参数 很少用 // this.getServletContext() Servlet上下文 ServletContext context = this.getServletContext(); String username = \"韋\"; context.setAttribute(\"username\",username);//将一个数据保存在了ServletContext中，名字为：username，值为：username System.out.println(\"hello\"); } } public class GetServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); String username = (String) context.getAttribute(\"username\"); //设置显示页面不乱码问题 resp.setContentType(\"text/html\"); resp.setCharacterEncoding(\"utf-8\"); resp.getWriter().print(\"名字为：\"+username); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.HelloServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003ehello\u003c/servlet-name\u003e \u003curl-pattern\u003e/hello2\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cservlet\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.GetServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003egetc\u003c/servlet-name\u003e \u003curl-pattern\u003e/getc\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 测试结果： 2、获取初始化参数 \u003ccontext-param\u003e \u003cparam-name\u003eurl\u003c/param-name\u003e \u003cparam-value\u003ejdbc:mysql//localhost:3306/mybatis\u003c/param-value\u003e \u003c/context-param\u003e \u003cservlet\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo03\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd3\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd3\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e public class ServletDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); //此处获取上下文对象，获取初始化参数对应web.xml中的context-param中的参数，当你访问这个路径的时候，页面进行跳转的时候，就会获取到该路径对应的值 String url = context.getInitParameter(\"url\"); resp.getWriter().print(url); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 3、请求转发 public class ServletDemo04 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { ServletContext context = this.getServletContext(); System.out.println(\"进入demo4\"); // RequestDispatcher requestDispatcher = context.getRequestDispatcher(\"/sd3\");//转发的请求路径 // requestDispatcher.forward(req,resp);//调用forward实现转发请求 context.getRequestDispatcher(\"/sd3\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ServletDemo04\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003esd4\u003c/servlet-name\u003e \u003curl-pattern\u003e/sd4\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 4、读取资源文件 Properties 在Java目录下新建一个properties 在resources目录下新建一个properties 发现：都打包到了同一个路径下：classes；我们俗称这个路径为classpath 思路：需要一个文件流 username=root password=123456 public class ServletDemo05 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream is = this.getServletContext().getResourceAsStream(\"/WEB-INF/classes/db.properties\"); Properties properties = new Properties(); properties.load(is); String user = properties.getProperty(\"username\"); String pwd = properties.getProperty(\"password\"); resp.getWriter().print(user+\":\"+pwd); } @Override protected void doPost(HttpServletRequest req, HttpServl","date":"2021-07-04","objectID":"/javaweb/:6:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.5、HttpServletResponse web服务器接受到客户端的http请求，针对这个请求，分别创建一个代表请求的 HttpServletRequest对 象，代表一个响应的HttpServletResponse； 如果要获取客户端请求过来的参数：找HttpServletRequest 如果要给客户端响应一些信息：找HttpServletResponse 1、简单分类 负责向浏览器发送数据的方法 ServletOutputStream getOutputStream() throws IOException; PrintWriter getWriter() throws IOException; 负责向浏览器发送响应头的方法 void setCharacterEncoding(String var1); void setContentLength(int var1); void setContentLengthLong(long var1); void setContentType(String var1); void addDateHeader(String var1, long var2); void setHeader(String var1, String var2); void addHeader(String var1, String var2); void setIntHeader(String var1, int var2); void addIntHeader(String var1, int var2); 2、常见应用 向浏览器输出消息 下载文件 要获取下载文件的路径 下载的文件名时什么？ 想办法让浏览器能够支持下载我们需要的东西 获取下载文件的输入流 创建缓冲区 获取OutputStream对象 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ public class FileServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //1. 要获取下载文件的路径 String realPath = \"G:\\\\IDEADocument\\\\javaweb\\\\javaweb-03-servlet\\\\response\\\\target\\\\classes\\\\韋.png\"; System.out.println(\"下载文件的路径：\"+realPath); //2. 下载的文件名时什么？如果有/则需要进行转义 String fileName = realPath.substring(realPath.lastIndexOf(\"\\\\\") + 1); //3. 想办法让浏览器能够支持下载我们需要的东西,下载我们需要的东西，中文文件名，则使用URLEncoder.encode编码，否则有可能乱码 resp.setHeader(\"Content-Disposition\",\"attachment;filename=\"+ URLEncoder.encode(fileName,\"UTF-8\")); //4. 获取下载文件的输入流 FileInputStream in = new FileInputStream(realPath); //5. 创建缓冲区 int len = 0; byte[] buffer = new byte[1024]; //6. 获取OutputStream对象 ServletOutputStream out = resp.getOutputStream(); //7. 将FileOutputStream流写入到buffer缓冲区 使用OutputStream将缓冲区中的数据输出到客户端！ while((len = in.read(buffer))\u003e0){ out.write(buffer,0,len); } in.close(); out.close(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 注意：如果图片采用中文名字命名，则需要将其转化，使用URLEncoder.encoder编码，有可能会乱码 3、验证码功能 验证怎么来的？ 前端实现 后端实现，需要用到Java的图片类，生成一个图片 public class ImageServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //如何让一个浏览器3秒自动刷新一次 resp.setHeader(\"refresh\",\"3\"); //在内存中创建一个图片 BufferedImage image = new BufferedImage(80, 20, BufferedImage.TYPE_INT_RGB); //得到图片 Graphics2D g = (Graphics2D) image.getGraphics();//笔 //设置图片的背景颜色 g.setColor(Color.white); g.fillRect(0,0,80,20); //给图片写数据 g.setColor(Color.red); g.setFont(new Font(null,Font.BOLD,20)); g.drawString(makeNum(),0,20); //告诉浏览器，这个请求用图片的方式打开 resp.setContentType(\"image/jpeg\"); //网站存在缓存，不让浏览器缓存 resp.setDateHeader(\"expires\",-1); resp.setHeader(\"Cache-Control\",\"no-cache\"); resp.setHeader(\"Pragma\",\"no-cache\"); //把图片写给浏览器 ImageIO.write(image,\"jpg\",resp.getOutputStream()); } //生成随机数 private String makeNum(){ Random random = new Random(); String num = random.nextInt(999999) + \"\"; StringBuffer sb = new StringBuffer(); //如果num产生的长度为4，这里就让其空下来的地方填充0，保证其数字长度为6 for (int i = 0; i \u003c6 - num.length() ; i++) { sb.append(\"0\"); } num = sb.toString() + num; return num; } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } \u003cservlet\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.clover.servlet.ImageServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eimage\u003c/servlet-name\u003e \u003curl-pattern\u003e/img\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 关于expries一些简单的简介：https://www.jianshu.com/p/f331d5f0b979 4、实现重定向 B一个web资源收到客户端A请求后，B它会通知A客户端去访问另外一个web资源C，这个过程叫重定向 常见场景： 用户登录 void sendRedirect(String var1) throws IOException; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //重定向 /* resp.setHeader(\"Location\",\"/r/img\"); resp.setStatus(302); * */ resp.sendRedirect(\"/r/img\"); } \u003cbody\u003e \u003ch2\u003eHello World!\u003c/h2\u003e \u003c%--这里提交的路径，需要寻找到项目的路径--%\u003e \u003c%--${pageContext.request.contextPath()}代表当前项目的路径--%\u003e \u003cform action=\"${pageContext.req","date":"2021-07-04","objectID":"/javaweb/:6:5","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"6.6、HttpServletRequest HttpServletRequest代表客户端的请求，用户通过Http协议访问服务器，HTTP请求中的所有信息会被封装 到HttpServletRequest，通过这个HttpServletRequest的方法，获得客户端的所有信息 1、获取参数,请求转发 //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); 注意：如果这里使用`/`它会默认的找不到路径资源，因为这里的`/`就代表着当前的web应用 重定向的时候需要写全路径 而转发的时候时不需要写全路径的 \u003ch1\u003e登录\u003c/h1\u003e \u003cdiv\u003e \u003c%-- 这里表单表示的依视：以post方式提交表单，提交到我们的login请求--%\u003e \u003cform action=\"${pageContext.request.contextPath}/login\" method=\"post\"\u003e 用户名：\u003cinput type=\"text\" name=\"username\"\u003e\u003cbr\u003e 密码：\u003cinput type=\"password\" name=\"password\"\u003e\u003cbr\u003e 爱好： \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"女孩\"\u003e女孩 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"代码\"\u003e代码 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"唱歌\"\u003e唱歌 \u003cinput type=\"checkbox\" name=\"hobbys\" value=\"电影\"\u003e电影 \u003cbr\u003e \u003cinput type=\"submit\"\u003e \u003c/form\u003e \u003c/div\u003e public class LoginServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); String username = req.getParameter(\"username\"); String password = req.getParameter(\"password\"); String[] hobbys = req.getParameterValues(\"hobbys\"); System.out.println(\"====================\"); //后台接受中文乱码问题 System.out.println(username); System.out.println(password); System.out.println(Arrays.toString(hobbys)); System.out.println(\"====================\"); System.out.println(req.getContextPath()); //通过请求转发 //这里的 / 代表当前的web应用 req.getRequestDispatcher(\"/r/success.jsp\").forward(req,resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ","date":"2021-07-04","objectID":"/javaweb/:6:6","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7、Cookie、Session ","date":"2021-07-04","objectID":"/javaweb/:7:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.1、会话 会话：用户打开一个浏览器，点击了很多超链接，访问web资源，关闭浏览器，这个过程可以称之为会话 有状态会话： 一个同学来过教室，下次再来教室，我们会指定这个同学，曾经来过，称之为有状态会话 一个网站怎么证明你来过？ 客户端（自己） 服务端（网站） 服务端给客户端一个信件，客户端下次访问服务端带上信件就可以了；cookie 服务器登记你来过了，下次你来的时候我来匹配你；session ","date":"2021-07-04","objectID":"/javaweb/:7:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.2、保存会话的两种技术 cookie 客户端技术（响应，请求） session 服务器技术，利用这个技术，可以保存用户的会话信息？我们可以把信息或者数据存放在session中！ 常见例子：网站登录之后，你下次就不用在登录了，可以直接进去 ","date":"2021-07-04","objectID":"/javaweb/:7:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.3、Cookie 注意：使用谷歌浏览器解决浏览器显示中文乱码，要多设置一个resp.setContentType(\"text/html;charset=utf-8\"); 从请求中拿到cookie信息 服务器响应给客户端cookie Cookie[] cookies = req.getCookies();//获得cookie cookie.getName();//获得cookie中的key cookie.getValue();//获得cookie中的value new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\");//新建一个cookie loginTime.setMaxAge(24*60*60);//设置cookie的有效期 resp.addCookie(loginTime);//响应给客户端一个cookie 数据之间的转化 //获取cookie中的值![[Pasted image 20210608115423.png]] cookie.getValue(); //将cookie中的值转化为Long型 long lastLoginTime = Long.parseLong(cookie.getValue()); //以时间格式显示 Date date = new Date(lastLoginTime); //以字符串的形式输出 out.write(date.toLocaleString()); cookie：一般会保存在本地的用户目录下的AppData 一个网站的cookie是否存在上限！ 一个cookie只能保存一个信息 一个web站点可以给浏览器发送多个cookie，最多存放20个cookie cookie大小有限制4kb 300个cookie浏览器上限 删除Cookie 不设置有效期，关闭浏览器，自动失效 设置有效期为0 public class CookieDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //创建一个Cookie，名字必须要和删除的名字一致 Cookie cookie = new Cookie(\"lastLoginTime\", System.currentTimeMillis() + \"\"); //设置Cookie的有效期为0，立马过期 cookie.setMaxAge(0); //给客户端响应一个cookie resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 传递中文数据的时候，可能会出现乱码 所以可以采用编码、解码 URLEncoder.encode(\"韋\",\"utf-8\") URLDecoder.decode(cookie.getValue(),\"utf-8\") ","date":"2021-07-04","objectID":"/javaweb/:7:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"7.4、Session（重点） 什么是Session： 服务器会给每一个用户（浏览器）创建一个Session对象； 一个Session独占一个浏览器，只要浏览器没有关闭，这个Session就存在； 用户登录之后，整个网站它都可以访问！－－＞保存用户的信息；保存购物车的信息．．．．．． Session和Cookie的区别： Cookie是把用户的数据写给用户的浏览器，浏览器保存（可以保存多个） Session把用户的数据写到用户独占Session中，服务器端保存（保存重要的信息，减少服务器资源的浪费 Session对象由服务器创建 使用场景： 保存一个登录用户的信息 购物车信息 在整个网站中经常会使用的数据，我们将它保存在Session中 //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); resp.addCookie(cookie); Session是在网页一打开就会创建并且一直存在，就算你关闭了网页他也会存在，除非你手动删除 使用Session： package com.clover.servlet; import com.clover.pojo.Person; import javax.servlet.ServletException; import javax.servlet.http.*; import java.io.IOException; public class SessionDemo01 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); //给Session中存放东西 session.setAttribute(\"name\",new Person(\"韋\",1)); //获取Session的ID String sessionId = session.getId(); //判断Session是不是新创建的 if(session.isNew()){ resp.getWriter().write(\"session创建成功，ID：\"+sessionId); }else { resp.getWriter().write(\"session已经在服务器中存在了，ID：\"+sessionId); } //Session创建的时候做了什么事情 /* 1.把获取到的sessionId存放到Cookie中去 2.在响应给服务器 * */ // Cookie cookie = new Cookie(\"JSESSIONID\",sessionId); // resp.addCookie(cookie); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } --------------------------------------------------------- 获取对象中的值 public class SessionDemo02 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决中文乱码问题 req.setCharacterEncoding(\"utf-8\"); resp.setCharacterEncoding(\"utf-8\"); resp.setContentType(\"text/html;charset=utf-8\"); //得到Session HttpSession session = req.getSession(); Person name = (Person) session.getAttribute(\"name\"); System.out.println(name); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } ----------------------------------------------------------- 手动注销session public class SessionDemo03 extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { HttpSession session = req.getSession(); //取消刚刚获取的name session.removeAttribute(\"name\"); //并且注销掉该session，注销后立马生成新的sessionId，手动注销Session session.invalidate(); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { doGet(req, resp); } } 会话自动过期：web.xml中配置 \u003c!--设置session默认失效时间--\u003e \u003csession-config\u003e \u003c!--1分钟后session自动失效，以分钟为单位--\u003e \u003csession-timeout\u003e1\u003c/session-timeout\u003e \u003c/session-config\u003e ","date":"2021-07-04","objectID":"/javaweb/:7:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8、JSP ","date":"2021-07-04","objectID":"/javaweb/:8:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.1、什么是JSP Java Server Pages ：Java服务器端页面，也和Servlet一样，用于动态Web技术 最大的特点： 写JSP就像在写HTML 区别： HTML只给用户提供静态的数据 JSP页面中可以嵌入JAVA代码，为用户提供动态数据 ","date":"2021-07-04","objectID":"/javaweb/:8:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.2、JSP原理 思路：JSP到底是怎么执行的？ 代码层面没有任何问题 服务器内部工作 tomcat有一个work目录 IDEA中使用Tomcat会在IDEA的tomcat中产生一个work目录 我电脑的地址： C:\\Users\\REN\\.IntelliJIdea2019.3\\system\\tomcat\\Tomcat_9_0_411_javaweb-session-cookie\\work\\Catalina\\localhost\\ROOT\\org\\apache\\jsp 发现页面转变成了Java程序！ 浏览器向服务器发送请求，不管访问什么资源，其实都是在访问Servlet JSP最终也会被转换成为一个Java类！ JSP本质上就是一个Servlet //初始化 public void _jspInit() { } //销毁 public void _jspDestroy() { } //JSPServlet public void _jspService(HttpServletRequest request, HttpServletResponse response) 判断请求 内置一些对象 final javax.servlet.jsp.PageContext pageContext; //页面上下文 javax.servlet.http.HttpSession session = null; //session final javax.servlet.ServletContext application; //applicationContext final javax.servlet.ServletConfig config; //配置 javax.servlet.jsp.JspWriter out = null; //输出对象 final java.lang.Object page = this; //当前页 HttpServletRequest request //请求 HttpServletResponse response //响应 输出页面前增加的代码 response.setContentType(\"text/html\"); //设置响应的页面类型 pageContext = _jspxFactory.getPageContext(this, request, response, null, true, 8192, true); _jspx_page_context = pageContext; application = pageContext.getServletContext(); config = pageContext.getServletConfig(); session = pageContext.getSession(); out = pageContext.getOut(); _jspx_out = out; 以上的这些个对象，我们可以在JSP页面中直接使用 在JSP页面中；只要是JAVA代码就会原封不动的输出；如果是HTML代码就会被转化为： out.write(\"\u003chtml\u003e\\n\"); 这样的格式，输出到前端！ ","date":"2021-07-04","objectID":"/javaweb/:8:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.3、JSP基础语法 JSP表达式 \u003c%-- JSP表达式 作用：用来将程序的输出，输出到客户端 \u003c%= 变量或者表达式%\u003e --%\u003e \u003c%= new java.util.Date()%\u003e JSP脚本片段 \u003c%-- jsp脚本片段--%\u003e \u003c% int sum = 0; for (int i = 1; i \u003c= 100; i++) { sum+=i; } out.println(\"\u003ch1\u003eSum=\"+sum+\"\u003c/h1\u003e\"); %\u003e 脚本片段的再实现 \u003c% int x = 10; out.println(x); %\u003e \u003cp\u003e这是一个JSP文档\u003c/p\u003e \u003c% int y = 20; out.println(x); out.println(y); %\u003e \u003c%-- 在代码中嵌入HTML元素--%\u003e \u003c% for (int i = 0; i \u003c 5; i++) { %\u003e \u003ch1\u003ehello,world\u003c%= i%\u003e\u003c/h1\u003e \u003c% } %\u003e JSP声明 \u003c%! static { System.out.println(\"Loading servlet\"); } private int globalvar = 0; public void clover(){ System.out.println(\"进入了clover方法\"); } %\u003e 注意：这里使用的\u003c\u003e里面有一个感叹号存在 JSP声明：会被编译到JSP生成的Java类中！其他的，就会被生成到_jspService方法中！ JSP的注释，不会在客户端显示，HTML就会！ ","date":"2021-07-04","objectID":"/javaweb/:8:3","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.4、JSP指令 \u003c%@page args......%\u003e \u003c%@include file=\"\"%\u003e \u003c%--@include会将两个页面合二为一--%\u003e \u003c%@include file=\"common/header.jsp\"%\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003c%@include file=\"common/footer.jsp\"%\u003e \u003chr\u003e \u003c%--jsp标签 jsp:include：拼接页面，本质上还是三个 --%\u003e \u003cjsp:include page=\"/common/header.jsp\"/\u003e \u003ch1\u003e网页主体\u003c/h1\u003e \u003cjsp:include page=\"/common/footer.jsp\"/\u003e 注意：使用 jsp:include，其中的page代表当web页面，所以需要在common前面加一个/ 而两者也是有区别，使用@include，如果同时定义一个名字相同的变量，则会报错 使用 jsp:include则不会报错 ","date":"2021-07-04","objectID":"/javaweb/:8:4","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.5、九大内置对象 PageContext 存东西 Request 存东西 Response Session 存东西 Application 【ServletContext】存东西 config 【ServletConfig】 out page exception 在pageContextDemo01中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--内置对象--%\u003e \u003c% pageContext.setAttribute(\"name1\",\"clover一号\");//保存的数据只在一个页面中有效 request.setAttribute(\"name2\",\"clover二号\");//保存的数据只在一次请求中有效，请求转发会携带这个数据 session.setAttribute(\"name3\",\"clover三号\");//保存的数据只在一次会话中有效，从打开浏览器到关闭浏览器 application.setAttribute(\"name4\",\"clover四号\");//保存的数据只在服务器中有效，从打开服务器到关闭服务器 %\u003e \u003c%--脚本片段中的代码，会被原封不动生成到.JSP.java 要求：这里面的代码，必须保证Java语法的正确性 --%\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）:page--\u003erequest--\u003esession--\u003eapplication String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 2.在pageContextDemo02中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% //从pageContext取出，我们通过寻找的方式来 //从底层到高层（作用域）: String name1 = (String) pageContext.findAttribute(\"name1\"); String name2 = (String) pageContext.findAttribute(\"name2\"); String name3 = (String) pageContext.findAttribute(\"name3\"); String name4 = (String) pageContext.findAttribute(\"name4\"); String name5 = (String) pageContext.findAttribute(\"name5\"); %\u003e \u003c%--使用EL表达式输出 ${} --%\u003e \u003ch1\u003e取出的值为：\u003c/h1\u003e \u003ch3\u003e${name1}\u003c/h3\u003e \u003ch3\u003e${name2}\u003c/h3\u003e \u003ch3\u003e${name3}\u003c/h3\u003e \u003ch3\u003e${name4}\u003c/h3\u003e \u003ch3\u003e\u003c%=name5%\u003e\u003c/h3\u003e \u003c/body\u003e \u003c/html\u003e 这里由于时在另外一个页面访问，也没有请求转发，所以一号与二号就消亡了 测试结果： 3.在pageContextDemo03中测试 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% pageContext.forward(\"/index.jsp\"); //就相当于执行了request.getRequestDispatcher(\"/index.jsp\").forward(request,response); %\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： request：客户端向服务器发送请求，产生的数据，用户看完就没用了，比如：新闻，用户看完没用了的！ session：客户端向服务器发送请求，产生的数据，用户用完一会还有用，比如：购物车 application：客户端向服务器发送请求，产生的数据，一个用户用完了，其它用户还可能使用，比如：聊天数据 ","date":"2021-07-04","objectID":"/javaweb/:8:5","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"8.6、JSP标签、JSTL标签，EL表达式 所需依赖 \u003cdependency\u003e \u003cgroupId\u003ejavax.servlet.jsp.jstl\u003c/groupId\u003e \u003cartifactId\u003ejstl-api\u003c/artifactId\u003e \u003cversion\u003e1.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003etaglibs\u003c/groupId\u003e \u003cartifactId\u003estandard\u003c/artifactId\u003e \u003cversion\u003e1.1.2\u003c/version\u003e \u003c/dependency\u003e EL表达式：${} 获取数据 执行运算 获取web开发常用对象 JSP标签 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--jsp:include--%\u003e \u003c%-- http://localhost:8080/jsptag.jsp?name=clover$age=3 --%\u003e \u003cjsp:forward page=\"jsptag2.jsp\"\u003e \u003cjsp:param name=\"name\" value=\"clover\"/\u003e \u003cjsp:param name=\"age\" value=\"3\"/\u003e \u003c/jsp:forward\u003e \u003c/body\u003e \u003c/html\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--取出参数--%\u003e 名字：\u003c%=request.getParameter(\"name\")%\u003e 年龄：\u003c%=request.getParameter(\"age\")%\u003e \u003c/body\u003e \u003c/html\u003e 测试结果： JSTL表达式 JSTL标签库的使用就是为了弥补HTML标签的不足，它自定义许多标签，可以供我们使用，标签的功能和Java代码一样 核心标签（掌握部分） JSTL标签使用步骤 引入对应的taglib 使用其中的方法 注意：在Tomcat也需要引入jstl的包，否则会报错，JSTL解析错误 \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003ch4\u003eif测试\u003c/h4\u003e \u003chr\u003e \u003cform action=\"coreif.jsp\" method=\"get\"\u003e \u003c%-- EL表达式获取表单中的数据 ${param.参数名} --%\u003e \u003cinput type=\"text\" name=\"username\" value=\"${param.username}\"\u003e \u003cinput type=\"submit\" value=\"登录\"\u003e \u003c/form\u003e \u003c%--判断如果提交的用户名是管理员，则登录成功--%\u003e \u003cc:if test=\"${param.username=='admin'}\" var=\"isAdmin\"\u003e \u003cc:out value=\"管理员欢迎您！\"/\u003e \u003c/c:if\u003e \u003c%--自闭和标签--%\u003e \u003cc:out value=\"${isAdmin}\"/\u003e \u003c/body\u003e \u003c/html\u003e 登录账户不为admin时的结果： 登录账户为admin时的结果： corechoose 与 corewhen \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c%--定义一个变量score，值为85--%\u003e \u003cc:set var=\"score\" value=\"90\"/\u003e \u003cc:choose\u003e \u003cc:when test=\"${score\u003e=90}\"\u003e 你的成绩为优秀 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=80}\"\u003e 你的成绩为良好 \u003c/c:when\u003e \u003cc:when test=\"${score\u003e=70}\"\u003e 你的成绩为一般 \u003c/c:when\u003e \u003cc:when test=\"${score\u003c=60}\"\u003e 你的成绩为不及格 \u003c/c:when\u003e \u003c/c:choose\u003e \u003c/body\u003e \u003c/html\u003e 注意：如果有一个值满足多个条件，它会按照顺序去执行 coreforeach \u003c%@ page import=\"java.util.ArrayList\" %\u003e \u003c%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %\u003e \u003c%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %\u003e \u003chtml\u003e \u003chead\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003c% ArrayList\u003cString\u003e people = new ArrayList\u003c\u003e(); people.add(0,\"张三\"); people.add(1,\"李四\"); people.add(2,\"王五\"); people.add(3,\"张六\"); people.add(4,\"田七\"); request.setAttribute(\"list\",people); %\u003e \u003c%-- var,每一次遍历出来的变量 item，要遍历的对象 begin，从哪开始 end，到哪结束 step，每一次执行的步长 --%\u003e \u003cc:forEach var=\"people\" items=\"${list}\"\u003e \u003cc:out value=\"${people}\"/\u003e\u003cbr\u003e \u003c/c:forEach\u003e \u003cbr\u003e \u003cc:forEach var=\"people\" items=\"${list}\" begin=\"1\" end=\"3\" step=\"2\"\u003e \u003cc:out value=\"${people}\" /\u003e \u003c/c:forEach\u003e \u003c/body\u003e \u003c/html\u003e 使用了begin end 变量后的情况 ","date":"2021-07-04","objectID":"/javaweb/:8:6","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"9、JavaBean JavaBean有特定的写法： 必须要有一个无参构造 属性必须私有化 必须有对应的get/set方法 一般用来和数据库的字段做映射 ORM：对象关系映射 ","date":"2021-07-04","objectID":"/javaweb/:9:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10、MVC三层架构 ","date":"2021-07-04","objectID":"/javaweb/:10:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.1、原来的操作模式 用户直接访问控制层，控制层就可以直接操作数据库 servlet---CRUD---数据库 弊端：程序十分臃肿，不利于维护（在servlet中加入了处理jdbc的代码） Servlet的代码中：处理请求、响应、视图跳转、处理JDBC、处理业务代码、处理逻辑代码 架构思想：没有什么是加一层解决不了的！ ","date":"2021-07-04","objectID":"/javaweb/:10:1","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"10.2、MVC三层架构 Model 业务处理：业务逻辑（Service） 数据持久层：CRUD（Dao） View 展示数据 提供连接发起Servlet请求 Controller 接受用户的请求：（req：请求参数、session信息） 交给业务层处理对应的代码 控制视图的跳转 登录---\u003e接受用户的登录请求---\u003e处理用户的请求（获取用户登录的参数，username，password）---\u003e交给业务层处理登录业务（判断用户名密码是否正确：事务）---\u003eDao层查询用户名和密码是否正确---\u003e数据库 ","date":"2021-07-04","objectID":"/javaweb/:10:2","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"11、Filter（重点） Filter：过滤器，用来过滤网站的数据 处理中文乱码 登录验证 Filter开发步骤： 导包 编写过滤器 导包不能导入错误 编写过滤器，实现Filter接口，重写对应的方法 package com.clover.filter; import javax.servlet.*; import java.io.IOException; public class CharacterEncodingFilter implements Filter { //初始化：web服务器启动，就已经初始化了，随时等待过滤对象出现！ @Override public void init(FilterConfig filterConfig) throws ServletException { System.out.println(\"CharacterEncodingFilter初始化\"); } //Chain：链 /* * 1.过滤器中的所有代码，再过滤特定请求的时候都会执行 * 2.必须要让过滤器继续执行（因为可能存在多个过滤器，所以要继续执行下去） * */ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { request.setCharacterEncoding(\"UTF-8\"); response.setCharacterEncoding(\"UTF-8\"); response.setContentType(\"text/html;charset=utf-8\"); System.out.println(\"CharacterEncodingFilter执行前.........\"); chain.doFilter(request,response);//让我们的请求继续走，如果不屑，程序执行到这里就会被拦截停止！ System.out.println(\"CharacterEncodingFilter执行后.........\"); } //销毁 @Override public void destroy() { System.out.println(\"CharacterEncodingFilter销毁\"); } } 3.编写web.xml配置Filter \u003cfilter\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003cfilter-class\u003ecom.clover.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eCharacterEncodingFilter\u003c/filter-name\u003e \u003c!-- 只要是 /servlet下的任何请求，都会经过这个过滤器--\u003e \u003curl-pattern\u003e/servlet/*\u003c/url-pattern\u003e \u003c/filter-mapping\u003e ","date":"2021-07-04","objectID":"/javaweb/:11:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"12、监听器 编写一个监听器 实现一个监听器的接口 package com.clover.listener; import javax.servlet.ServletContext; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; public class OnlineCountListener implements HttpSessionListener { //创建session监听：查看你的一举一动 //一旦创建Session就会出发一次这个事件！ @Override public void sessionCreated(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count+1); } context.setAttribute(\"OnlineCount\",onlineCount); } //销毁Session监听 //一旦销毁Session就会出发一次这个事件！ @Override public void sessionDestroyed(HttpSessionEvent se) { ServletContext context = se.getSession().getServletContext(); Integer onlineCount = (Integer) context.getAttribute(\"OnlineCount\"); if(onlineCount == null){ onlineCount = new Integer(1); }else { int count = onlineCount.intValue(); onlineCount = new Integer(count-1); } context.setAttribute(\"OnlineCount\",onlineCount); } /* * 销毁session有两种方法 *1.自动销毁 getSession().invalidate(); *2.手动销毁 在web.xml中设置session存活时间 */ } 在web.xml中注册监听器 \u003c!--注册监听器--\u003e \u003clistener\u003e \u003clistener-class\u003ecom.clover.listener.OnlineCountListener\u003c/listener-class\u003e \u003c/listener\u003e ","date":"2021-07-04","objectID":"/javaweb/:12:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["JavaWeb"],"content":"13、过滤器、监听器常见应用 ","date":"2021-07-04","objectID":"/javaweb/:13:0","tags":["JavaWeb"],"title":"Javaweb","uri":"/javaweb/"},{"categories":["Thread"],"content":"Thread","date":"2021-07-04","objectID":"/thread/","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程简介 ","date":"2021-07-04","objectID":"/thread/:1:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Process：进程 程序是指令和数据的有效集合，其本身没有任何运行的含义，是一个静态的概念。而进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位。一个进程中可以包含若干个线程，当然一个进程中最少包含一个线程。线程是CPU调度和执行的单位。 ","date":"2021-07-04","objectID":"/thread/:1:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Thread：线程 ","date":"2021-07-04","objectID":"/thread/:1:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"两条线程是同时、交替执行的 注意，线程开启不一定立即执行，由CPU调度执行 ","date":"2021-07-04","objectID":"/thread/:1:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"方法一：继承Thread类，重写run()方法，调用start开启线程 package com.ren.lesson01; //创建线程方式一：继承Thread类，重写run()方法，调用start开启线程 //总结：注意，线程开启不一定立即执行，由CPU调度执行 public class TestThread01 extends Thread{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //main线程，主线程 //创建一个线程对象 TestThread01 testThread01 = new TestThread01(); //调用start()方法开启线程 testThread01.start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： 从网络上下载图片，通过一个下载器方法实现 package com.ren.lesson01; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; public class TestThread02 extends Thread { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestThread02(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public void run() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); } public static void main(String[] args) { TestThread02 t1 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestThread02 t2 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestThread02 t3 = new TestThread02(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //这三个不是按照顺序来执行的，是同时进行，小的先完成 t1.start(); t2.start(); t3.start(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } 小结： ","date":"2021-07-04","objectID":"/thread/:1:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 package com.ren.lesson01; //创建线程方式二：实现runnable接口，重写run方法，执行线程需要丢入runnable接口实现类，调用start方法。 public class TestThread03 implements Runnable{ @Override public void run() { //run方法线程体 for (int i = 0; i \u003c 200; i++) { System.out.println(\"我去打篮球了---\"+i); } } public static void main(String[] args) { //创建runnable接口的实现类对象 TestThread03 testThread03 = new TestThread03(); //创建线程对象，通过线程对象来开启我们的线程，代理 // Thread thread = new Thread(testThread03); // // thread.start(); new Thread(testThread03).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"我准备出门了---\"+i); } } } 结果图： package com.ren.lesson01; //多个线程同时操作同一个对象 //买火车票的例子 //发现问题：多个线程操作同一个资源的情况下，线程不安全，数据紊乱 public class TestThread04 implements Runnable{ //票数 private int ticketNums = 10; @Override public void run() { while (true){ if(ticketNums\u003c=0){ break; } //模拟延时 try { Thread.sleep(200); } catch (InterruptedException e) { e.printStackTrace(); } //Thread.currentThread().getName()获取当前线程的名称 System.out.println(Thread.currentThread().getName()+\"--\u003e拿到了第\"+ticketNums--+\"票\"); } } public static void main(String[] args) { TestThread04 ticket = new TestThread04(); new Thread(ticket,\"你\").start(); new Thread(ticket,\"我\").start(); new Thread(ticket,\"他\").start(); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程创建方式三：实现Callable接口 package com.ren.lesson02; import com.ren.lesson01.TestThread02; import org.apache.commons.io.FileUtils; import java.io.File; import java.io.IOException; import java.net.URL; import java.util.concurrent.*; //线程创建方式三：实现Callable接口 /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ public class TestCallable implements Callable\u003cBoolean\u003e { private String url; //网络图片保存地址 private String name; //保存的文件名 public TestCallable(String url,String name){ this.url = url; this.name = name; } //下载图片线程的执行体 @Override public Boolean call() { WebDownloader webDownloader = new WebDownloader(); webDownloader.Downloader(url,name); System.out.println(\"下载的文件名为：\"+name); return true; } public static void main(String[] args) throws ExecutionException, InterruptedException { TestCallable t1 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/1.jpg\",\"1.jpg\"); TestCallable t2 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/2.jpg\",\"2.jpg\"); TestCallable t3 = new TestCallable(\"https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X2pwZy9QbjRTbTBSc0F1Z1g0WFJ2ODZpYTZRR0NXVjdGOG5taWJmS0hDRmhhZk4wa2IxRXlCbUh4MmliNThqd0hQWnlydUpSd2hpYVNZM0ppYXptY2liRlB5b2R2cU9pYUEvNjQw?x-oss-process=image/3.jpg\",\"3.jpg\"); //创建执行服务 ExecutorService ser = Executors.newFixedThreadPool(3); //提交执行(通过服务来提交我们的线程) Future\u003cBoolean\u003e r1 = ser.submit(t1); Future\u003cBoolean\u003e r2 = ser.submit(t2); Future\u003cBoolean\u003e r3 = ser.submit(t3); //获取结果（获取的结果就是线程调用了call函数所返回的结果） Boolean rs1 = r1.get(); Boolean rs2 = r1.get(); Boolean rs3 = r1.get(); System.out.println(rs1); System.out.println(rs2); System.out.println(rs3); //关闭服务 ser.shutdownNow(); } } //下载器 class WebDownloader{ public void Downloader(String url,String name){ try { FileUtils.copyURLToFile(new URL(url),new File(name)); } catch (IOException e) { e.printStackTrace(); System.out.println(\"IO异常,Downloader方法出现异常\"+name); } } } /** * callable的好处： * 1.可以定义返回值 * 2.可以抛出异常 * 不好处：实现方式复杂些 */ 结果图： ","date":"2021-07-04","objectID":"/thread/:1:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"静态代理 使用结婚这个例子来阐述，可以将其与线程进行比较 package com.ren.lesson02; /** * 静态代理模式总结： * 真实对象（目标对象）和代理对象都要实现同一个接口 * 代理对象要代理真实角色 * 好处：代理对象可以做很多真实对象做不了的事情 * 真实对象专注做自己的事情 */ public class StaticProxy { public static void main(String[] args) { You you = new You(); //将其与多线程对比 /** * Thread就相当于WeddingCompany * Thread是一个代理，它代理的是他括号里面的真实对象（Runnable接口） * HappyMarry是来自于它的接口中的（代理对象中的），start是Thread里面去弄的，它们都有一个共同的方法，run方法 */ new Thread(()-\u003e System.out.println(\"我爱你\")).start(); new WeddingCompany(you).HappyMarry(); } } interface Marry{ void HappyMarry(); } //真实角色，你去结婚 class You implements Marry{ @Override public void HappyMarry() { System.out.println(\"我要结婚了！\"); } } //代理角色，帮助你结婚 class WeddingCompany implements Marry{ //代理谁--\u003e真实目标角色 private Marry target; public WeddingCompany(Marry target) { this.target = target; } @Override public void HappyMarry() { before(); this.target.HappyMarry();//这就是真实对象 after(); } private void after() { System.out.println(\"结婚之后，收尾款\"); } private void before() { System.out.println(\"结婚之前，布置现场\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:1:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lamda表达式 ","date":"2021-07-04","objectID":"/thread/:2:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"函数式接口的定义： 任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口 对于函数式接口，我们可以通过lamda表达式来创建该接口的对象 一步步的简化过程 package com.ren.lesson02; /** * 推导lamda表达式 */ public class TestLambda { //3.静态内部类 static class Like2 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda2\"); } } public static void main(String[] args) { ILike like = new Like(); like.lamda(); like = new Like2(); like.lamda(); //4.局部内部类 class Like3 implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda3\"); } } like = new Like3(); like.lamda(); //5.匿名内部类,没有类的名称，必须借助接口或者父类 like = new ILike() { @Override public void lamda() { System.out.println(\"i like lamda4\"); } }; like.lamda(); //3.用lamda简化 like = ()-\u003e{ System.out.println(\"i like lamda5\"); }; like.lamda(); } } //1.定义一个函数式接口 interface ILike{ void lamda(); } //2.实现类 class Like implements ILike{ @Override public void lamda() { System.out.println(\"i like lamda\"); } } 实例过程 package com.ren.lesson02; public class TestLamda2 { public static void main(String[] args) { //lamda表达式简化 ILove love = (int a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化1.去掉参数类型 love = (a)-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化2.去掉括号 love = a-\u003e { System.out.println(\"i love you--\u003e\"+a); }; //简化3.去掉花括号 love = a-\u003e System.out.println(\"i love you--\u003e\"+a); /** * 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 */ love.love(8); } } interface ILove{ void love(int a); } 总结： * lamda表达式只能有一行代码的情况下才能简化成为一行（也就是去掉花括号），如果有多行，那么就用代码块包裹。 * 前提是接口为函数式接口 * 多个参数也可以去掉参数类型，要去掉就都去掉，必须加上括号 ","date":"2021-07-04","objectID":"/thread/:2:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程五大状态 ","date":"2021-07-04","objectID":"/thread/:3:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程方法 ","date":"2021-07-04","objectID":"/thread/:3:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不涉及到多个线程操作一个对象可以直接继承Thread，涉及道路就采用继承Runnable接口 ","date":"2021-07-04","objectID":"/thread/:4:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程停止 package com.ren.lesson03; /** * 测试stop(停止线程) * 1.建议使用线程正常停止---\u003e利用次数，不建议死循环 * 2.建议使用标志位---\u003e设置一个标志位 * 3.不要使用stop或者destory等过时或者JDK不建议使用的方法 */ public class TestStop implements Runnable{ //1.设置一个标识位 private boolean flag = true; @Override public void run() { int i = 0; while(flag){ System.out.println(\"run......Thread\"+i++); } } //2.设置一个公开的方法停止线程，转换标志位 public void stop(){ this.flag = false; } public static void main(String[] args) { TestStop testStop = new TestStop(); new Thread(testStop).start(); for (int i = 0; i \u003c 1000; i++) { System.out.println(\"main\"+i); if(i==900){ //调用stop方法切换标志位，让线程停止 testStop.stop(); System.out.println(\"该线程停止了\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程休眠 package com.ren.lesson03; import java.text.SimpleDateFormat; import java.util.Date; //模拟倒计时 public class TestSleep2 { public static void main(String[] args) { //打印当前系统时间 Date startTime = new Date(System.currentTimeMillis());//获取系统当前时间 while(true){ try { Thread.sleep(1000); System.out.println(new SimpleDateFormat(\"HH:mm:ss\").format(startTime)); startTime = new Date(System.currentTimeMillis());//更新当前时间 } catch (InterruptedException e) { e.printStackTrace(); } } } //模拟倒计时 public static void tenDown() throws InterruptedException { int num = 10; while(true){ Thread.sleep(1000); System.out.println(num--); if(num\u003c=0){ break; } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程礼让 package com.ren.lesson03; /** * 测试礼让线程 * 礼让不一定成功，看CPU心情 */ public class TestYield { public static void main(String[] args) { MyYield myYield = new MyYield(); new Thread(myYield,\"a\").start(); new Thread(myYield,\"b\").start(); } } class MyYield implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"线程开始执行！\"); Thread.yield();//礼让 System.out.println(Thread.currentThread().getName()+\"线程停止执行！\"); } } 结果图： 注意：礼让有可能是成功的，也有可能礼让失败！！！ ","date":"2021-07-04","objectID":"/thread/:4:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程强制执行_Join Join合并线程，待此线程执行完成后，再执行其它线程，其它线程阻塞。可以想象成插队。 package com.ren.lesson03; //测试join方法，想象成插队 public class TestJoin implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 1000; i++) { System.out.println(\"线程VIP来了\"+i); } } public static void main(String[] args) throws InterruptedException { //启动我们的线程 TestJoin testJoin = new TestJoin(); Thread thread = new Thread(testJoin); //主线程 for (int i = 0; i \u003c 500; i++) { if(i==200){ thread.start(); thread.join();//插队 } System.out.println(\"main\"+i); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:4","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程状态观测 package com.ren.lesson03; //观察测试线程的状态 public class TestState { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-\u003e{ for (int i = 0; i \u003c 5; i++) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"//////\"); }); //观察状态 Thread.State state = thread.getState(); System.out.println(state);//New //观察启动后 thread.start();//启动线程 state = thread.getState(); System.out.println(state);//Run //只要线程不终止，就一直输出状态 while(state != Thread.State.TERMINATED){ Thread.sleep(100);//1秒运行十次 state = thread.getState();//线程状态的更新 System.out.println(state); } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:5","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程优先级 线程优先级越高，所获取的资源越多 优先级低只是意味着获得调度的概率低，并不是优先级低就不会被调用了，这都是看CPU的调度 package com.ren.lesson03; //测试线程的优先级 public class Testpriority { public static void main(String[] args) { //主线程默认优先级 System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); MyPriority myPriority = new MyPriority(); Thread t1 = new Thread(myPriority); Thread t2 = new Thread(myPriority); Thread t3 = new Thread(myPriority); Thread t4 = new Thread(myPriority); Thread t5 = new Thread(myPriority); Thread t6 = new Thread(myPriority); //先设置优先级，在启动 t1.start(); t2.setPriority(1); t2.start(); t3.setPriority(5); t3.start(); t4.setPriority(Thread.MAX_PRIORITY); t4.start(); // t5.setPriority(11); // t5.start(); // // t6.setPriority(-1); // t6.start(); } } class MyPriority implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()+\"--\u003e\"+Thread.currentThread().getPriority()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:6","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"守护线程 package com.ren.lesson03; //测试守护线程 public class TestDaemon { public static void main(String[] args) { God god = new God(); You you = new You(); Thread thread = new Thread(); thread.setDaemon(true);//默认是false表示的用户线程，正常的线程都是用户线程 thread.start();//上帝守护线程启动 new Thread(you).start();// 你 用户线程启动 } } class God implements Runnable{ @Override public void run() { while (true){ System.out.println(\"1111111111111111111111111\"); } } } class You implements Runnable{ @Override public void run() { for (int i = 0; i \u003c 36500; i++) { System.out.println(\"你一生都开心的活着！\"); } System.out.println(\"============goodbye world==============\"); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:4:7","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"线程同步机制 ","date":"2021-07-04","objectID":"/thread/:4:8","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"三大不安全案例 ","date":"2021-07-04","objectID":"/thread/:5:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"买票 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); } catch (InterruptedException e) { e.printStackTrace(); } } } private void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //模拟延时 放大问题的发生性 Thread.sleep(100); //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"取钱 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(100,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 @Override public void run() { //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"不安全的集合 package com.ren.lesson04; import java.util.ArrayList; import java.util.List; //线程不安全的集合 public class UnsafeList { public static void main(String[] args) { List\u003cString\u003e list = new ArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:5:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步方法 package com.ren.lesson04; //不安全的买票 //线程不安全，有负数 public class UnsafeBuyTicket { public static void main(String[] args) { BuyTicket station = new BuyTicket(); new Thread(station,\"A\").start(); new Thread(station,\"B\").start(); new Thread(station,\"C\").start(); } } class BuyTicket implements Runnable{ //票数 private int ticketNums = 10; //外部停止方式 boolean flag = true; @Override public void run() { //买票 while (flag){ try { buy(); //模拟延时 放大问题的发生性 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } } } //synchronized 同步方法，锁的是this private synchronized void buy() throws InterruptedException { //判断是否有票 if(ticketNums\u003c=0){ flag=false; return ; } //买票 System.out.println(Thread.currentThread().getName()+\"拿到\"+ticketNums--); } } ","date":"2021-07-04","objectID":"/thread/:6:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"同步块 package com.ren.lesson04; //不安全的取钱 //两个人去银行取钱，账户 public class UnsafeBank { public static void main(String[] args) { Account account = new Account(1000,\"结婚基金\"); Drawing you = new Drawing(account, 50,\"你\"); Drawing girlFriend = new Drawing(account, 100,\"girlFriend\"); you.start(); girlFriend.start(); } } class Account{ //余额 int money; //卡名 String name; public Account(int money, String name) { this.money = money; this.name = name; } } //银行：模拟取款 class Drawing extends Thread{ //账户 Account account; //取了多少钱 int drawingMoney; //现在手里有多少钱 int nowMoney; public Drawing(Account account,int drawingMoney,String name){ super(name); this.account = account; this.drawingMoney = drawingMoney; } //取钱 //synchronized 默认锁的是this @Override public void run() { //锁的对象就是变化的量，需要增、删、改的对象 synchronized (account){ //判断有没有钱 if(account.money-drawingMoney\u003c0){ System.out.println(Thread.currentThread().getName()+\"钱不够，取不了\"); return; } //延时，放大问题的发生性 try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //卡内余额 = 余额 - 你取的钱 account.money = account.money - drawingMoney; //你手上的钱 nowMoney = nowMoney + drawingMoney; System.out.println(account.name+\"余额为：\"+account.money); //Thread.currentThread().getName() 等价于 this.getName() 因为继承了Thread System.out.println(this.getName()+\"手里的钱：\"+nowMoney); } } } ","date":"2021-07-04","objectID":"/thread/:6:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"关键点： 结果图： ","date":"2021-07-04","objectID":"/thread/:6:3","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"CopyOnWriteArrayList package com.ren.lesson04; import java.util.concurrent.CopyOnWriteArrayList; public class TestJUC { public static void main(String[] args) { CopyOnWriteArrayList\u003cString\u003e list = new CopyOnWriteArrayList\u003c\u003e(); for (int i = 0; i \u003c 10000; i++) { new Thread(()-\u003e{ list.add(Thread.currentThread().getName()); }).start(); } try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } //打印是在主线程，操作list是在子线程，sleep是保证子线程执行完在执行主线程的打印 System.out.println(list.size()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:7:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁 ","date":"2021-07-04","objectID":"/thread/:8:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"死锁避免方法 package com.ren.lesson05; //死锁：多个线程互相抱着对方需要的资源，形成僵持 public class DeadLock { public static void main(String[] args) { Makeup g1 = new Makeup(0,\"灰姑凉\"); Makeup g2 = new Makeup(1,\"白雪公主\"); g1.start(); g2.start(); } } //口红 class Lipstick{ } //镜子 class Mirror{ } class Makeup extends Thread{ //需要的资源只有一份，用static来保证只有一份 static Lipstick lipstick = new Lipstick(); static Mirror mirror = new Mirror(); //选择 int choice; //使用化妆品的人 String girlName; public Makeup(int choice,String girlName){ this.choice = choice; this.girlName = girlName; } @Override public void run() { try { makeup(); } catch (InterruptedException e) { e.printStackTrace(); } } //化妆，互相持有对方的锁，就是需要拿到对方的资源 private void makeup() throws InterruptedException { if(choice == 0){ /** * 这个地方解决的方法就是不让其一个人抱着两个人的资源，将其写到外面来 */ synchronized (lipstick){//获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); Thread.sleep(1000); } synchronized (mirror){//一秒钟后想获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); } }else{ synchronized (mirror){//获得镜子的锁 System.out.println(this.girlName+\"获得镜子的锁\"); Thread.sleep(2000); } synchronized (lipstick){//两秒钟后想获得口红的锁 System.out.println(this.girlName+\"获得口红的锁\"); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:8:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"Lock ","date":"2021-07-04","objectID":"/thread/:9:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"synchronized与Lock的对比 package com.ren.lesson05; import java.util.concurrent.locks.ReentrantLock; public class TestLock { public static void main(String[] args) { TestLock2 testLock2 = new TestLock2(); new Thread(testLock2).start(); new Thread(testLock2).start(); new Thread(testLock2).start(); } } class TestLock2 implements Runnable{ int ticketNums = 10; //定义lock锁 private final ReentrantLock lock = new ReentrantLock(); @Override public void run() { while (true){ try{ //加锁 lock.lock(); if(ticketNums\u003e0){ try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(ticketNums--); }else{ break; } }finally { //解锁 lock.unlock(); } } } } 结果图： ","date":"2021-07-04","objectID":"/thread/:9:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"生产者消费者问题 ","date":"2021-07-04","objectID":"/thread/:10:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"管程法 package com.ren.lesson05; //测试：生产者消费者模型--\u003e利用缓冲区解决：管程法 //生产者， 消费者 ， 产品， 缓冲区 public class TestPC { public static void main(String[] args) { SynContainer container = new SynContainer(); new Productor(container).start(); new Consumer(container).start(); } } //生产者 class Productor extends Thread{ SynContainer container; public Productor(SynContainer container){ this.container = container; } //生产 @Override public void run() { for (int i = 0; i \u003c 100; i++) { container.push(new Chicken(i)); System.out.println(\"生产了第\"+i+\"只鸡\"); } } } //消费者 class Consumer extends Thread{ SynContainer container; public Consumer(SynContainer container){ this.container = container; } //消费 @Override public void run() { for (int i = 0; i \u003c 100; i++) { System.out.println(\"消费了第--\u003e\"+container.pop().id+\"只鸡\"); } } } //产品 class Chicken{ //产品编号 int id; public Chicken(int id) { this.id = id; } } //缓冲区 class SynContainer{ //需要一个容器大小 Chicken[] chickens = new Chicken[10]; //容器计数器 int count = 0; //生产者放入产品 public synchronized void push(Chicken chicken){ //如果容器满了，就需要等待消费者消费产品 if(count==chickens.length){ //通知消费者生产，生产者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果没有满，我们就需要丢入产品 chickens[count] = chicken; count++; //可以通知消费者消费了 this.notifyAll(); } //消费者消费产品 public synchronized Chicken pop(){ //判断能否消费 if(count == 0){ //等待生产者生产，消费者等待 try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } //如果可以消费 count--; Chicken chicken = chickens[count]; //吃完了，通知生产者生产 this.notifyAll(); return chicken; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:1","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"信号灯法 package com.ren.lesson05; //测试生产者消费者问题2：信号灯法，标志位解决 public class TestPC2 { public static void main(String[] args) { TV tv = new TV(); new Player(tv).start(); new Watcher(tv).start(); } } //生产者--\u003e演员 class Player extends Thread{ TV tv; public Player(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { if(i%2==0){ tv.play(\"快乐大本营播放中！\"); }else{ tv.play(\"抖音记录美好生活\"); } } } } //消费者--\u003e观众 class Watcher extends Thread{ TV tv; public Watcher(TV tv){ this.tv = tv; } @Override public void run() { for (int i = 0; i \u003c 20; i++) { tv.watch(); } } } //产品--\u003e节目 class TV{ //演员表演，观众等待 T //观众观看，演员等待 F //表演的节目 String voice; //标志位 boolean flag = true; //演员表演 public synchronized void play(String voice){ if(!flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"演员表演了：\"+voice); //通知观众观看 this.notifyAll();//通知唤醒 this.voice = voice; this.flag = !flag; } //观众观看 public synchronized void watch(){ if(flag){ try { this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.println(\"观众观看了：\"+voice); //通知演员表演 this.notifyAll(); this.flag = !flag; } } 结果图： ","date":"2021-07-04","objectID":"/thread/:10:2","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["Thread"],"content":"使用线程池 package com.ren.lesson05; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; //测试线程池 public class TestPool { public static void main(String[] args) { //1.创建服务，创建线程池 //newFixedThreadPool 参数为：线程池大小 ExecutorService service = Executors.newFixedThreadPool(10); //执行runnable的实现类 service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); service.execute(new MyThread()); //2.关闭连接 service.shutdown(); } } class MyThread implements Runnable{ @Override public void run() { System.out.println(Thread.currentThread().getName()); } } 结果图： ","date":"2021-07-04","objectID":"/thread/:11:0","tags":["Thread"],"title":"Thread","uri":"/thread/"},{"categories":["HTTP"],"content":"HTTP","date":"2021-07-04","objectID":"/http/","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"网络编程 ","date":"2021-07-04","objectID":"/http/:1:0","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.1、概述 计算机网络： 是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来，在网络操作系统，网络管理软件及网络通信协议下，实现资源共享和信息传递的计算机系统。 网络编程的目的： 无线电台…传播交流信息，数据交换，通信。 想要达到这个效果需要什么： 1、如何准确的定位网络上的一台主机 192.168.16.124：端口号，定位到这个计算机上的某个资源 2、找到了这个主机，如何传输数据呢？ javaweb：网页编程 B/S（架构） 网络编程：TCP/IP C/S（架构） ","date":"2021-07-04","objectID":"/http/:1:1","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.2、网络通信的要素 如何实现网络的通信？ 通信双方地址： ip 端口号 规则： 网络通信的协议 TCP/IP参考模型： 小结： 1. 网络编程中有两个主要的问题 - 如何准确的定位到网络上的一台或者多台主机 - 找到主机之后如何进行通信 2. 网络编程中的要素 - IP 和 端口号 ip的一些类 - 网络通信的协议 UDP和TCP的一些类 3. 万物皆对象 ","date":"2021-07-04","objectID":"/http/:1:2","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.3、IP ip地址：InetAddress 唯一定位一台网络上计算机 127.0.0.1：代表本机IP，英文名为localhost ip地址的分类 ipv4/ipv6 IPV4 == 127.0.0.1 由四个字节组成，每个字节长为0~255 IPV6 == fe80::141:5ede:c789:7a8a%12，128位，8个无符号整数！ 公网（互联网使用）和私网（局域网） ABCD类地址（了解一下，面试可能会出这种题） 192.168.xx.xx：专门给组织内部使用的 域名：记忆IP问题 IP：www.vip.com package com.ren.lesson01; import java.net.InetAddress; import java.net.UnknownHostException; //测试IP public class TestInetAddress { public static void main(String[] args) { try { //查询本机地址 InetAddress inetAddress1 = InetAddress.getByName(\"127.0.0.1\"); System.out.println(inetAddress1); //查询网址IP地址 InetAddress inetAddress2 = InetAddress.getByName(\"www.baidu.com\"); System.out.println(inetAddress2); InetAddress inetAddress3 = InetAddress.getByName(\"localhost\"); System.out.println(inetAddress3); InetAddress inetAddress4 = InetAddress.getLocalHost(); System.out.println(inetAddress4); //常用方法 System.out.println(inetAddress2.getAddress()); System.out.println(inetAddress2.getCanonicalHostName());//获取规范的名字 System.out.println(inetAddress2.getHostAddress());//获得主机名字 System.out.println(inetAddress2.getHostName());//获取域名，或者自己电脑的名称 } catch (UnknownHostException e) { e.printStackTrace(); } } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:3","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.4、端口 端口表示计算机上的一个程序的进程； 不同的进程有不同的端口号！用来区分软件！ 被规定0~65535 TCP，UDP：65535*2是最终值 单个协议下，端口号不能冲突。如TCP使用80，UDP也是可以使用80的 端口分类 公有端口0~1023 HTTP：80 HTTPS：443 FTP：21 SSH：22 Telent：23 程序注册端口：1024~49151，分配给用户或者程序 Tomcat ：8080 MySQL：3306 Oracle：1521 动态、私有端口：49152~65535 netstat -ano # 查看所有的端口 netstat -ano|findstr \"5900\" #查看指定的端口 tasklist|findstr \"8696\" #查看指定的端口的进程 package com.ren.lesson01; import java.net.InetSocketAddress; public class TestInetSocketAddress { public static void main(String[] args) { InetSocketAddress socketAddress = new InetSocketAddress(\"127.0.0.1\", 8080); InetSocketAddress socketAddress2 = new InetSocketAddress(\"localhost\", 8080); System.out.println(socketAddress); System.out.println(socketAddress2); System.out.println(socketAddress.getAddress()); System.out.println(socketAddress.getHostName());//地址 System.out.println(socketAddress.getPort());//端口 } } 结果图： ","date":"2021-07-04","objectID":"/http/:1:4","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.5、通信协议 协议：约定，就好比我们现在说的是普通话。 网络通信协议 ：速率，传输码率，代码结构，传输控制…. 问题：非常的复杂？ 大事化小：分层！ TCP/IP协议簇 重要： TCP：用户传输协议 UDP：用户数据报协议（相当于写信，传出去就不管了） 出名的协议： TCP： IP：网络互连协议 TCP UDP对比 TCP：比作打电话 连接，稳定 三次握手， 四次挥手 //其原理跟这个对话很相似，理解这个对话之间的联系 最少需要三次，保证稳定连接 A： 你愁啥？ B： 瞅你咋地？ A： 干一场！ A： 我要走了！ B： 你真的要走了吗？ B： 你真的真的要走了吗？ A： 我真的要走了！ 客户端，服务端 传输完成，释放连接，效率低 UDP：比作发短信 不连接，不稳定 客户端，服务端：没有明确的界限 不管有没有准备好，都可以发给你… 类似于导弹 DDOS：洪水攻击！ （饱和式攻击） ","date":"2021-07-04","objectID":"/http/:1:5","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.6、 TCP 客户端 ​ 1、连接服务器，通过socket ​ 2、发送消息 package com.ren.lesson02; import java.io.IOException; import java.io.OutputStream; import java.net.InetAddress; import java.net.Socket; import java.net.UnknownHostException; //客户端 public class TcpClientDemo01 { public static void main(String[] args) { Socket socket = null; OutputStream os = null; try { //1.要知道服务器的地址 InetAddress serverIP = InetAddress.getByName(\"127.0.0.1\"); int port = 9999; //2.创建一个socket连接 socket = new Socket(serverIP, port); //3.发送消息 IO流 os = socket.getOutputStream(); os.write(\"欢迎来到篮球世界\".getBytes()); } catch (Exception e) { e.printStackTrace(); }finally { if(os!=null){ try { os.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!= null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } 服务器 ​ 1、建立服务的端口ServerSocket ​ 2、等待用户的连接，通过accept，它会返回咋们客户端的socket ​ 3、接受用户的消息 package com.ren.lesson02; import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.net.ServerSocket; import java.net.Socket; //服务端 public class TcpServerDemo01 { public static void main(String[] args){ ServerSocket serverSocket = null; Socket socket = null; InputStream is = null; ByteArrayOutputStream baos = null; try { //1.我得有一个地址 serverSocket = new ServerSocket(9999); //2.等待客户端连接过来 socket = serverSocket.accept(); //3. 读取客户的消息 is = socket.getInputStream(); /* * 基础不好时的写法 * byte[] buffer = new byte[1024]; * int len; * while((len = is.read(buffer))!= -1){ * String msg = new String(buffer,0,len); * System.out.println(msg); * } * */ //管道流 baos = new ByteArrayOutputStream(); byte[] buffer = new byte[1024]; int len; while((len = is.read(buffer))!= -1){ baos.write(buffer,0,len); } //将字节转化为字符 System.out.println(baos.toString()); } catch (IOException e) { e.printStackTrace(); }finally { //关闭资源 if(baos!= null){ try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } if (is!=null){ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } if(socket!=null){ try { socket.close(); } catch (IOException e) { e.printStackTrace(); } } if(serverSocket!= null){ try { serverSocket.close(); } catch (IOException e) { e.printStackTrace(); } } } } } ","date":"2021-07-04","objectID":"/http/:1:6","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"文件上传 服务器端 package com.ren.lesson02; import java.io.*; import java.net.ServerSocket; import java.net.Socket; public class TcpServerDemo02 { public static void main(String[] args) throws Exception { //1.创建服务 ServerSocket serverSocket = new ServerSocket(9000); //2.监听客户端的连接 Socket socket = serverSocket.accept();//阻塞式监听，会一直等待客户端连接 //3.获取输入流 InputStream is = socket.getInputStream(); //4.文件输出 FileOutputStream fos = new FileOutputStream(new File(\"receive.jpg\")); byte[] buffer = new byte[1024]; int len; while((len=is.read(buffer))!=-1){ fos.write(buffer,0,len); } //通知客户端我接受完毕了 OutputStream os = socket.getOutputStream(); os.write(\"我接收完毕了，你可以断开了\".getBytes()); //5.关闭资源 os.close(); fos.close(); is.close(); socket.close(); serverSocket.close(); } } 客户端 package com.ren.lesson02; import java.io.*; import java.net.InetAddress; import java.net.Socket; public class TcpClientDemo02 { public static void main(String[] args) throws Exception { //1.创建一个socket连接 Socket socket = new Socket(InetAddress.getByName(\"127.0.0.1\"),9000); //2.创建一个输出流 OutputStream os = socket.getOutputStream(); //3.读取文件 FileInputStream fis = new FileInputStream(new File(\"tx.jpg\")); //4.写出文件 byte[] buffer = new byte[1024]; int len; while((len=fis.read(buffer))!=-1){ os.write(buffer,0,len); } //通知服务器，我已经结束了 socket.shutdownOutput();//我已经传输完了 //确定服务器接收完毕，才能断开连接 InputStream inputStream = socket.getInputStream(); //String byte[] 管道流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buffer2 = new byte[1024]; int len2; while ((len2=inputStream.read(buffer2))!=-1){ baos.write(buffer2,0,len2); } System.out.println(baos.toString()); //5.关闭资源 baos.close(); inputStream.close(); fis.close(); os.close(); socket.close(); } } 结果图 ","date":"2021-07-04","objectID":"/http/:1:7","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"Tomcat 服务端 自定义 S Tomcat服务器 S 客户端 自定义 C 浏览器 B 所以这就是常说的C/S，B/S ","date":"2021-07-04","objectID":"/http/:1:8","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.7 、UDP 相当于发短信：不用连接，需要对方的地址！ 客户端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetAddress; //不需要连接服务器 public class UdpClientDemo01 { public static void main(String[] args) throws Exception { //1.建立一个Socket DatagramSocket socket = new DatagramSocket(); //2.建个包 String msg = \"你好啊，篮球\"; InetAddress localhost = InetAddress.getByName(\"localhost\"); int port = 9191; //发送的数据，数据的起始长度，要发送给谁 DatagramPacket packet = new DatagramPacket(msg.getBytes(),0,msg.getBytes().length,localhost,port); //3.发送包 socket.send(packet); //4.关闭数据 socket.close(); } } 服务端 package com.ren.lesson03; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; //还是要等待客户端的连接 public class UdpServerDemo01 { public static void main(String[] args) throws Exception { //开放端口 DatagramSocket socket = new DatagramSocket(9191); //接受数据包 byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, 0, buffer.length);//接收 socket.receive(packet);//阻塞接收 System.out.println(packet.getAddress().getHostAddress()); System.out.println(new String(packet.getData(),0,packet.getLength())); //关闭资源 socket.close(); } } 结果图： 循环发送消息 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; import java.net.SocketException; public class UdpSenderDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(8888); //准备数据：控制台读取 System.in BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); while (true){ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(\"localhost\", 6666)); socket.send(packet); if (data.equals(\"bye\")){ break; } } socket.close(); } } 循环接收消息 package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.SocketException; public class UdpReceiveDemo01 { public static void main(String[] args) throws Exception { DatagramSocket socket = new DatagramSocket(6666); while (true){ //准备接受包裹 byte[] container = new byte[1024]; DatagramPacket packet = new DatagramPacket(container, 0, container.length); socket.receive(packet);//阻塞式接受包裹 //断开连接 byte[] data = packet.getData(); String receiverData = new String(data, 0, data.length); System.out.println(receiverData); if(receiverData.equals(\"bye\")){ break; } } socket.close(); } } 结果图： 在线咨询：两个人都可以是发送方，也都是接收方！ 发送端：采用了线程方法 package com.ren.chat; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.DatagramPacket; import java.net.DatagramSocket; import java.net.InetSocketAddress; public class TalkSend implements Runnable { private int fromPort; private String toIP; private int toPort; DatagramSocket socket = null; BufferedReader reader = null; public TalkSend(int fromPort, String toIP, int toPort) { this.fromPort = fromPort; this.toIP = toIP; this.toPort = toPort; try{ socket = new DatagramSocket(fromPort); //准备数据：控制台读取 System.in reader = new BufferedReader(new InputStreamReader(System.in)); }catch (Exception e){ e.printStackTrace(); } } @Override public void run() { while (true){ try{ //读取控制台这一行的数据 String data = reader.readLine(); //将读取的数据转为字节 byte[] datas = data.getBytes(); DatagramPacket packet = new DatagramPacket(datas, 0, datas.length, new InetSocketAddress(toIP, toPort)); socket.send(packet); if (data.equals(\"bye\")){ break; } }catch (Exception e){ e.printStackTrace(); } } socket.close(); } } 接收端： package com.ren.chat; import java.net.DatagramPacket; import java.net.DatagramSocket; public class TalkReceive implements Runnable { DatagramSocket socket = null; private int port; private String msgFrom; public TalkReceive(int port,String msgFrom) { this.port = port; this.msgFrom = msgFrom; try{ socket = new DatagramSocket(port); }catch (Exception e){ e","date":"2021-07-04","objectID":"/http/:1:9","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["HTTP"],"content":"1.8、URL 统一资源定位符：定位资源的，定位互联网上的某一个资源 DNS叫域名解析 相当于把 www.baidu.com 解析成 xxx.xxx.xx.xx 的一个IP 协议：//ip地址：端口号/项目名/资源 ","date":"2021-07-04","objectID":"/http/:1:10","tags":["HTTP"],"title":"Http","uri":"/http/"},{"categories":["GUI"],"content":"GUI","date":"2021-07-04","objectID":"/gui/","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"GUI编程 ","date":"2021-07-04","objectID":"/gui/:0:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"1.简介 Gui的核心技术：Swing，AWT。 不流行的原因： 1.因为界面不美观 2.需要jre环境 ","date":"2021-07-04","objectID":"/gui/:1:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"为什么我们要学习？ 1. 是MVC架构的基础 2.可以写出自己心中一些想要的工具 3.工具时候，也可能需要维护swing界面，概率极小 4.了解MVC架构，了解监听 ","date":"2021-07-04","objectID":"/gui/:1:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.AWT ","date":"2021-07-04","objectID":"/gui/:2:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.1、AWT介绍 1.包含了很多类和接口！GUI：图形用户界面编程 2. 元素： 窗口，按钮，文本 3. java.awt包 ","date":"2021-07-04","objectID":"/gui/:2:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"2.2 、组件和容器 1.Frame package com.ren.lesson; import java.awt.*; //GUI第一个界面 public class TestFrame { public static void main(String[] args) { //Frame对象,看源码 Frame frame = new Frame(\"我的第一个Java图像界面窗口\"); //需要设置可见性 frame.setVisible(true); //设置窗口大小 frame.setSize(400,400); //设置背景颜色 frame.setBackground(new Color(85,150,68)); //弹出初始位置 frame.setLocation(200,200); //设置大小固定 frame.setResizable(false); } } 运行结果： 问题：发现窗口关闭不掉，停止Java运行！ 尝试回顾封装： package com.ren.lesson; import java.awt.*; public class TestFrame2 { public static void main(String[] args) { //展示多个窗口 MyFrame myFrame1 = new MyFrame(100,100,200,200,Color.BLACK); MyFrame myFrame2 = new MyFrame(300,100,200,200,Color.PINK); MyFrame myFrame3 = new MyFrame(100,300,200,200,Color.yellow); MyFrame myFrame4 = new MyFrame(300,300,200,200,Color.orange); } } class MyFrame extends Frame { static int id = 0;//可能存在多个窗口，我们需要一个计数器 public MyFrame(int x, int y, int w, int h,Color color){ super(\"MyFrame\"+(++id)); setBackground(color); setBounds(x,y,w,h); setVisible(true); setResizable(false); } } 结果 2. 面板Pannel 解决了关闭窗口事件！ package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.awt.event.WindowListener; //Panel 可以看成是一个空间，但是不能单独存在 public class TestPanel { public static void main(String[] args) { Frame frame = new Frame(); //面板中存在一个布局的概念 Panel panel = new Panel(); //设置布局 frame.setLayout(null); //设置坐标 frame.setBounds(300,300,500,500); frame.setBackground(Color.GREEN); //panel设置坐标，相对于frame panel.setBounds(50,50,400,400); panel.setBackground(new Color(193, 14, 26)); //将面板添加到frame（窗口）中 frame.add(panel); frame.setVisible(true); //监听事件，监听窗口关闭事件 System.exit(0) //适配器模式： frame.addWindowListener(new WindowAdapter() { //点击关闭窗口的时候需要做的事情 @Override public void windowClosing(WindowEvent e) { //结束程序 System.exit(0); } }); } } 结果 3.布局管理器 流式布局 从左到右 package com.ren.lesson; import java.awt.*; public class TestFlowLayout { public static void main(String[] args) { Frame frame = new Frame(); //组件---按钮组件 Button button1 = new Button(\"button1\"); Button button2 = new Button(\"button2\"); Button button3 = new Button(\"button3\"); //设置为流式布局 //frame.setLayout(new FlowLayout()); //frame.setLayout(new FlowLayout(FlowLayout.LEFT)); frame.setLayout(new FlowLayout(FlowLayout.RIGHT)); frame.setSize(500,500); //把按钮添加上去 frame.add(button1); frame.add(button2); frame.add(button3); frame.setVisible(true); } } 东南西北中 上下结构 package com.ren.lesson; import java.awt.*; public class TestBorderLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestBorderLayout\"); Button east = new Button(\"East\"); Button west = new Button(\"West\"); Button south = new Button(\"South\"); Button north = new Button(\"North\"); Button center = new Button(\"Center\"); frame.add(east,BorderLayout.EAST); frame.add(west,BorderLayout.WEST); frame.add(south,BorderLayout.SOUTH); frame.add(north,BorderLayout.NORTH); frame.add(center,BorderLayout.CENTER); frame.setVisible(true); frame.setSize(400,400); } } 表格布局 三行两列布局 package com.ren.lesson; import java.awt.*; public class TestGridLayout { public static void main(String[] args) { Frame frame = new Frame(\"TestGridLayout\"); Button btn1 = new Button(\"btn1\"); Button btn2 = new Button(\"btn2\"); Button btn3 = new Button(\"btn3\"); Button btn4 = new Button(\"btn4\"); Button btn5 = new Button(\"btn5\"); Button btn6 = new Button(\"btn6\"); frame.setLayout(new GridLayout(3,2)); frame.add(btn1); frame.add(btn2); frame.add(btn3); frame.add(btn4); frame.add(btn5); frame.add(btn6); frame.pack();//这是一个Java函数，他会选择一个最优秀的布局。相当于自动布局，一般不用；这个可以不用设置大小，它会自动填充 frame.setVisible(true); } } 运行结果 练习题 分析及思路 ","date":"2021-07-04","objectID":"/gui/:2:2","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"切记，不要一开始就动手写代码，应当先分析 package com.ren.lesson; import java.awt.*; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class ExDemo { public static void main(String[] args) { //总的窗口 Frame frame = new Frame(); frame.setSize(500,500); frame.setLocation(300,400); frame.setBackground(Color.GREEN); frame.setLayout(new GridLayout(2,1)); frame.setVisible(true); //创建四个面板 Panel p1 = new Panel(new BorderLayout()); Panel p2 = new Panel(new GridLayout(2,1)); Panel p3 = new Panel(new BorderLayout()); Panel p4 = new Panel(new GridLayout(2,2)); //先处理上半部分 p1.add(new Button(\"East-1\"),BorderLayout.EAST); p1.add(new Button(\"West-1\"),BorderLayout.WEST); p2.add(new Button(\"p2-btn-1\")); p2.add(new Button(\"p2-btn-2\")); p1.add(p2,BorderLayout.CENTER); //在处理下半部分 p3.add(new Button(\"East-2\"),BorderLayout.EAST); p3.add(new Button(\"West-2\"),BorderLayout.WEST); for (int i = 0; i \u003c 4; i++) { p4.add(new Button(\"p4-btn-\"+(++i))); } p3.add(p4,BorderLayout.CENTER); //再将所有的面板加入总窗口中 frame.add(p1); frame.add(p3); //设置监听事件 frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } 结果图 ","date":"2021-07-04","objectID":"/gui/:2:3","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"总结： 1.Frame是一个顶级窗口 2.Panel无法单独显示，必须添加到某个容器中。 3. 布局管理器 1. 流式 2. 东南西北中 3. 表格 4. 大小，定位，背景颜色，可见性，监听！ 4. 事件监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.sql.SQLOutput; public class TestActionEvent { public static void main(String[] args) { //按下按钮，触发一些事件 Frame frame = new Frame(); Button button = new Button(\"test1\"); //因为，addActionListener()需要一个ActionListener，所以我们需要构造一个ActionListener button.addActionListener(new MyActionListener()); frame.add(button,BorderLayout.CENTER); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } //事件监听 class MyActionListener implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { System.out.println(\"aaa\"); } } 多个按钮共享一个事件 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; public class TestActionEventTwo { public static void main(String[] args) { //两个按钮实现同一个监听 Frame frame = new Frame(\"开始-停止\"); Button button1 = new Button(\"start\"); Button button2 = new Button(\"stop\"); //可以显示的定义触发会返回的命令，如果不显示的定义，则会走默认的的值！一般不怎么用 //可以多个按钮只写一个监听类 button2.setActionCommand(\"button-stop\"); MyMonitor myMonitor = new MyMonitor(); button1.addActionListener(myMonitor); button2.addActionListener(myMonitor); frame.add(button1,BorderLayout.NORTH); frame.add(button2,BorderLayout.SOUTH); frame.pack(); windowClose(frame); frame.setVisible(true); } //关闭窗口的事件 private static void windowClose(Frame frame){ frame.addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEvent e) { System.exit(0); } }); } } class MyMonitor implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { //e.getActionCommand() 获取按钮的信息 System.out.println(\"按钮被点击了：msg=\u003e\"+e.getActionCommand()); if(e.getActionCommand().equals(\"start\")){ } } } 5. 输入框TextField监听 package com.ren.lesson2; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; public class TestText01 { public static void main(String[] args) { //main方法只管启动 new MyFrame(); } } class MyFrame extends Frame{ public MyFrame(){ TextField textField = new TextField(); add(textField); //监听这个文本输入框的文字 MyActionListener2 myActionListener2 = new MyActionListener2(); //按下enter键就会触发这个输入框的事件 textField.addActionListener(myActionListener2); //设置替换编码 textField.setEchoChar('*'); setVisible(true); pack(); } } class MyActionListener2 implements ActionListener{ @Override public void actionPerformed(ActionEvent e) { TextField field = (TextField) e.getSource();//获取一些资源，返回的是一个对象 System.out.println(field.getText());//获取输入框的文本 field.setText(\"\");//按下回车后输入框清空 } } 6.简易计算器，组合+内部类回顾复习 oop原则：组合大于继承！ 目前代码 （面向过程） package com.ren.lesson2; /* * 1.先创建3个文本框 1个按钮 1个标签 （需要对按钮事件进行监听） * 2.在对上面的所创建的进行布局，并且添加到Frame框中 * 3.创建监听类对按钮事件进行监听，并且还需获取文本框中的参数 * 4.在进行计算机的计算 首现获取加数跟被加数 再将这个值加法运算后，放入第三个框 最后清除前两个框中内容 * */ import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; //简易计算机 public class TestCalc { public static void main(String[] args) { new Calculator(); } } class Calculator extends Frame{ public Calculator(){ //3 个文本框 TextField num1 = new TextField(10);//参数为文本框字符数 TextField num2 = new TextField(10);//参数为文本框字符数 TextField num3 = new TextField(20);//参数为文本框字符数 //1 个按钮 Button button = new Button(\"=\"); button.addActionListener(new MyCalculator(num1,num2,num3)); //1 个标签 Label label = new Label(\"+\"); //布局 setLayout(new FlowLayout()); add(num1); add(label); add(num2); add(button); add(num3); //关闭窗口事件 addWindowListener(new WindowAdapter() { @Override public void windowClosing(WindowEv","date":"2021-07-04","objectID":"/gui/:2:4","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"3.Swing 3.1、窗口、面板 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo { //init()初始化 public void init(){ JFrame jf = new JFrame(\"这是一个JFrame窗口\"); jf.setVisible(true); jf.setBounds(100,100,400,500); jf.setBackground(Color.GREEN); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); jf.add(jLabel); //容器实例化(窗口本身也是一个容器，我们要让这个窗口能看得到，所以对其进行实例化) //关闭事件 jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { //建议一个窗口 new JFrameDemo().init(); } } 标签居中 package com.ren.lesson04; import javax.swing.*; import java.awt.*; public class JFrameDemo02 { public static void main(String[] args) { new MyJFrame2().init(); } } class MyJFrame2 extends JFrame { public void init(){ this.setVisible(true); this.setBounds(10,10,400,500); //设置文字 Jlabel JLabel jLabel = new JLabel(\"欢迎来到篮球世界\"); this.add(jLabel); //让我们的文本标签居中 设置水平对齐 jLabel.setHorizontalAlignment(SwingConstants.CENTER); //获得一个容器（这个容器中的颜色才是它真正的颜色） Container container = this.getContentPane(); container.setBackground(Color.red); } } 3.2 、弹窗 JDialog 用来被弹出，默认就有关闭事件！ package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; //主窗口 public class DialogDemo extends JFrame { public DialogDemo() { this.setVisible(true); this.setSize(700,600); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); //JFrame 放东西，需要一个容器 Container container = this.getContentPane(); //绝对布局 container.setLayout(null); //创建按钮 JButton button = new JButton(\"点击弹出一个对话框\"); button.setBounds(30,30,200,50); //点击这个按钮的时候，弹出一个窗口 button.addActionListener(new ActionListener() { //监听器 @Override public void actionPerformed(ActionEvent e) { //显示弹窗 new MyDialogDemo(); } }); container.add(button); } public static void main(String[] args) { new DialogDemo(); } } class MyDialogDemo extends JDialog{ public MyDialogDemo() { this.setVisible(true); this.setBounds(200,200,300,300); Container container = this.getContentPane(); container.setLayout(null); JLabel label = new JLabel(\"欢迎来到篮球世界\"); container.add(label); } } 结果图： 3.3、标签 label new JLabel(\"xxxxx\"); 图标 ICON package com.ren.lesson04; import javax.swing.*; import java.awt.*; //图标是一个接口，需要实现类 public class IconDemo extends JFrame implements Icon { private int width; private int height; public IconDemo(){} public IconDemo(int width,int height){ this.width = width; this.height = height; } public void init(){ IconDemo iconDemo = new IconDemo(15,15); //图片放在标签上，也可以放在按钮上！ JLabel label = new JLabel(\"icontest\",iconDemo,SwingConstants.CENTER); Container container = getContentPane(); container.add(label); this.setVisible(true); this.setBounds(100,100,350,350); this.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); } public static void main(String[] args) { new IconDemo().init(); } @Override public void paintIcon(Component c, Graphics g, int x, int y) { g.fillOval(x,y,width,height); } @Override public int getIconWidth() { return width; } @Override public int getIconHeight() { return height; } } 结果图： 图片Icon package com.ren.lesson04; import javax.swing.*; import java.awt.*; import java.net.URL; public class ImageDemo extends JFrame { public ImageDemo() { //获取图片的地址 JLabel label = new JLabel(\"ImageIcon\"); //获取当前类目录下的资源 URL url = ImageDemo.class.getResource(\"tx.jpg\"); //将图片放到标签中(命名不要冲突了) ImageIcon imageIcon = new ImageIcon(url); label.setIcon(imageIcon); label.setHorizontalAlignment(SwingConstants.CENTER); Container container = getContentPane(); container.add(label); setVisible(true); setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE); setBounds(100,100,350,350); } public static void main(String[] args) { new ImageDemo(); } } 出现报错，空指针异常，为找出哪里异常！！！重新开启IDEA就好了 结果图： 3.4、面板 JPanel package com.ren.lesson05; import javax.swing.*; import java.awt.*; public class JPanelDemo extends JFrame { public JPanelDemo() { Container container = this.getContentPane(); container.setLayout(new GridLayout(2,1,10,10));//后面参数的意思是间距 JPanel panel1 = new JPanel(new Gr","date":"2021-07-04","objectID":"/gui/:3:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"贪吃蛇 帧： 如果时间片足够小，就是动画，一秒三十帧。连起来是动画，拆开就是静态的图片！ 键盘监听 定时器Timer ","date":"2021-07-04","objectID":"/gui/:4:0","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["GUI"],"content":"思路： 1、先创建一个主类，创建一个窗口设置其相关数据； 2、创建一个游戏面板类，游戏界面一般都在面板上，最后创建一个数据类 3、在游戏面板类中先对该游戏的一些数据进行定义，如蛇、食物、成绩、蛇的走向、游戏状态以及定时器；在再其构造函数中调用一个初始化函数（是对该游戏的一些数据进行初始化），并且获得两个监听事件以及一个定时器的启动 4、构建一个绘制面板，在其中绘画一些需要的文字，图片，图标、蛇、游戏状态等 5、重写一个键盘监听函数，对于需要键盘操作的事件都对其进行监听，对于其中的一些操作还需要用到重新绘制函数 6、重写一个事件监听函数，通过状态来判断是否要进行接下来的操作；有吃食物、蛇的移动、走向、失败的判断、重画页面以及最后的定时器启动 *重点：对于每一块数据的操作，如先是写出静态的蛇、图片、背景等操作，在让其动起来时可以按以下步骤操作 定义数据 画到面板上去 监听事件 键盘监听事件 事件监听 ","date":"2021-07-04","objectID":"/gui/:4:1","tags":["GUI"],"title":"GUI","uri":"/gui/"},{"categories":["Docker"],"content":"docker","date":"2021-07-04","objectID":"/docker/","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker ","date":"2021-07-04","objectID":"/docker/:1:0","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"参考资料 官方文档：https://docs.docker.com/docker-for-windows/ 【官方文档超级详细】 仓库地址：https://hub.docker.com/ 【发布到仓库，git pull push】 b站教程：https://www.bilibili.com/video/BV1og4y1q7M4? 【这个教程非常简洁！且深入！基于企业应用场景！推荐！以下笔记都基于该课程】 ","date":"2021-07-04","objectID":"/docker/:1:1","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"前期基础 linux基本命令，类似cd，mkdir等 ","date":"2021-07-04","objectID":"/docker/:1:2","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker概述 Docker为什么会出现 一款产品，开发和上线两套环境，应用环境配置费时费力，而且容易出问题，尤其 对于机器学习和深度学习的库更是如此，很可能存在版本问题、底层依赖冲突问题 所以发布项目时，不只是一套代码过去，而是代码+环境整体打包过去，所谓开发 即运维，保证系统稳定性，提高部署效率 使用Docker后的流程： 开发：建立模型–环境–打包带上环境，即镜像–放到Docker仓库 部署：下载Docker中的镜像，直接运行即可 Docker的思想来自于集装箱，集装箱，对环境进行隔离 Docker通过隔离机制，可以将服务器利用到极致。 Docker的历史 2010年，几个搞IT的人，在美国成立一家公司dotCloud，做一些pass的云计服 务，他们将自己的容器化技术命名为Docker，Docker基于Go语言开发，Docker刚 刚诞生的时候，没有引起行业的注意，dotCloud活不下去，然后他们决定开源 2013年，创始人将Docker开源，不开则以，一开惊人，刚开源的时候，每个月都 会更新一个版本，2014年4月9日，Docker 1.0发布 容器vs虚拟机 在容器技术出来之前，用的是虚拟机技术 虚拟机原理示意图 缺点： 资源占用多 冗余步骤多 启动很慢 容器化技术示意图 不是模拟的完整的操作系统 二者对比 比较虚拟机和Docker的不同 传统虚拟机 Docker 虚拟内容 硬件+完整的操作系统+软件 APP+LIB 大小 笨重，通常几个G 轻便几个M或KB 启动速度 慢，分钟级 快，秒级 ","date":"2021-07-04","objectID":"/docker/:1:3","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker安装 Docker的基本组成 明确几个概念： 镜像(image)：docker镜像好比一个模板，可以通过这个模板来创建容器(container)，一个镜像可以创建多个容器，类似Python中的Class 容器(container)：类似Python中通过Class创建的实例，Object；容器可以理解为一个简易的系统 仓库(repository)：存放镜像的地方， 分为公有仓库和私有仓库 Docker Hub：国外的 阿里云：配置镜像加速 环境准备 我们要有一台服务器，并且可以操作它 Linux命令基础，购买linux阿里云的服务器 CentOS 7 使用Xshell链接远程服务器 安装xshell 下载CentOS7 https://www.jianshu.com/p/a63f47e096e8 下载VMware 360软件管家下载 VMware配置虚拟机 https://blog.csdn.net/babyxue/article/details/80970526 xshell链接服务器 https://blog.csdn.net/zzy1078689276/article/details/77280814 [root@192 ~]# cd / [root@192 /]# pwd / [root@192 /]# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var [root@192 /]# uname -r 3.10.0-1127.el7.x86_64 用户名 密码 查看ip：vmware里面输入，ip addIPr https://www.bilibili.com/video/BV1og4y1q7M4?p=6 Centos安装 https://docs.docker.com/engine/install/centos/ 卸载旧的版本 # 卸载旧的版本 $ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 安装基本环境 # 安装基本的安装包 $ sudo yum install -y yum-utils 设置镜像的仓库 注意！！下载默认用国外的，太慢不要用！ 用国内镜像，百度搜索，docker的阿里云镜像地址 # 不要用官网默认这个！ $ sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo # 默认是国外的 # 换成下面的 $ sudo yum-config-manager \\ --add-repo \\ https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo # 阿里云镜像 直接复制粘贴就OK了 更新软件包索引 yum makecache fast 没有问题的话就是可以用的 安装docker引擎 yum install docker-ce docker-ce-cli containerd.io # docker-ce 社区版 ee 企业版 注意这里会有几个个y/n的判断 要看到Complet再收手！ 启动Docker systemctl start docker # 代表启动成功 docker version Client: Docker Engine - Community Version: 19.03.11 API version: 1.40 Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:13:48 2020 OS/Arch: linux/amd64 Experimental: false Server: Docker Engine - Community Engine: Version: 19.03.11 API version: 1.40 (minimum version 1.12) Go version: go1.13.10 Git commit: 42e35e61f3 Built: Mon Jun 1 09:12:26 2020 OS/Arch: linux/amd64 Experimental: false containerd: Version: 1.2.13 GitCommit: 7ad184331fa3e55e52b890ea95e65ba581ae3429 runc: Version: 1.0.0-rc10 GitCommit: dc9208a3303feef5b3839f4323d9beb36df0a9dd docker-init: Version: 0.18.0 GitCommit: fec3683 docker run hello-world 中间一堆是签名信息 run的运行流程图 查看下载的镜像 docker images 卸载Docker # 卸载依赖 yum remove docker-ce docker-ce-cli containerd.io # 删除资源 rm -rf /var/lib/docker # docker 的默认工作路径 阿里云镜像加速 支付宝扫码登录，短信验证，确认授权 我有两个问题 阿里云镜像加速必须配置嘛？ 哎呦我去: 加速快 哎呦我去: 要是翻墙就无所谓了 这个阿里云必须要买嘛，买哪个，我看阿里云好多产品 哎呦我去:不需要买 哎呦我去:免费的 哎呦我去:阿里云搜索容器服务 哎呦我去:有一个镜像加速 这个地址是哪来的呀 操作 控制台搜索 容器镜像服务 找到加速地址 sudo mkdir -p /etc/docker # 创建一个目录 sudo tee /etc/docker/daemon.json \u003c\u003c-'EOF' { \"registry-mirrors\": [\"https://uyfgafsw.mirror.aliyuncs.com\"] } EOF # 编写配置文件 sudo systemctl daemon-reload # 重启服务 sudo systemctl restart docker # 重启docker 在线画图软件ProcessOn 服务器及购买相关介绍 ","date":"2021-07-04","objectID":"/docker/:1:4","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"底层原理 Docker是怎么工作的？ Docker是一个Client-Server结构的系统，Docker的守护进程在主机上。通过Socket从客户端访问！ DockerServer接受到Docker-Client的指令， Docker为什么比VM快？ 1. Docker有着比虚拟机更少的抽象层 2. docker主要用的是宿主机的内核，vm需要Guest OS 所以说新建一个容器的时候，docker不需要像虚拟机一样重新加载一个操作系统内核，避免引导 ","date":"2021-07-04","objectID":"/docker/:1:5","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker命令 帮助命令 docker version # 显示docker的基本信息 docker info # 系统信息，镜像和容器的数量 docker 命令 --help # 全部信息 官网文档 镜像命令 docker images 查看所有本地主机上的镜像 [root@192 ~]# docker images # 解释 REPOSITORY # 镜像仓库源 TAG # 镜像的标签 IMAGE ID # 镜像的ID CREATED # 镜像的创建时间 SIZE # 镜像的大小 --all , -a Show all images (default hides intermediate images) # 显示所有 --digests Show digests --filter , -f Filter output based on conditions provided --format Pretty-print images using a Go template --no-trunc Don’t truncate output --quiet , -q Only show numeric IDs # 只显示id docker search 搜索仓库中的镜像，相当于网页搜索 网页搜索 mysql docker search mysql docker search --help # 解释 Options: -f, --filter filter Filter output based on conditions provided --format string Pretty-print search using a Go template --limit int Max number of search results (default 25) --no-trunc Don't truncate output docker search mysql --filter=STARS=3000 # 搜索出Stars大于3000的 docker pull 下载镜像 docker pull mysql # 下载mysql镜像，default tag，默认最新版latest [root@192 ~]# sudo systemctl daemon-reload [root@192 ~]# sudo systemctl restart docker [root@192 ~]# docker pull mysql Using default tag: latest # 不写tag默认最新版 latest: Pulling from library/mysql 8559a31e96f4: Pull complete # layer 分层下载，docker image的核心 联合文件系统 d51ce1c2e575: Pull complete c2344adc4858: Pull complete fcf3ceff18fc: Pull complete 16da0c38dc5b: Pull complete b905d1797e97: Pull complete 4b50d1c6b05c: Pull complete c75914a65ca2: Pull complete 1ae8042bdd09: Pull complete 453ac13c00a3: Pull complete 9e680cd72f08: Pull complete a6b5dc864b6c: Pull complete Digest: sha256:8b7b328a7ff6de46ef96bcf83af048cb00a1c86282bfca0cb119c84568b4caf6#签名 Status: Downloaded newer image for mysql:latest docker.io/library/mysql:latest # 真实地址 # 即 docker pull mysql # 等价于 docker pull docker.io/library/mysql:latest # 指定版本下载 docker pull mysql:5.7 版本来自于官网，版本库https://hub.docker.com/_/mysql docker images 此时查看镜像，可以看到新下载的两个 docker rmi remove images # 删除一个 可以通过名称 也可以指定id -f表示删除所有 docker rmi -f 9cfcce23593a # 删除多个 用空格分隔id docker rmi -f id id id # 删除所有 docker rmi -f $(docker images -aq) # images -aq就是查所有镜像id，从而递归删除 容器命令 说明：有了镜像才能创建容器，linux，下载一个centos镜像来测试学习 docker pull centos 新建容器并启动 docker run [可选参数] image # 参数说明 --name=“Name” # 容器名字，用于区分容器 -d 后台方式运行 -it 使用交互方式运行，进入容器查看内容 -p 指定容器的端口 如-p 8080::8080 -p ip:主机端口：容器端口 -p 主机端口:容器端口 -p 容器端口 -p 随机指定端口 进入退出容器 # 进入 docker run -it centos /bin/bash # 查看目录 ls # 退出 exit 注意这里面主机名，变成了centos的容器id 这里面就是一个容器，套娃啊 查看运行的容器 # 查看正在运行的容器 docker ps # 查看曾经运行的容器 docker ps -a # 显示最近创建的容器，设置显示个数 docker ps -a - n=? # 只显示容器的编号 docker ps -aq [root@192 ~]# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 4 minutes ago Exited (0) 4 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 8 minutes ago Exited (0) 4 minutes ago lucid_cannon a89ddb393d3d bf756fb1ae65 \"/hello\" 19 hours ago Exited (0) 19 hours ago gracious_bhabha [root@192 ~]# docker ps -a -n=2 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 9939864fa2e6 centos \"bin/bash\" 6 minutes ago Exited (0) 6 minutes ago unruffled_knuth 5f42e9930435 centos \"/bin/bash\" 10 minutes ago Exited (0) 7 minutes ago [root@192 ~]# docker ps -aq 9939864fa2e6 5f42e9930435 a89ddb393d3d 退出容器 # 容器停止退出 exit # 容器不停止退出 注意必须在英文输入法下，中文输入法不行 Ctrl + P + Q [root@192 ~]# docker run -it centos /bin/bash [root@bfcea13c40cd /]# [root@192 ~]# docker ps ##注意这里会自动给个命令，删掉 CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" About a minute ago Up About a minute stoic_wilson edbd9366d959 centos \"/bin/bash\" 7 minutes ago Up 7 minutes affectionate_bartik [root@192 ~]# docker exec -it edbd9366d959 /bin/bash ## 再次进入 [root@edbd9366d959 /]# exit ##停止并推出 exit 删除容器 # 删除指定容器 不能删除正在运行的容器，如果强制删除 rm -f docker rm 容器id # 删除所有容器 docker rm -f $(docker ps -aq) # 删除所有容器 docker ps -a -q|xargs docker rm [root@192 ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES bfcea13c40cd centos \"/bin/bash\" 29 minutes ago Up 29 minute","date":"2021-07-04","objectID":"/docker/:1:6","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker镜像 原理 UnionFS 联合文件系统 bootfs：boot file system rootfs：root file system Docker镜像都是只读的，当容器启动时，一个新的可写层被加到镜像的顶部，这一层就是我们通常说的容器层，容器层之下的都叫镜像层 commit提交镜像 docker commit # 提交容器成为一个新的副本 docker commit -m=\"提交的描述信息\" -a=\"作者\" 容器id 目标镜像名：[TAG] docker images docker run -it -p 8080:8080 tomcat 这是一个前台程序 将webapps.dist里面所有的文件拷贝到webapps里面，其中-r必须有，表示目录递归拷贝 docker commit -a=\"paidaxing\" -m=\"add webapps app\" 当前容器的id tomcat02:1.0 发现新的版本，比之前的大了一些，因为里面记录了我们的改动 如果想保存当前容器的状态，可以通过commit提交，获得一个镜像 好比我们以前学习VM的时候的快照 到这里算是入门了 接下来三个部分是docker的精髓 ","date":"2021-07-04","objectID":"/docker/:1:7","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"容器数据卷 什么是容器卷 docker是要将应用和环境打包成一个镜像，这样，数据就不应该在容器中，否则容 器删除，数据就会丢失，这就是删库跑路，故容器之间要有一个数据共享技术 在Docker容器中产生的数据，同步到本地，这就是卷技术，本质上是一个目录挂 载，将容器内的目录挂载到虚拟机上 目的： 容器的持久化和同步操作 容器间可以数据共享 使用数据卷 方式一：直接使用命令来挂载 docker run -it -v -p # -it 交互式进入 # -v volume卷技术 # -p 主机端口 新开一个窗口 docker inspect 容器id 找到挂载信息Mounts 测试 容器停止后，修改主机文件，再启动容器的时候，数据同样改变 双向同步 实战安装mysql MySQL的数据持久化命令 docker search mysql # 拉取 docker pull mysql:5.7 # 挂载 docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=xn123456 --name mysql mysql:5.7 -d 后台运行 -p 端口映射 -v 卷挂载 -e 环境配置 安装启动mysql需要配置密码 --name 容器名字 链接测试：打开SQLyog 点 测试链接 点 链接 具名和匿名挂载 使用DockerFile来构建docker镜像的文件 kas: 没有安装吧？ kas: 安装一下就可以了 py9001021曾叙坚: centos 默认使用vi写内容，vim需要下载 py9001021曾叙坚: 是的，需要下载vim才能使用 YF: 配置可以改下，字体就很炫酷了 都建民: 用vi 试试 都建民: 你没有安装vim 都建民: yum install vim 都建民: 试试这个命令 yum install vim # 编辑文件的，没有装一下 安装完之后就可以运行这个命令了 # 镜像是一层一层的，脚本是一行一行的 # 指令都是大写的 # 这里的每个命令可以理解为镜像的一层 FROM centos VOLUME [\"volume01\",\"volume02\"] # 再创建镜像的时候就挂载出来 CMD echo \"---end---\" CMD /bin/bash 想保存并退出 Wesley.: shift 加 冒号 cat dockerfile1 docker build -f dockerfile1 -t padaxing/centos:1.0 . # 最后的点很重要 镜像名前面不能有/ docker images 启动生成的镜像 在容器内部创建一个文件 查看Mounts，Source对应容器外目录，匿名挂载卷 测试一下，在container volume01下生成文件 在主机挂载路径下，也同样生成 多个容器数据共享 看一下有啥images 启动docker01，用之前建的padaxing/centos 1.0 镜像 docker run -it --name docker01 padaxing/centos:1.0 # 1.0必须写 当前这个ctrl+p+q不停止退出 依次启动docker02、docker03 docker run -it --name docker02 --volumes-from docker01 padaxing/centos:1.0 docker02继承docker01的volumes 可以验证，在docker01下加一个数据，在docker02下也会出现 创建docker03，同样继承docker01 docker run -it --name docker03 --volumes-from docker01 padaxing/centos:1.0 在docker03的volume01下建立文件，在docker01的volume01下同样也有 即通过–volumes-from 可以实现不同容器间的数据共享 删除docker01，数据还在 docker rm -f 可以看到，删除docker01，进入docker02，数据依然在 结论： 容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用位置 但是如果持久化到了本地，即使所有容器删除了，本地数据是不会删除的 ","date":"2021-07-04","objectID":"/docker/:1:8","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"DockerFile 是用来构建docker镜像的文件，可以理解为命令参数脚本 构建步骤： 编写一个dockerfile文件 docker build 构建成为一个镜像 docker run运行镜像 docker push 发布镜像（DockerHub、阿里云镜像仓库 私有/共有） 这个写一个项目时一样的 官方DockerFile示例 看一下官方的DockerFile 可以看到官方镜像都是基础包，很多功能没有，我们通常会自己搭建自己的镜像 官方既然可以制作镜像，我们亦可以 DockerFile基础知识 每个指令都必须是大写字母 按照从上到下顺序执行 # 表示注释 每一个指令都会创建体检一个新的镜像层，并提交 docker是面向开发的，我们以后要发布项目，做镜像，就要编写dockerfile文件，这个文件十分简单！ Docker镜像逐渐成为企业的交付标准，必须掌握！ DockerFile命令 DockerFile FROM # 基础镜像 比如centos MAINTAINER # 镜像是谁写的 姓名+邮箱 RUN # 镜像构建时需要运行的命令 ADD # 添加，比如添加一个tomcat压缩包 WORKDIR # 镜像的工作目录 VOLUME # 挂载的目录 EXPOSE # 指定暴露端口，跟-p一个道理 RUN # 最终要运行的 CMD # 指定这个容器启动的时候要运行的命令，只有最后一个会生效，而且可被替代 ENTRYPOINT # 指定这个容器启动的时候要运行的命令，可以追加命令 ONBUILD # 当构建一个被继承Dockerfile 这个时候运行ONBUILD指定，触发指令 COPY # 将文件拷贝到镜像中 ENV # 构建的时候设置环境变量 实战构建自己的centos Docker Hub中99%的镜像都是从FROM scratch开始的 添加centos7的压缩包 # 创建一个自己的centos # 进入home目录 cd /home # 创建一个目录，之后的东西都保存到这里 mkdir dockerfile # 进入这个目录 cd dockerfile/ # 创建一个dockerfile，名字叫mydockerfile vim mydockerfile-centos xshell新开一个界面 # 官方默认centos docker run -it centos pwd # 官方默认有pwd命令 vim # 官方默认没有vim命令 ifconfig # 官方默认没有ifconfig命令 回到mydockerfile # 下面给官方centos加上自定义的内容 FROM centos MAINTAINER padaxing\u003c010301200@hai.com\u003e ENV MYPATH /usr/local WORKDIR $MYPATH RUN yum -y install vim RUN yum -y install net-tools EXPOSE 80 CMD echo $MYPATH CMD echo \"---end---\" CMD /bin/bash ESC, shif + : 输入wq保存并退出 如果写错了需要修改、 vim mydockerfile-centos # 进入之后按i或者INSERT键即可修改 下面通过这个这个文件创建镜像 docker build -f dockerfile-centos -t mycentos:0.1 . 依次执行命令 最终返回Successfully表示成功 docker run -it mycentos:0.1 # 版本号必须写，不然他会去找最新的 pwd vim ifconfig 这时可以看到这些功能都有了 可以通过查看docker构建历史 可以看到当前这个镜像是怎么一步一步构建起来的 我们平时拿到一个镜像也可以通过这个方法研究一下他是怎么做的 CMD与ENTRYPOINT FROM centos CMD [\"ls\",\"-a\"] # 启动centos展示目录 测试ENTRYPOINT run的时候可以直接加命令 Docker中许多命令都十分相似，我们需要了解他们的区别，最好的方式就是这样对比测试 区别： CMD是直接产生了覆盖现象，想要在后面追加命令则需要输入被覆盖的命令加上要追加的命令；而entrypoint可以直接在后面追加命令不会产生覆盖现象 实战Tomcat镜像 准备镜像文件 tomcat压缩包，jdk压缩包 jdk压缩包 tomcat压缩包 编写dockerflie文件，官方命名Dockerfile，build会自动寻找这个文件，就不需要-f指定了 FROM centos MAINTAINER wei\u003c1186419584@qq.com\u003e COPY readme.txt /usr/local/readme.txt #将文件复制到容器里面的路径 ADD jdk-8u11-linux-x64.tar.gz /usr/local/ #将压缩包添加到容器中（使用add自动会帮你解压） ADD apache-tomcat-9.0.41.tar.gz /usr/local/ RUN yum -y install vim #安装vim命令 ENV MYPATH /usr/local #进去后就进入这个路径 WORKDIR $MYPATH #工作目录 ENV JAVA_HOME /usr/local/jdk1.8.0_11 #配置Java环境变量（Java安装目录） ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar #Java配置 ENV CATALINA_HOME /usr/local/apache-tomcat-9.0.41 #配置tomcat环境变量（tomcat默认的安装目录） ENV CATALINA_BASH /usr/local/apache-tomcat-9.0.41 #tomcat配置 ENV PATH $PATH:$JAVA_HOME/bin:$CATALINA_HOME/lib:$CATALINA_HOME/bin #将这些目录放入总的path中，$CATALINA_HOME/lib：tomcat的依赖，$CATALINA_HOME/bin启动tomcat就不需要进入bin目录了 EXPOSE 8080 #暴露端口 CMD /usr/local/apache-tomcat-9.0.41/bin/startup.sh \u0026\u0026 tail -F /url/local/apache-tomcat-9.0.41/bin/logs/catalina.out #执行tomcat后面是做一些参数，展示日志信息 3.运行镜像 docker build -t 镜像名 . 4.启动镜像 docker run -d -p 3345:8080 --name weitomcat02 -v /home/wei/build/tomcat/test:/usr/local/apache-tomcat-9.0.41/webapps/test -v /home/wei/build/tomcat/tomcatlogs/:/usr/local/apache-tomcat-9.0.41/logs divtomcat 5.访问测试 6.发布项目（由于做了卷挂载，我们直接在本地编写就可以发布了！） web.xml文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app version=\"2.4\" xmlns=\"http://java.sun.com/xml/ns/j2ee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd\"\u003e \u003c/web-app\u003e index.jsp文件 \u003c%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%\u003e \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e \u003cmeta charset=\"utf-8\"\u003e \u003ctitle\u003ehello,wei\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e Hello World!\u003cbr/\u003e \u003c% System.out.println(\"-------my test web logs-----------\"); %\u003e \u003c/body\u003e \u003c/html 发布自己的镜像 1、地址https://hub.docker.com/ 注册自己的账号 2、确定这个账号可以登录 3、在我们的服务器上提交自己的镜像 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker login --help Usage: docker login [OPTIONS] [SERVER] Log in to a Docker registry. If no server is specified, the default is defined by the daemon. Options: -p, --password string Password --password-stdin Take the ","date":"2021-07-04","objectID":"/docker/:1:9","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker网络 理解docker0 1、清空所有环境 测试 三个网络 # 问题： docker是如何处理容器访问网络的？ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 tomcat 运行一个tomcat # 查看容器的内部网络地址 ip addr， 发现容器启动的时候会得到一个eth0@if91 IP地址，docker分配的！ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat01 ip addr 1: lo: \u003cLOOPBACK,UP,LOWER_UP\u003e mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 90: eth0@if91: \u003cBROADCAST,MULTICAST,UP,LOWER_UP\u003e mtu 1500 qdisc noqueue state UP group default link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0 inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever # 思考：Linux能不能ping通容器内部？ [root@iZ2zejeormv0s24sdvazvxZ ~]# ping 172.17.0.2 PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data. 64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.085 ms 64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.067 ms 64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.070 ms 64 bytes from 172.17.0.2: icmp_seq=5 ttl=64 time=0.066 ms 64 bytes from 172.17.0.2: icmp_seq=6 ttl=64 time=0.091 ms 64 bytes from 172.17.0.2: icmp_seq=7 ttl=64 time=0.070 ms ^C --- 172.17.0.2 ping statistics --- 7 packets transmitted, 7 received, 0% packet loss, time 5999ms rtt min/avg/max/mdev = 0.066/0.074/0.091/0.010 ms # Linux可以ping通docker容器内部 原理 1、我们每启动一个docker容器，docker就会给docker容器分配一个IP，我们只要安装了docker，就会有一个网卡docker0，桥接模式，使用的技术是evth-pair技术 再次测试IP addr 2、再启动一个容器测试，发现又多了一对网卡 # 我们发现这个容器带来的网卡，都是一对对的 # evth-pair就是一对的虚拟设备接口，他们都是成对的出现，一端连接着协议，一端批次相连 # 正因为有这个特性，evth-pair 充当一个桥梁，连接各种虚拟网络设备的 # OpenStac，Docker容器之间的连接，OVS的连接，都是使用evth-pair 技术 3、我们来测试一下tomcat01 和 tomcat02是否可以ping通！ # [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping 172.17.0.2 # 结论： 容器和容器之间是可以互相ping通的！ 绘制一个网络模型图： 结论： tomcat01和tomcat02是共用一个路由器的，也就是我们的docker0 所有的容器在不指定网络的情况下，都是docker0路由的，docker会给我们的容器 分配一个默认的可用IP 小结： Docker使用的是Linux的桥接，宿主机中是一个docker容器的网桥 docker0 Docker中的所有的网络接口都是虚拟的，虚拟的转发效率高！ 只要容器删除，对应的网桥一对就没了 思考一个场景，我们编写了一个微服务，database url=ip:，项目不重启，数据库ip换掉了，我们希望可以解决这个问题，可以使用名字来进行访问容器？ 这里使用的是--link 技术 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat01 ping: tomcat01: Name or service not known # 如何解决呢？ # 通过--link 既可以解决了网络连通问题 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat 581a112c15d5f4de2634cb1027ff1d011a1c495b4e83a27ccd98784c17fce05f [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 ping tomcat02 PING tomcat02 (172.17.0.3) 56(84) bytes of data. 64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.126 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.102 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.106 ms 64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.096 ms # 反向可以ping通嘛？ [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat02 ping tomcat03 ping: tomcat03: Name or service not known 探究inspect： 其实这个tomcat03就是在本地配置了tomcat02的配置 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker exec -it tomcat03 cat /etc/hosts 127.0.0.1 localhost ::1 localhost ip6-localhost ip6-loopback fe00::0 ip6-localnet ff00::0 ip6-mcastprefix ff02::1 ip6-allnodes ff02::2 ip6-allrouters # 172.17.0.3 tomcat02 0303648ab9d4 172.17.0.4 581a112c15d5 本质探究：--link就是我们在hosts配置中增加了一个tomcat02的映射。172.17.0.3 tomcat02 0303648ab9d4 我们现在玩Docker已经不建议使用--link了！ 使用的都是自定义网络！不使用docker0！ docker0问题：它不支持容器名连接访问！ 自定义网络 查看所有的docker网络 网络模式 bridge： 桥接 就是在docker上搭桥（默认使用，自己创建也使用bridge） none： 不配置网络 host： 和宿主机共享网络 container： 容器网络连通！（用得少，局限很多） 测试 # 我们直接启动的命令 默认是有--net bridge，而这个就是我们的docker0 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker run -d -P --name tomcat01 --net bridge tomcat # docker0特点： 默认，域名不能访问，--link可以打通连接！ # 我们可以自定义一个网络！ # --driver bridge 连接模式 # --subnet 192.168.0.0/16 子网地址 # --gateway 192.168.0.1 网关 [root@iZ2zejeormv0s24sdvazvxZ ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 1","date":"2021-07-04","objectID":"/docker/:1:10","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"IDEA整合Docker ","date":"2021-07-04","objectID":"/docker/:1:11","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker 整合Docker ","date":"2021-07-04","objectID":"/docker/:1:12","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Compose ","date":"2021-07-04","objectID":"/docker/:1:13","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"Docker Swarm ","date":"2021-07-04","objectID":"/docker/:1:14","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Docker"],"content":"各种bug Xshell链接失败 Connecting to 192.168.147.131:22... Could not connect to '192.168.147.131' (port 22): Connection failed. 注：电脑休眠重启后，机子会断开，要重新在vmware里面输入ip addr 获得ip 修改xshell中的主机接口即可 ","date":"2021-07-04","objectID":"/docker/:1:15","tags":["Docker"],"title":"Docker","uri":"/docker/"},{"categories":["Ajax-Json"],"content":"Ajax-Json","date":"2021-07-04","objectID":"/ajax-json/","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"},{"categories":["Ajax-Json"],"content":"Json和Ajax 需要掌握的知识 早期网站：如登录功能，需要刷新页面，才能重新登录；不点击提交按钮，就不知道自己密码输错了； 现在大多数的网站，都是局部刷新，不刷新整个页面的情况下，实现更新； 注册的时候，发现手机已经注册过了，但是你只是输入了，没有提交，然后它就提示了 什么是Json 1、JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式，目前使用特别广泛。 2、采用完全独立于变成语言的文本格式来存储和表示数据。 3、简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。 4、易于人阅读和编写，同时也易于机器解析和生成，并有效地提升网络传输效率。 对象表示为键值对 数据由逗号分隔 花括号保存对象 方括号保存属组 JSON键值对是用来保存JavaScript对象的一种方式，和 JavaScript 对象的写法也大同小异，键–值对组合中的键名写在前面并用双引号 \"\" 包裹，使用冒号 : 分隔，然后紧接着值： {\"name\": \"clover\"} {\"age\": \"3\"} {\"sex\": \"男\"} 很多人搞不清楚 JSON 和 JavaScript 对象的关系，甚至连谁是谁都不清楚。其实，可以这么理解： JSON是JavaScript对象的字符串表示法，它使用文本表示一个JS对象的信息，本质是一个字符串 var obj = {a: 'Hello', b: 'World'}; //这是一个对象，注意键名也是可以使用引号包裹的 var json = '{\"a\": \"Hello\", \"b\": \"World\"}'; //这是一个 JSON 字符串，本质是一个字符串 JSON和 JavaScript对象互转 要实现从JSON字符串转换为JavaScript对象，使用JSON.parse()方法： var obj = JSON.parse('{\"a\": \"Hello\", \"b\": \"World\"}'); //结果是 {a: 'Hello', b: 'World'} 要实现从JavaScript 对象转换为JSON字符串，使用JSON.stringify() 方法： var json = JSON.stringify({a: 'Hello', b: 'World'}); //结果是 '{\"a\": \"Hello\", \"b\": \"World\"}' 代码测试： \u003c!DOCTYPE html\u003e \u003chtml lang=\"en\"\u003e \u003chead\u003e \u003cmeta charset=\"UTF-8\"\u003e \u003ctitle\u003eTitle\u003c/title\u003e \u003c/head\u003e \u003cbody\u003e \u003cscript type=\"text/javascript\"\u003e //编写一个对象 var user = { name: \"韋\", age: 3, sex: \"男\" }; console.log(user); //将js对象转化为json字符串 var str = JSON.stringify(user); console.log(str); //将json字符串转化为js兑现对象 var users = JSON.parse(str); console.log(users); \u003c/script\u003e \u003c/body\u003e \u003c/html\u003e 结果图： Controller控制层返回JSON数据 导入jackson所需要的包 \u003c!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-core --\u003e \u003cdependency\u003e \u003cgroupId\u003ecom.fasterxml.jackson.core\u003c/groupId\u003e \u003cartifactId\u003ejackson-databind\u003c/artifactId\u003e \u003cversion\u003e2.9.8\u003c/version\u003e \u003c/dependency\u003e 配置SpringMVC需要的配置web.xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cweb-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"\u003e \u003c!--1.注册servlet--\u003e \u003cservlet\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003cservlet-class\u003eorg.springframework.web.servlet.DispatcherServlet\u003c/servlet-class\u003e \u003c!--通过初始化参数指定SpringMVC配置文件的位置，进行关联--\u003e \u003cinit-param\u003e \u003cparam-name\u003econtextConfigLocation\u003c/param-name\u003e \u003cparam-value\u003eclasspath:springmvc-servlet.xml\u003c/param-value\u003e \u003c/init-param\u003e \u003c!-- 启动顺序，数字越小，启动越早 --\u003e \u003cload-on-startup\u003e1\u003c/load-on-startup\u003e \u003c/servlet\u003e \u003c!--所有请求都会被springmvc拦截 --\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eSpringMVC\u003c/servlet-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e \u003cfilter\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003cfilter-class\u003eorg.springframework.web.filter.CharacterEncodingFilter\u003c/filter-class\u003e \u003cinit-param\u003e \u003cparam-name\u003eencoding\u003c/param-name\u003e \u003cparam-value\u003eutf-8\u003c/param-value\u003e \u003c/init-param\u003e \u003c/filter\u003e \u003cfilter-mapping\u003e \u003cfilter-name\u003eencoding\u003c/filter-name\u003e \u003curl-pattern\u003e/\u003c/url-pattern\u003e \u003c/filter-mapping\u003e \u003c/web-app\u003e springmvc-servlet.xml \u003c?xml version=\"1.0\" encoding=\"UTF8\"?\u003e \u003cbeans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"\u003e \u003c!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --\u003e \u003ccontext:component-scan base-package=\"com.clover.controller\"/\u003e \u003c!-- 让Spring MVC不处理静态资源 --\u003e \u003cmvc:default-servlet-handler /\u003e \u003c!-- 支持mvc注解驱动 在spring中一般采用@Request Mapping注解来完成映射关系 要想使@Request Mapping注解生效 必须向上下文中注册Default Annotation Handler Mapping 和一个Annotation Method Handler Adapter实例 这两个实例分别在类级别和方法级别处理。 而annotation-driven配置帮助我们自动完成上述两个实例的注入。 --\u003e \u003cmvc:annotation-driven /\u003e \u003c!-- 视图解析器 --\u003e \u003cbean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\" id=\"internalResourceViewResolver\"\u003e \u003c!-- 前缀 --\u003e \u003cproperty ","date":"2021-07-04","objectID":"/ajax-json/:0:0","tags":["Ajax-Json"],"title":"Ajax-Json","uri":"/ajax-json/"}]